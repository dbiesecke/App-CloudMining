#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFF';
  package Algorithm::Diff;use strict;use integer;use vars qw($VERSION @EXPORT_OK);$VERSION=1.19_02;require Exporter;*import=\&Exporter::import;@EXPORT_OK=qw(prepare LCS LCSidx LCS_length diff sdiff compact_diff traverse_sequences traverse_balanced);sub _withPositionsOfInInterval {my$aCollection=shift;my$start=shift;my$end=shift;my$keyGen=shift;my%d;my$index;for ($index=$start ;$index <= $end ;$index++ ){my$element=$aCollection->[$index];my$key=&$keyGen($element,@_);if (exists($d{$key})){unshift (@{$d{$key}},$index)}else {$d{$key}=[$index]}}return wantarray ? %d : \%d}sub _replaceNextLargerWith {my ($array,$aValue,$high)=@_;$high ||=$#$array;if ($high==-1 || $aValue > $array->[-1]){push (@$array,$aValue);return$high + 1}my$low=0;my$index;my$found;while ($low <= $high){$index=($high + $low)/ 2;$found=$array->[$index];if ($aValue==$found){return undef}elsif ($aValue > $found){$low=$index + 1}else {$high=$index - 1}}$array->[$low]=$aValue;return$low}sub _longestCommonSubsequence {my$a=shift;my$b=shift;my$counting=shift;my$keyGen=shift;my$compare;if (ref($a)eq 'HASH'){my$tmp=$b;$b=$a;$a=$tmp}if (!ref($a)||!ref($b)){my@callerInfo=caller(1);die 'error: must pass array or hash references to ' .$callerInfo[3]}if (!defined($keyGen)){$keyGen=sub {$_[0]};$compare=sub {my ($a,$b)=@_;$a eq $b}}else {$compare=sub {my$a=shift;my$b=shift;&$keyGen($a,@_)eq &$keyGen($b,@_)}}my ($aStart,$aFinish,$matchVector)=(0,$#$a,[]);my ($prunedCount,$bMatches)=(0,{});if (ref($b)eq 'HASH'){$bMatches=$b}else {my ($bStart,$bFinish)=(0,$#$b);while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aStart],$b->[$bStart],@_)){$matchVector->[$aStart++ ]=$bStart++;$prunedCount++}while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aFinish],$b->[$bFinish],@_)){$matchVector->[$aFinish-- ]=$bFinish--;$prunedCount++}$bMatches=_withPositionsOfInInterval($b,$bStart,$bFinish,$keyGen,@_)}my$thresh=[];my$links=[];my ($i,$ai,$j,$k);for ($i=$aStart ;$i <= $aFinish ;$i++ ){$ai=&$keyGen($a->[$i],@_);if (exists($bMatches->{$ai})){$k=0;for$j (@{$bMatches->{$ai}}){if ($k and $thresh->[$k]> $j and $thresh->[$k - 1 ]< $j){$thresh->[$k]=$j}else {$k=_replaceNextLargerWith($thresh,$j,$k)}if (defined($k)){$links->[$k]=[($k ? $links->[$k - 1 ]: undef),$i,$j ]}}}}if (@$thresh){return$prunedCount + @$thresh if$counting;for (my$link=$links->[$#$thresh];$link ;$link=$link->[0]){$matchVector->[$link->[1]]=$link->[2]}}elsif ($counting){return$prunedCount}return wantarray ? @$matchVector : $matchVector}sub traverse_sequences {my$a=shift;my$b=shift;my$callbacks=shift || {};my$keyGen=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$finishedACallback=$callbacks->{'A_FINISHED'};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$finishedBCallback=$callbacks->{'B_FINISHED'};my$matchVector=_longestCommonSubsequence($a,$b,0,$keyGen,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai;for ($ai=0 ;$ai <= $#$matchVector ;$ai++ ){my$bLine=$matchVector->[$ai];if (defined($bLine)){&$discardBCallback($ai,$bi++,@_)while$bi < $bLine;&$matchCallback($ai,$bi++,@_)}else {&$discardACallback($ai,$bi,@_)}}while ($ai <= $lastA or $bi <= $lastB){if ($ai==$lastA + 1 and $bi <= $lastB){if (defined($finishedACallback)){&$finishedACallback($lastA,@_);$finishedACallback=undef}else {&$discardBCallback($ai,$bi++,@_)while$bi <= $lastB}}if ($bi==$lastB + 1 and $ai <= $lastA){if (defined($finishedBCallback)){&$finishedBCallback($lastB,@_);$finishedBCallback=undef}else {&$discardACallback($ai++,$bi,@_)while$ai <= $lastA}}&$discardACallback($ai++,$bi,@_)if$ai <= $lastA;&$discardBCallback($ai,$bi++,@_)if$bi <= $lastB}return 1}sub traverse_balanced {my$a=shift;my$b=shift;my$callbacks=shift || {};my$keyGen=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$changeCallback=$callbacks->{'CHANGE'};my$matchVector=_longestCommonSubsequence($a,$b,0,$keyGen,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai=0;my$ma=-1;my$mb;while (1){do {$ma++}while($ma <= $#$matchVector &&!defined$matchVector->[$ma]);last if$ma > $#$matchVector;$mb=$matchVector->[$ma];while ($ai < $ma || $bi < $mb){if ($ai < $ma && $bi < $mb){if (defined$changeCallback){&$changeCallback($ai++,$bi++,@_)}else {&$discardACallback($ai++,$bi,@_);&$discardBCallback($ai,$bi++,@_)}}elsif ($ai < $ma){&$discardACallback($ai++,$bi,@_)}else {&$discardBCallback($ai,$bi++,@_)}}&$matchCallback($ai++,$bi++,@_)}while ($ai <= $lastA || $bi <= $lastB){if ($ai <= $lastA && $bi <= $lastB){if (defined$changeCallback){&$changeCallback($ai++,$bi++,@_)}else {&$discardACallback($ai++,$bi,@_);&$discardBCallback($ai,$bi++,@_)}}elsif ($ai <= $lastA){&$discardACallback($ai++,$bi,@_)}else {&$discardBCallback($ai,$bi++,@_)}}return 1}sub prepare {my$a=shift;my$keyGen=shift;$keyGen=sub {$_[0]}unless defined($keyGen);return scalar _withPositionsOfInInterval($a,0,$#$a,$keyGen,@_)}sub LCS {my$a=shift;my$b=shift;my$matchVector=_longestCommonSubsequence($a,$b,0,@_);my@retval;my$i;for ($i=0 ;$i <= $#$matchVector ;$i++ ){if (defined($matchVector->[$i])){push (@retval,$a->[$i])}}return wantarray ? @retval : \@retval}sub LCS_length {my$a=shift;my$b=shift;return _longestCommonSubsequence($a,$b,1,@_)}sub LCSidx {my$a=shift @_;my$b=shift @_;my$match=_longestCommonSubsequence($a,$b,0,@_);my@am=grep defined$match->[$_],0..$#$match;my@bm=@{$match}[@am];return \@am,\@bm}sub compact_diff {my$a=shift @_;my$b=shift @_;my($am,$bm)=LCSidx($a,$b,@_);my@cdiff;my($ai,$bi)=(0,0);push@cdiff,$ai,$bi;while(1){while(@$am && $ai==$am->[0]&& $bi==$bm->[0]){shift @$am;shift @$bm;++$ai,++$bi}push@cdiff,$ai,$bi;last if!@$am;$ai=$am->[0];$bi=$bm->[0];push@cdiff,$ai,$bi}push@cdiff,0+@$a,0+@$b if$ai < @$a || $bi < @$b;return wantarray ? @cdiff : \@cdiff}sub diff {my$a=shift;my$b=shift;my$retval=[];my$hunk=[];my$discard=sub {push @$hunk,['-',$_[0],$a->[$_[0]]]};my$add=sub {push @$hunk,['+',$_[1],$b->[$_[1]]]};my$match=sub {push @$retval,$hunk if 0 < @$hunk;$hunk=[]};traverse_sequences($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add },@_);&$match();return wantarray ? @$retval : $retval}sub sdiff {my$a=shift;my$b=shift;my$retval=[];my$discard=sub {push (@$retval,['-',$a->[$_[0]],"" ])};my$add=sub {push (@$retval,['+',"",$b->[$_[1]]])};my$change=sub {push (@$retval,['c',$a->[$_[0]],$b->[$_[1]]])};my$match=sub {push (@$retval,['u',$a->[$_[0]],$b->[$_[1]]])};traverse_balanced($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add,CHANGE=>$change,},@_);return wantarray ? @$retval : $retval}my$Root=__PACKAGE__;package Algorithm::Diff::_impl;use strict;sub _Idx() {0}sub _End() {3}sub _Same() {4}sub _Base() {5}sub _Pos() {6}sub _Off() {7}sub _Min() {-2}sub Die {require Carp;Carp::confess(@_)}sub _ChkPos {my($me)=@_;return if$me->[_Pos];my$meth=(caller(1))[3];Die("Called $meth on 'reset' object")}sub _ChkSeq {my($me,$seq)=@_;return$seq + $me->[_Off]if 1==$seq || 2==$seq;my$meth=(caller(1))[3];Die("$meth: Invalid sequence number ($seq); must be 1 or 2")}sub getObjPkg {my($us)=@_;return ref$us if ref$us;return$us ."::_obj"}sub new {my($us,$seq1,$seq2,$opts)=@_;my@args;for($opts->{keyGen}){push@args,$_ if $_}for($opts->{keyGenArgs}){push@args,@$_ if $_}my$cdif=Algorithm::Diff::compact_diff($seq1,$seq2,@args);my$same=1;if(0==$cdif->[2]&& 0==$cdif->[3]){$same=0;splice @$cdif,0,2}my@obj=($cdif,$seq1,$seq2);$obj[_End]=(1+@$cdif)/2;$obj[_Same]=$same;$obj[_Base]=0;my$me=bless \@obj,$us->getObjPkg();$me->Reset(0);return$me}sub Reset {my($me,$pos)=@_;$pos=int($pos || 0);$pos += $me->[_End]if$pos < 0;$pos=0 if$pos < 0 || $me->[_End]<= $pos;$me->[_Pos]=$pos ||!1;$me->[_Off]=2*$pos - 1;return$me}sub Base {my($me,$base)=@_;my$oldBase=$me->[_Base];$me->[_Base]=0+$base if defined$base;return$oldBase}sub Copy {my($me,$pos,$base)=@_;my@obj=@$me;my$you=bless \@obj,ref($me);$you->Reset($pos)if defined$pos;$you->Base($base);return$you}sub Next {my($me,$steps)=@_;$steps=1 if!defined$steps;if($steps){my$pos=$me->[_Pos];my$new=$pos + $steps;$new=0 if$pos && $new < 0;$me->Reset($new)}return$me->[_Pos]}sub Prev {my($me,$steps)=@_;$steps=1 if!defined$steps;my$pos=$me->Next(-$steps);$pos -= $me->[_End]if$pos;return$pos}sub Diff {my($me)=@_;$me->_ChkPos();return 0 if$me->[_Same]==(1 & $me->[_Pos]);my$ret=0;my$off=$me->[_Off];for my$seq (1,2){$ret |=$seq if$me->[_Idx][$off + $seq + _Min ]< $me->[_Idx][$off + $seq ]}return$ret}sub Min {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);$base=$me->[_Base]if!defined$base;return$base + $me->[_Idx][$off + _Min ]}sub Max {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);$base=$me->[_Base]if!defined$base;return$base + $me->[_Idx][$off ]-1}sub Range {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);if(!wantarray){return$me->[_Idx][$off ]- $me->[_Idx][$off + _Min ]}$base=$me->[_Base]if!defined$base;return ($base + $me->[_Idx][$off + _Min ]).. ($base + $me->[_Idx][$off ]- 1)}sub Items {my($me,$seq)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);if(!wantarray){return$me->[_Idx][$off ]- $me->[_Idx][$off + _Min ]}return @{$me->[$seq]}[$me->[_Idx][$off + _Min ].. ($me->[_Idx][$off ]- 1)]}sub Same {my($me)=@_;$me->_ChkPos();return wantarray ? (): 0 if$me->[_Same]!=(1 & $me->[_Pos]);return$me->Items(1)}my%getName;BEGIN {%getName=(same=>\&Same,diff=>\&Diff,base=>\&Base,min=>\&Min,max=>\&Max,range=>\&Range,items=>\&Items,)}sub Get {my$me=shift @_;$me->_ChkPos();my@value;for my$arg (@_){for my$word (split ' ',$arg){my$meth;if($word !~ /^(-?\d+)?([a-zA-Z]+)([12])?$/ || not $meth=$getName{lc $2 }){Die($Root,", Get: Invalid request ($word)")}my($base,$name,$seq)=($1,$2,$3);push@value,scalar(4==length($name)? $meth->($me): $meth->($me,$seq,$base))}}if(wantarray){return@value}elsif(1==@value){return$value[0]}Die(0+@value," values requested from ",$Root,"'s Get in scalar context")}my$Obj=getObjPkg($Root);no strict 'refs';for my$meth (qw(new getObjPkg)){*{$Root."::".$meth}=\&{$meth};*{$Obj ."::".$meth}=\&{$meth}}for my$meth (qw(Next Prev Reset Copy Base Diff Same Items Range Min Max Get _ChkPos _ChkSeq)){*{$Obj."::".$meth}=\&{$meth}}1;
ALGORITHM_DIFF

$fatpacked{"Algorithm/DiffOld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFFOLD';
  package Algorithm::DiffOld;use strict;use vars qw($VERSION @EXPORT_OK @ISA @EXPORT);use integer;require Exporter;@ISA=qw(Exporter);@EXPORT=qw();@EXPORT_OK=qw(LCS diff traverse_sequences);$VERSION=1.10;sub _replaceNextLargerWith {my ($array,$aValue,$high)=@_;$high ||=$#$array;if ($high==-1 || $aValue > $array->[-1 ]){push(@$array,$aValue);return$high + 1}my$low=0;my$index;my$found;while ($low <= $high){$index=($high + $low)/ 2;$found=$array->[$index ];if ($aValue==$found){return undef}elsif ($aValue > $found){$low=$index + 1}else {$high=$index - 1}}$array->[$low ]=$aValue;return$low}sub _longestCommonSubsequence {my$a=shift;my$b=shift;my$compare=shift || sub {my$a=shift;my$b=shift;$a eq $b};my$aStart=0;my$aFinish=$#$a;my$bStart=0;my$bFinish=$#$b;my$matchVector=[];while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aStart ],$b->[$bStart ],@_)){$matchVector->[$aStart++ ]=$bStart++}while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aFinish ],$b->[$bFinish ],@_)){$matchVector->[$aFinish-- ]=$bFinish--}my$thresh=[];my$links=[];my ($i,$ai,$j,$k);for ($i=$aStart;$i <= $aFinish;$i++ ){$k=0;for ($j=$bFinish;$j >= $bStart;$j--){next if!&$compare($a->[$i],$b->[$j],@_);if ($k and $thresh->[$k ]> $j and $thresh->[$k - 1 ]< $j){$thresh->[$k ]=$j}else {$k=_replaceNextLargerWith($thresh,$j,$k)}if (defined($k)){$links->[$k ]=[($k ? $links->[$k - 1 ]: undef),$i,$j ]}}}if (@$thresh){for (my$link=$links->[$#$thresh ];$link;$link=$link->[0 ]){$matchVector->[$link->[1 ]]=$link->[2 ]}}return wantarray ? @$matchVector : $matchVector}sub traverse_sequences {my$a=shift;my$b=shift;my$callbacks=shift || {};my$compare=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$finishedACallback=$callbacks->{'A_FINISHED'};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$finishedBCallback=$callbacks->{'B_FINISHED'};my$matchVector=_longestCommonSubsequence($a,$b,$compare,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai;for ($ai=0;$ai <= $#$matchVector;$ai++ ){my$bLine=$matchVector->[$ai ];if (defined($bLine)){&$discardBCallback($ai,$bi++,@_)while$bi < $bLine;&$matchCallback($ai,$bi++,@_)}else {&$discardACallback($ai,$bi,@_)}}if (defined($finishedBCallback)&& $ai <= $lastA){&$finishedBCallback($bi,@_)}else {&$discardACallback($ai++,$bi,@_)while ($ai <= $lastA)}if (defined($finishedACallback)&& $bi <= $lastB){&$finishedACallback($ai,@_)}else {&$discardBCallback($ai,$bi++,@_)while ($bi <= $lastB)}return 1}sub LCS {my$a=shift;my$matchVector=_longestCommonSubsequence($a,@_);my@retval;my$i;for ($i=0;$i <= $#$matchVector;$i++ ){if (defined($matchVector->[$i ])){push(@retval,$a->[$i ])}}return wantarray ? @retval : \@retval}sub diff {my$a=shift;my$b=shift;my$retval=[];my$hunk=[];my$discard=sub {push(@$hunk,['-',$_[0 ],$a->[$_[0 ]]])};my$add=sub {push(@$hunk,['+',$_[1 ],$b->[$_[1 ]]])};my$match=sub {push(@$retval,$hunk)if scalar(@$hunk);$hunk=[]};traverse_sequences($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add },@_);&$match();return wantarray ? @$retval : $retval}1;
ALGORITHM_DIFFOLD

$fatpacked{"App/CloudMining.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CLOUDMINING';
  require Data::Dumper;require File::HomeDir;package App::CloudMining;use MooseX::App qw(BashCompletion ConfigHome Color Version Typo Man Term);option 'debug'=>(is=>'rw',isa=>'Bool',documentation=>q[set Debug mode for verbose ],);has 'private'=>(is=>'rw',);1;
APP_CLOUDMINING

$fatpacked{"App/Prove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE';
  package App::Prove;use strict;use warnings;use TAP::Harness::Env;use Text::ParseWords qw(shellwords);use File::Spec;use Getopt::Long;use App::Prove::State;use Carp;use base 'TAP::Object';our$VERSION='3.33';use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>$^O eq 'VMS';use constant IS_UNIXY=>!(IS_VMS || IS_WIN32);use constant STATE_FILE=>IS_UNIXY ? '.prove' : '_prove';use constant RC_FILE=>IS_UNIXY ? '.proverc' : '_proverc';use constant PLUGINS=>'App::Prove::Plugin';my@ATTR;BEGIN {@ATTR=qw(archive argv blib show_count color directives exec failures comments formatter harness includes modules plugins jobs lib merge parse quiet really_quiet recurse backwards shuffle taint_fail taint_warn timer verbose warnings_fail warnings_warn show_help show_man show_version state_class test_args state dry extensions ignore_exit rules state_manager normalize sources tapversion trap);__PACKAGE__->mk_methods(@ATTR)}sub _initialize {my$self=shift;my$args=shift || {};my@is_array=qw(argv rc_opts includes modules state plugins rules sources);for my$key (@is_array){$self->{$key}=[]}for my$attr (@ATTR){if (exists$args->{$attr}){$self->{$attr}=$args->{$attr}}}$self->state_class('App::Prove::State');return$self}sub add_rc_file {my ($self,$rc_file)=@_;local*RC;open RC,"<$rc_file" or croak "Can't read $rc_file ($!)";while (defined(my$line=<RC>)){push @{$self->{rc_opts}},grep {defined and not /^#/}$line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg}close RC}sub process_args {my$self=shift;my@rc=RC_FILE;unshift@rc,glob '~/' .RC_FILE if IS_UNIXY;my@args;while (defined(my$arg=shift)){if ($arg eq '--norc'){@rc=()}elsif ($arg eq '--rc'){defined(my$rc=shift)or croak "Missing argument to --rc";push@rc,$rc}elsif ($arg =~ m{^--rc=(.+)$}){push@rc,$1}else {push@args,$arg}}if (defined(my$stop_at=_first_pos('::',@args))){my@test_args=splice@args,$stop_at;shift@test_args;$self->{test_args}=\@test_args}$self->add_rc_file($_)for grep -f,@rc;unshift@args,@{$self->{rc_opts}};if (my@bad=map {"-$_"}grep {/^-(man|help)$/}@args){die "Long options should be written with two dashes: ",join(', ',@bad),"\n"}{local@ARGV=@args;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));GetOptions('v|verbose'=>\$self->{verbose},'f|failures'=>\$self->{failures},'o|comments'=>\$self->{comments},'l|lib'=>\$self->{lib},'b|blib'=>\$self->{blib},'s|shuffle'=>\$self->{shuffle},'color!'=>\$self->{color},'colour!'=>\$self->{color},'count!'=>\$self->{show_count},'c'=>\$self->{color},'D|dry'=>\$self->{dry},'ext=s@'=>sub {my ($opt,$val)=@_;push @{$self->{extensions}||=[]},$val},'harness=s'=>\$self->{harness},'ignore-exit'=>\$self->{ignore_exit},'source=s@'=>$self->{sources},'formatter=s'=>\$self->{formatter},'r|recurse'=>\$self->{recurse},'reverse'=>\$self->{backwards},'p|parse'=>\$self->{parse},'q|quiet'=>\$self->{quiet},'Q|QUIET'=>\$self->{really_quiet},'e|exec=s'=>\$self->{exec},'m|merge'=>\$self->{merge},'I=s@'=>$self->{includes},'M=s@'=>$self->{modules},'P=s@'=>$self->{plugins},'state=s@'=>$self->{state},'directives'=>\$self->{directives},'h|help|?'=>\$self->{show_help},'H|man'=>\$self->{show_man},'V|version'=>\$self->{show_version},'a|archive=s'=>\$self->{archive},'j|jobs=i'=>\$self->{jobs},'timer'=>\$self->{timer},'T'=>\$self->{taint_fail},'t'=>\$self->{taint_warn},'W'=>\$self->{warnings_fail},'w'=>\$self->{warnings_warn},'normalize'=>\$self->{normalize},'rules=s@'=>$self->{rules},'tapversion=s'=>\$self->{tapversion},'trap'=>\$self->{trap},)or croak('Unable to continue');$self->{argv}=[@ARGV]}return}sub _first_pos {my$want=shift;for (0 .. $#_){return $_ if $_[$_]eq $want}return}sub _help {my ($self,$verbosity)=@_;eval('use Pod::Usage 1.12 ()');if (my$err=$@){die 'Please install Pod::Usage for the --help option ' .'(or try `perldoc prove`.)' ."\n ($@)"}Pod::Usage::pod2usage({-verbose=>$verbosity });return}sub _color_default {my$self=shift;return -t STDOUT &&!$ENV{HARNESS_NOTTY}&&!IS_WIN32}sub _get_args {my$self=shift;my%args;$args{trap}=1 if$self->trap;if (defined$self->color ? $self->color : $self->_color_default){$args{color}=1}if (!defined$self->show_count){$args{show_count}=1}else {$args{show_count}=$self->show_count}if ($self->archive){$self->require_harness(archive=>'TAP::Harness::Archive');$args{archive}=$self->archive}if (my$jobs=$self->jobs){$args{jobs}=$jobs}if (my$harness_opt=$self->harness){$self->require_harness(harness=>$harness_opt)}if (my$formatter=$self->formatter){$args{formatter_class}=$formatter}for my$handler (@{$self->sources}){my ($name,$config)=$self->_parse_source($handler);$args{sources}->{$name}=$config}if ($self->ignore_exit){$args{ignore_exit}=1}if ($self->taint_fail && $self->taint_warn){die '-t and -T are mutually exclusive'}if ($self->warnings_fail && $self->warnings_warn){die '-w and -W are mutually exclusive'}for my$a (qw(lib switches)){my$method="_get_$a";my$val=$self->$method();$args{$a}=$val if defined$val}my%verb_map=(verbose=>1,quiet=>-1,really_quiet=>-2,);my@verb_adj=grep {$_}map {$self->$_()? $verb_map{$_}: 0}keys%verb_map;die "Only one of verbose, quiet or really_quiet should be specified\n" if@verb_adj > 1;$args{verbosity}=shift@verb_adj || 0;for my$a (qw(merge failures comments timer directives normalize)){$args{$a}=1 if$self->$a()}$args{errors}=1 if$self->parse;$args{exec}=[split(/\s+/,$self->exec)]if (defined($self->exec));$args{version}=$self->tapversion if defined($self->tapversion);if (defined(my$test_args=$self->test_args)){$args{test_args}=$test_args}if (@{$self->rules}){my@rules;for (@{$self->rules}){if (/^par=(.*)/){push@rules,$1}elsif (/^seq=(.*)/){push@rules,{seq=>$1 }}}$args{rules}={par=>[@rules]}}$args{harness_class}=$self->{harness_class}if$self->{harness_class};return \%args}sub _find_module {my ($self,$class,@search)=@_;croak "Bad module name $class" unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;for my$pfx (@search){my$name=join('::',$pfx,$class);eval "require $name";return$name unless $@}eval "require $class";return$class unless $@;return}sub _load_extension {my ($self,$name,@search)=@_;my@args=();if ($name =~ /^(.*?)=(.*)/){$name=$1;@args=split(/,/,$2)}if (my$class=$self->_find_module($name,@search)){$class->import(@args);if ($class->can('load')){$class->load({app_prove=>$self,args=>[@args]})}}else {croak "Can't load module $name"}}sub _load_extensions {my ($self,$ext,@search)=@_;$self->_load_extension($_,@search)for @$ext}sub _parse_source {my ($self,$handler)=@_;(my$opt_name=lc$handler)=~ s/::/-/g;local@ARGV=@{$self->{argv}};my%config;Getopt::Long::GetOptions("$opt_name-option=s%"=>sub {my ($name,$k,$v)=@_;if ($v =~ /(?<!\\)=/){croak "Option $name must be consistently used as a hash" if exists$config{$k}&& ref$config{$k}ne 'HASH';$config{$k}||={};my ($hk,$hv)=split /(?<!\\)=/,$v,2;$config{$k}{$hk}=$hv}else {$v =~ s/\\=/=/g;if (exists$config{$k}){$config{$k}=[$config{$k}]unless ref$config{$k}eq 'ARRAY';push @{$config{$k}}=>$v}else {$config{$k}=$v}}});$self->{argv}=\@ARGV;return ($handler,\%config)}sub run {my$self=shift;unless ($self->state_manager){$self->state_manager($self->state_class->new({store=>STATE_FILE }))}if ($self->show_help){$self->_help(1)}elsif ($self->show_man){$self->_help(2)}elsif ($self->show_version){$self->print_version}elsif ($self->dry){print "$_\n" for$self->_get_tests}else {$self->_load_extensions($self->modules);$self->_load_extensions($self->plugins,PLUGINS);local$ENV{TEST_VERBOSE}=1 if$self->verbose;return$self->_runtests($self->_get_args,$self->_get_tests)}return 1}sub _get_tests {my$self=shift;my$state=$self->state_manager;my$ext=$self->extensions;$state->extensions($ext)if defined$ext;if (defined(my$state_switch=$self->state)){$state->apply_switch(@$state_switch)}my@tests=$state->get_tests($self->recurse,@{$self->argv});$self->_shuffle(@tests)if$self->shuffle;@tests=reverse@tests if$self->backwards;return@tests}sub _runtests {my ($self,$args,@tests)=@_;my$harness=TAP::Harness::Env->create($args);my$state=$self->state_manager;$harness->callback(after_test=>sub {$state->observe_test(@_)});$harness->callback(after_runtests=>sub {$state->commit(@_)});my$aggregator=$harness->runtests(@tests);return!$aggregator->has_errors}sub _get_switches {my$self=shift;my@switches;if ($self->taint_fail){push@switches,'-T'}elsif ($self->taint_warn){push@switches,'-t'}if ($self->warnings_fail){push@switches,'-W'}elsif ($self->warnings_warn){push@switches,'-w'}return@switches ? \@switches : ()}sub _get_lib {my$self=shift;my@libs;if ($self->lib){push@libs,'lib'}if ($self->blib){push@libs,'blib/lib','blib/arch'}if (@{$self->includes}){push@libs,@{$self->includes}}@libs=map {File::Spec->rel2abs($_)}@libs;return@libs ? \@libs : ()}sub _shuffle {my$self=shift;my$i=@_;while ($i){my$j=rand$i--;@_[$i,$j ]=@_[$j,$i ]}return}sub require_harness {my ($self,$for,$class)=@_;my ($class_name)=$class =~ /^(\w+(?:::\w+)*)/;$class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;eval("use $class;");die "$class_name is required to use the --$for feature: $@" if $@;$self->{harness_class}=$class_name;return}sub print_version {my$self=shift;printf("TAP::Harness v%s and Perl v%vd\n",$TAP::Harness::VERSION,$^V);return}1;
APP_PROVE

$fatpacked{"App/Prove/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE';
  package App::Prove::State;use strict;use warnings;use File::Find;use File::Spec;use Carp;use App::Prove::State::Result;use TAP::Parser::YAMLish::Reader ();use TAP::Parser::YAMLish::Writer ();use base 'TAP::Base';BEGIN {__PACKAGE__->mk_methods('result_class')}use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant NEED_GLOB=>IS_WIN32;our$VERSION='3.33';sub new {my$class=shift;my%args=%{shift || {}};my$self=bless {select=>[],seq=>1,store=>delete$args{store},extensions=>(delete$args{extensions}|| ['.t']),result_class=>(delete$args{result_class}|| 'App::Prove::State::Result'),},$class;$self->{_}=$self->result_class->new({tests=>{},generation=>1,});my$store=$self->{store};$self->load($store)if defined$store && -f $store;return$self}sub extensions {my$self=shift;$self->{extensions}=shift if @_;return$self->{extensions}}sub results {my$self=shift;$self->{_}|| $self->result_class->new}sub commit {my$self=shift;if ($self->{should_save}){$self->save}}sub apply_switch {my$self=shift;my@opts=@_;my$last_gen=$self->results->generation - 1;my$last_run_time=$self->results->last_run_time;my$now=$self->get_time;my@switches=map {split /,/}@opts;my%handler=(last=>sub {$self->_select(limit=>shift,where=>sub {$_->generation >= $last_gen},order=>sub {$_->sequence})},failed=>sub {$self->_select(limit=>shift,where=>sub {$_->result!=0},order=>sub {-$_->result})},passed=>sub {$self->_select(limit=>shift,where=>sub {$_->result==0})},all=>sub {$self->_select(limit=>shift)},todo=>sub {$self->_select(limit=>shift,where=>sub {$_->num_todo!=0},order=>sub {-$_->num_todo})},hot=>sub {$self->_select(limit=>shift,where=>sub {defined $_->last_fail_time},order=>sub {$now - $_->last_fail_time})},slow=>sub {$self->_select(limit=>shift,order=>sub {-$_->elapsed})},fast=>sub {$self->_select(limit=>shift,order=>sub {$_->elapsed})},new=>sub {$self->_select(limit=>shift,order=>sub {-$_->mtime})},old=>sub {$self->_select(limit=>shift,order=>sub {$_->mtime})},fresh=>sub {$self->_select(limit=>shift,where=>sub {$_->mtime >= $last_run_time})},save=>sub {$self->{should_save}++},adrian=>sub {unshift@switches,qw(hot all save)},);while (defined(my$ele=shift@switches)){my ($opt,$arg)=($ele =~ /^([^:]+):(.*)/)? ($1,$2): ($ele,undef);my$code=$handler{$opt}|| croak "Illegal state option: $opt";$code->($arg)}return}sub _select {my ($self,%spec)=@_;push @{$self->{select}},\%spec}sub get_tests {my$self=shift;my$recurse=shift;my@argv=@_;my%seen;my@selected=$self->_query;unless (@argv || @{$self->{select}}){@argv=$recurse ? '.' : 't';croak qq{No tests named and '@argv' directory not found} unless -d $argv[0]}push@selected,$self->_get_raw_tests($recurse,@argv)if@argv;return grep {!$seen{$_}++}@selected}sub _query {my$self=shift;if (my@sel=@{$self->{select}}){warn "No saved state, selection will be empty\n" unless$self->results->num_tests;return map {$self->_query_clause($_)}@sel}return}sub _query_clause {my ($self,$clause)=@_;my@got;my$results=$self->results;my$where=$clause->{where}|| sub {1};for my$name ($results->test_names){next unless -f $name;local $_=$results->test($name);push@got,$name if$where->()}if (my$order=$clause->{order}){@got=map {$_->[0]}sort {(defined$b->[1]<=> defined$a->[1])|| (($a->[1]|| 0)<=> ($b->[1]|| 0))}map {[$_,do {local $_=$results->test($_);$order->()}]}@got}if (my$limit=$clause->{limit}){@got=splice@got,0,$limit if@got > $limit}return@got}sub _get_raw_tests {my$self=shift;my$recurse=shift;my@argv=@_;my@tests;if (NEED_GLOB){eval "use File::Glob::Windows";@argv=map {glob "$_"}@argv}my$extensions=$self->{extensions};for my$arg (@argv){if ('-' eq $arg){push@argv=><STDIN>;chomp(@argv);next}push@tests,sort -d $arg ? $recurse ? $self->_expand_dir_recursive($arg,$extensions): map {glob(File::Spec->catfile($arg,"*$_"))}@{$extensions}: $arg}return@tests}sub _expand_dir_recursive {my ($self,$dir,$extensions)=@_;my@tests;my$ext_string=join('|',map {quotemeta}@{$extensions});find({follow=>1,follow_skip=>2,wanted=>sub {-f && /(?:$ext_string)$/ && push@tests=>$File::Find::name}},$dir);return@tests}sub observe_test {my ($self,$test_info,$parser)=@_;my$name=$test_info->[0];my$fail=scalar($parser->failed)+ ($parser->has_problems ? 1 : 0);my$todo=scalar($parser->todo);my$start_time=$parser->start_time;my$end_time=$parser->end_time,my$test=$self->results->test($name);$test->sequence($self->{seq}++);$test->generation($self->results->generation);$test->run_time($end_time);$test->result($fail);$test->num_todo($todo);$test->elapsed($end_time - $start_time);$test->parser($parser);if ($fail){$test->total_failures($test->total_failures + 1);$test->last_fail_time($end_time)}else {$test->total_passes($test->total_passes + 1);$test->last_pass_time($end_time)}}sub save {my ($self)=@_;my$store=$self->{store}or return;$self->results->last_run_time($self->get_time);my$writer=TAP::Parser::YAMLish::Writer->new;local*FH;open FH,">$store" or croak "Can't write $store ($!)";$writer->write($self->results->raw,\*FH);close FH}sub load {my ($self,$name)=@_;my$reader=TAP::Parser::YAMLish::Reader->new;local*FH;open FH,"<$name" or croak "Can't read $name ($!)";$self->{_}=$self->result_class->new($reader->read(sub {my$line=<FH>;defined$line && chomp$line;return$line}));close FH;$self->_regen_seq;$self->_prune_and_stamp;$self->results->generation($self->results->generation + 1)}sub _prune_and_stamp {my$self=shift;my$results=$self->results;my@tests=$self->results->tests;for my$test (@tests){my$name=$test->name;if (my@stat=stat$name){$test->mtime($stat[9])}else {$results->remove($name)}}}sub _regen_seq {my$self=shift;for my$test ($self->results->tests){$self->{seq}=$test->sequence + 1 if defined$test->sequence && $test->sequence >= $self->{seq}}}1;
APP_PROVE_STATE

$fatpacked{"App/Prove/State/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT';
  package App::Prove::State::Result;use strict;use warnings;use Carp 'croak';use App::Prove::State::Result::Test;use constant STATE_VERSION=>1;our$VERSION='3.33';sub new {my ($class,$arg_for)=@_;$arg_for ||={};my%instance_data=%$arg_for;$instance_data{version}=$class->state_version;my$tests=delete$instance_data{tests}|| {};my$self=bless \%instance_data=>$class;$self->_initialize($tests);return$self}sub _initialize {my ($self,$tests)=@_;my%tests;while (my ($name,$test)=each %$tests){$tests{$name}=$self->test_class->new({%$test,name=>$name})}$self->tests(\%tests);return$self}sub state_version {STATE_VERSION}sub test_class {return 'App::Prove::State::Result::Test'}my%methods=(generation=>{method=>'generation',default=>0 },last_run_time=>{method=>'last_run_time',default=>undef },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub tests {my$self=shift;if (@_){$self->{tests}=shift;return$self}my%tests=%{$self->{tests}};my@tests=sort {$a->sequence <=> $b->sequence}values%tests;return wantarray ? @tests : \@tests}sub test {my ($self,$name)=@_;croak("test() requires a test name")unless defined$name;my$tests=$self->{tests}||={};if (my$test=$tests->{$name}){return$test}else {my$test=$self->test_class->new({name=>$name });$self->{tests}->{$name}=$test;return$test}}sub test_names {my$self=shift;return map {$_->name}$self->tests}sub remove {my ($self,$name)=@_;delete$self->{tests}->{$name};return$self}sub num_tests {keys %{shift->{tests}}}sub raw {my$self=shift;my%raw=%$self;my%tests;for my$test ($self->tests){$tests{$test->name }=$test->raw}$raw{tests}=\%tests;return \%raw}1;
APP_PROVE_STATE_RESULT

$fatpacked{"App/Prove/State/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT_TEST';
  package App::Prove::State::Result::Test;use strict;use warnings;our$VERSION='3.33';my%methods=(name=>{method=>'name' },elapsed=>{method=>'elapsed',default=>0 },gen=>{method=>'generation',default=>1 },last_pass_time=>{method=>'last_pass_time',default=>undef },last_fail_time=>{method=>'last_fail_time',default=>undef },last_result=>{method=>'result',default=>0 },last_run_time=>{method=>'run_time',default=>undef },last_todo=>{method=>'num_todo',default=>0 },mtime=>{method=>'mtime',default=>undef },seq=>{method=>'sequence',default=>1 },total_passes=>{method=>'total_passes',default=>0 },total_failures=>{method=>'total_failures',default=>0 },parser=>{method=>'parser' },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub new {my ($class,$arg_for)=@_;$arg_for ||={};bless$arg_for=>$class}sub raw {my$self=shift;my%raw=%$self;delete$raw{name};delete$raw{parser};return \%raw}1;
APP_PROVE_STATE_RESULT_TEST

$fatpacked{"B/Hooks/EndOfScope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope;{$B::Hooks::EndOfScope::VERSION='0.13'}BEGIN {$B::Hooks::EndOfScope::AUTHORITY='cpan:FLORA'}use strict;use warnings;use 5.008001;BEGIN {require Module::Implementation;Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>['on_scope_end' ],)->()}use Sub::Exporter::Progressive -setup=>{exports=>['on_scope_end' ],groups=>{default=>['on_scope_end']},};1;
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;{$B::Hooks::EndOfScope::PP::VERSION='0.13'}BEGIN {$B::Hooks::EndOfScope::PP::AUTHORITY='cpan:FLORA'}use warnings;use strict;use Module::Runtime 'require_module';use constant _PERL_VERSION=>"$]";BEGIN {if (_PERL_VERSION =~ /^5\.009/){die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"}elsif (_PERL_VERSION < '5.010'){require_module('B::Hooks::EndOfScope::PP::HintHash');*on_scope_end=\&B::Hooks::EndOfScope::PP::HintHash::on_scope_end}else {require_module('B::Hooks::EndOfScope::PP::FieldHash');*on_scope_end=\&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end}}use Sub::Exporter::Progressive -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};sub __invoke_callback {local $@;eval {$_[0]->();1}or do {my$err=$@;require Carp;Carp::cluck((join ' ','A scope-end callback raised an exception, which can not be propagated when','B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE','EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete','exception text, followed by a stack-trace of the callback execution:',)."\n\n$err\n\r");sleep 1 if -t *STDERR}}1;
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  package B::Hooks::EndOfScope::PP::FieldHash;use strict;use warnings;use warnings;use strict;use Tie::Hash ();use Hash::Util::FieldHash 'fieldhash';fieldhash my%hh;{package B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;use base 'Tie::StdHash';sub DELETE {my$ret=shift->SUPER::DELETE(@_);B::Hooks::EndOfScope::PP::__invoke_callback($_)for @$ret;$ret}}sub on_scope_end (&) {$^H |=0x020000;tie(%hh,'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')unless tied%hh;push @{$hh{\%^H}||=[]},shift}1;
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  package B::Hooks::EndOfScope::PP::HintHash;use strict;use warnings;use Scalar::Util ();sub on_scope_end (&) {$^H |=0x020000;push @{$^H{sprintf '__B_H_EOS__guardstack_0X%x',Scalar::Util::refaddr(\%^H)}||=bless ([],'B::Hooks::EndOfScope::PP::_SG_STACK')},shift}package B::Hooks::EndOfScope::PP::_SG_STACK;use warnings;use strict;sub DESTROY {B::Hooks::EndOfScope::PP::__invoke_callback($_)for @{$_[0]}}1;
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;{$B::Hooks::EndOfScope::XS::VERSION='0.13'}BEGIN {$B::Hooks::EndOfScope::XS::AUTHORITY='cpan:FLORA'}use strict;use warnings;BEGIN {require Module::Runtime;Module::Runtime::use_module('Variable::Magic','0.48')}use Sub::Exporter::Progressive -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};my$wiz=Variable::Magic::wizard data=>sub {[$_[1]]},free=>sub {$_->()for @{$_[1]};()},local=>\undef ;sub on_scope_end (&) {my$cb=shift;$^H |=0x020000;if (my$stack=Variable::Magic::getdata %^H,$wiz){push @{$stack},$cb}else {Variable::Magic::cast %^H,$wiz,$cb}}1;
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.25';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$layers)=@_;my%seen=(unix=>1,perlio=>1);my@unique=grep {!$seen{$_}++}@$layers;binmode($fh,join(":",":raw",@unique))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar tmpnam();if ($IS_WIN32){local $@;eval "use Win32API::File qw/CloseHandle GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which})}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){CloseHandle(GetOsFHandle($_))for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||=File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,@result);{local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;local $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if (defined wantarray or ($do_tee && keys%localize)){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carp/Clan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_CLAN';
  @DB::args=();package Carp::Clan;use strict;use vars qw($MaxEvalLen $MaxArgLen $MaxArgNums $Verbose $VERSION);use overload ();$MaxEvalLen=0;$MaxArgLen=64;$MaxArgNums=8;$Verbose=0;$VERSION='6.04';sub _longmsg {return (@_)if (ref $_[0]);local $_;my ($pack,$file,$line,$sub,$hargs,$eval,$require,@parms,$push);my$error=join('',@_);my$msg='';my$i=0;while (do {{package DB;($pack,$file,$line,$sub,$hargs,undef,$eval,$require)=caller($i++)}}){next if ($pack eq 'Carp::Clan');if ($error eq ''){if (defined$eval){$eval =~ s/([\\\'])/\\$1/g unless ($require);$eval =~ s/([\x00-\x1F\x7F-\xFF])/sprintf("\\x%02X",ord($1))/eg;substr($eval,$MaxEvalLen)='...' if ($MaxEvalLen && length($eval)> $MaxEvalLen);if ($require){$sub="require $eval"}else {$sub="eval '$eval'"}}elsif ($sub eq '(eval)'){$sub='eval {...}'}else {@parms=();if ($hargs){$push=0;@parms=@DB::args ;if ($MaxArgNums and @parms > $MaxArgNums){$#parms=$MaxArgNums;pop(@parms);$push=1}for (@parms){if (defined $_){if (ref $_){$_=overload::StrVal($_)}else {unless (/^-?\d+(?:\.\d+(?:[eE][+-]\d+)?)?$/){s/([\\\'])/\\$1/g;s/([\x00-\x1F\x7F-\xFF])/sprintf("\\x%02X",ord($1))/eg;substr($_,$MaxArgLen)='...' if ($MaxArgLen and length($_)> $MaxArgLen);$_="'$_'"}}}else {$_='undef'}}push(@parms,'...')if ($push)}$sub .= '(' .join(', ',@parms).')'}if ($msg eq ''){$msg="$sub called"}else {$msg .= "\t$sub called"}}else {$msg=quotemeta($sub);if ($error =~ /\b$msg\b/){$msg=$error}else {if ($sub =~ /::/){$msg="$sub(): $error"}else {$msg="$sub: $error"}}}$msg .= " at $file line $line\n" unless ($error =~ /\n$/);$error=''}$msg ||=$error;$msg =~ tr/\0//d;$msg}sub _shortmsg {my$pattern=shift;my$verbose=shift;return (@_)if (ref $_[0]);goto&_longmsg if ($Verbose or $verbose);my ($pack,$file,$line,$sub);my$error=join('',@_);my$msg='';my$i=0;while (($pack,$file,$line,$sub)=caller($i++)){next if ($pack eq 'Carp::Clan' or $pack =~ /$pattern/);if ($error eq ''){$msg="$sub() called"}else {$msg=quotemeta($sub);if ($error =~ /\b$msg\b/){$msg=$error}else {if ($sub =~ /::/){$msg="$sub(): $error"}else {$msg="$sub: $error"}}}$msg .= " at $file line $line\n" unless ($error =~ /\n$/);$msg =~ tr/\0//d;return$msg}goto&_longmsg}sub croak {my$callpkg=caller(0);my$pattern=($callpkg eq 'main')? '^:::' : "^$callpkg\$";die _shortmsg($pattern,0,@_)}sub confess {die _longmsg(@_)}sub carp {my$callpkg=caller(0);my$pattern=($callpkg eq 'main')? '^:::' : "^$callpkg\$";warn _shortmsg($pattern,0,@_)}sub cluck {warn _longmsg(@_)}sub import {my$pkg=shift;my$callpkg=caller(0);my$pattern=($callpkg eq 'main')? '^:::' : "^$callpkg\$";my$verbose=0;my$item;my$file;for$item (@_){if ($item =~ /^\d/){if ($VERSION < $item){$file="$pkg.pm";$file =~ s!::!/!g;$file=$INC{$file};die _shortmsg('^:::',0,"$pkg $item required--this is only version $VERSION ($file)")}}elsif ($item =~ /^verbose$/i){$verbose=1}else {$pattern=$item}}if ($] >= 5.005){eval '$pattern = qr/$pattern/;'}else {eval {$pkg =~ /$pattern/}}if ($@){$@ =~ s/\s+$//;$@ =~ s/\s+at\s.+$//;die _shortmsg('^:::',0,$@)}{local ($^W)=0;no strict "refs";*{"${callpkg}::croak"}=sub {die _shortmsg($pattern,$verbose,@_)};*{"${callpkg}::confess"}=sub {die _longmsg (@_)};*{"${callpkg}::carp"}=sub {warn _shortmsg($pattern,$verbose,@_)};*{"${callpkg}::cluck"}=sub {warn _longmsg (@_)}}}1;
CARP_CLAN

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;use strict qw(vars subs);use vars qw($VERSION);$VERSION='0.08';sub mk_classdata {my ($declaredclass,$attribute,$data)=@_;if(ref$declaredclass){require Carp;Carp::croak("mk_classdata() is a class method, not an object method")}my$accessor=sub {my$wantclass=ref($_[0])|| $_[0];return$wantclass->mk_classdata($attribute)->(@_)if @_>1 && $wantclass ne $declaredclass;$data=$_[1]if @_>1;return$data};my$alias="_${attribute}_accessor";*{$declaredclass.'::'.$attribute}=$accessor;*{$declaredclass.'::'.$alias}=$accessor}1;
CLASS_DATA_INHERITABLE

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  use strict;use warnings;package Class::Load;$Class::Load::VERSION='0.22';use base 'Exporter';use Data::OptList 'mkopt';use Module::Implementation 0.04;use Module::Runtime 0.012 qw(check_module_name module_notional_filename require_module use_module);use Try::Tiny;use namespace::clean;{my$loader=Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>['is_class_loaded'],);$loader->()}our@EXPORT_OK=qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;our%EXPORT_TAGS=(all=>\@EXPORT_OK,);our$ERROR;sub load_class {my$class=shift;my$options=shift;my ($res,$e)=try_load_class($class,$options);return$class if$res;_croak($e)}sub load_first_existing_class {my$classes=Data::OptList::mkopt(\@_)or return;for my$class (@{$classes}){check_module_name($class->[0])}for my$class (@{$classes}){my ($name,$options)=@{$class};return$name if is_class_loaded($name,($options ? $options : ()));my ($res,$e)=try_load_class($name,$options);return$name if$res;my$file=module_notional_filename($name);next if$e =~ /^Can't locate \Q$file\E in \@INC/;next if$options && defined$options->{-version}&& $e =~ _version_fail_re($name,$options->{-version});_croak("Couldn't load class ($name) because: $e")}my@list=map {$_->[0].($_->[1]&& defined $_->[1]{-version}? " (version >= $_->[1]{-version})" : q{})}@{$classes};my$err .= q{Can't locate } ._or_list(@list)." in \@INC (\@INC contains: @INC).";_croak($err)}sub _version_fail_re {my$name=shift;my$vers=shift;return qr/\Q$name\E version \Q$vers\E required--this is only version/}sub _nonexistent_fail_re {my$name=shift;my$file=module_notional_filename($name);return qr/Can't locate \Q$file\E in \@INC/}sub _or_list {return $_[0]if @_==1;return join ' or ',@_ if @_==2;my$last=pop;my$list=join ', ',@_;$list .= ', or ' .$last;return$list}sub load_optional_class {my$class=shift;my$options=shift;check_module_name($class);my ($res,$e)=try_load_class($class,$options);return 1 if$res;return 0 if$options && defined$options->{-version}&& $e =~ _version_fail_re($class,$options->{-version});return 0 if$e =~ _nonexistent_fail_re($class);_croak($e)}sub try_load_class {my$class=shift;my$options=shift;check_module_name($class);local $@;undef$ERROR;if (is_class_loaded($class)){return 1 unless$options && defined$options->{-version};return try {$class->VERSION($options->{-version});1}catch {_error($_)}}my$file=module_notional_filename($class);delete$INC{$file};return try {local$SIG{__DIE__}='DEFAULT';if ($options && defined$options->{-version}){use_module($class,$options->{-version})}else {require_module($class)}1}catch {_error($_)}}sub _error {my$e=shift;$e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;chomp$e;$ERROR=$e;return 0 unless wantarray;return 0,$ERROR}sub _croak {require Carp;local$Carp::CarpLevel=$Carp::CarpLevel + 2;Carp::croak(shift)}1;
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  use strict;use warnings;package Class::Load::PP;$Class::Load::PP::VERSION='0.22';use Module::Runtime 'is_module_name';use Package::Stash 0.14;use Scalar::Util 'blessed','reftype';use Try::Tiny;use namespace::clean;sub is_class_loaded {my$class=shift;my$options=shift;my$loaded=_is_class_loaded($class);return$loaded if!$loaded;return$loaded unless$options && $options->{-version};return try {$class->VERSION($options->{-version});1}catch {0}}sub _is_class_loaded {my$class=shift;return 0 unless is_module_name($class);my$stash=Package::Stash->new($class);if ($stash->has_symbol('$VERSION')){my$version=${$stash->get_symbol('$VERSION')};if (defined$version){return 1 if!ref$version;return 1 if ref$version && reftype$version eq 'SCALAR' && defined ${$version};return 1 if blessed$version}}if ($stash->has_symbol('@ISA')){return 1 if @{$stash->get_symbol('@ISA')}}return 1 if$stash->list_all_symbols('CODE');return 0}1;
CLASS_LOAD_PP

$fatpacked{"Config/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY';
  package Config::Any;use strict;use warnings;use Carp;use Module::Pluggable::Object ();our$VERSION='0.24';sub load_files {my ($class,$args)=@_;unless ($args && exists$args->{files }){warn "No files specified!";return}return$class->_load($args)}sub load_stems {my ($class,$args)=@_;unless ($args && exists$args->{stems }){warn "No stems specified!";return}my$stems=delete$args->{stems };my@files;for my$s (@$stems){for my$ext ($class->extensions){push@files,"$s.$ext"}}$args->{files }=\@files;return$class->_load($args)}sub _load {my ($class,$args)=@_;croak "_load requires a arrayref of file paths" unless$args->{files };my$force=defined$args->{force_plugins };if (!$force and!defined$args->{use_ext }){warn "use_ext argument was not explicitly set, as of 0.09, this is true by default";$args->{use_ext }=1}my@plugins=$force ? map {eval "require $_;";$_}@{$args->{force_plugins }}: $class->plugins;my (%extension_lut,$extension_re);my$use_ext_lut=!$force && $args->{use_ext };if ($use_ext_lut){for my$plugin (@plugins){for ($plugin->extensions){$extension_lut{$_ }||=[];push @{$extension_lut{$_ }},$plugin}}$extension_re=join('|',keys%extension_lut)}my$base_class=__PACKAGE__;my%loader_args;for my$plugin (@plugins){$plugin =~ m{^$base_class\::(.+)};$loader_args{$plugin }=$args->{driver_args }->{$1 }|| {}}my@results;for my$filename (@{$args->{files }}){next unless -f $filename;my@try_plugins=@plugins;if ($use_ext_lut){$filename =~ m{\.($extension_re)\z};if (!$1){$filename =~ m{\.([^.]+)\z};croak "There are no loaders available for .${1} files"}@try_plugins=@{$extension_lut{$1 }}}my$supported=$use_ext_lut ? 0 : 1;for my$loader (@try_plugins){next unless$loader->is_supported;$supported=1;my@configs =eval {$loader->load($filename,$loader_args{$loader })};croak "Error parsing $filename: $@" if $@ and $use_ext_lut;next if $@ or!@configs;if ($args->{filter }){$args->{filter }->($_)for@configs}push@results,{$filename=>@configs==1 ? $configs[0 ]: \@configs };last}if (!$supported){croak "Cannot load $filename: required support modules are not available.\nPlease install " .join(" OR ",map {_support_error($_)}@try_plugins)}}if (defined$args->{flatten_to_hash }){my%flattened=map {%$_}@results;return \%flattened}return \@results}sub _support_error {my$module=shift;if ($module->can('requires_all_of')){return join(' and ',map {ref $_ ? join(' ',@$_): $_}$module->requires_all_of)}if ($module->can('requires_any_of')){return 'one of ' .join(' or ',map {ref $_ ? join(' ',@$_): $_}$module->requires_any_of)}}sub finder {my$class=shift;my$finder=Module::Pluggable::Object->new(search_path=>[__PACKAGE__ ],except=>[__PACKAGE__ .'::Base' ],require=>1);return$finder}sub plugins {my$class=shift;return grep {$_->isa('Config::Any::Base')}$class->finder->plugins}sub extensions {my$class=shift;my@ext =map {$_->extensions}$class->plugins;return wantarray ? @ext : \@ext}"Drink more beer";
CONFIG_ANY

$fatpacked{"Config/Any/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_BASE';
  package Config::Any::Base;use strict;use warnings;sub is_supported {my ($class)=shift;if ($class->can('requires_all_of')){eval join('',map {_require_line($_)}$class->requires_all_of);return $@ ? 0 : 1}if ($class->can('requires_any_of')){for ($class->requires_any_of){eval _require_line($_);return 1 unless $@}return 0}return 1}sub _require_line {my ($input)=shift;my ($module,$version)=(ref$input ? @$input : $input);return "require $module;" .($version ? "${module}->VERSION('${version}');" : '')}1;
CONFIG_ANY_BASE

$fatpacked{"Config/Any/General.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_GENERAL';
  package Config::Any::General;use strict;use warnings;use base 'Config::Any::Base';sub extensions {return qw(cnf conf)}sub load {my$class=shift;my$file=shift;my$args=shift || {};$args->{-ConfigFile }=$file;require Config::General;Config::General->VERSION('2.47');$args->{-ForceArray }=1 unless exists$args->{-ForceArray };my$configfile=Config::General->new(%$args);my$config={$configfile->getall };return$config}sub requires_all_of {['Config::General' ]}1;
CONFIG_ANY_GENERAL

$fatpacked{"Config/Any/INI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_INI';
  package Config::Any::INI;use strict;use warnings;use base 'Config::Any::Base';our$MAP_SECTION_SPACE_TO_NESTED_KEY=1;sub extensions {return qw(ini)}sub load {my$class=shift;my$file=shift;require Config::Tiny;my$config=Config::Tiny->read($file);die$Config::Tiny::errstr if not defined$config;my$out=delete$config->{_ }|| {};for my$k (keys %$config){my@keys=split /\s+/,$k;my$ref=$config->{$k };if ($MAP_SECTION_SPACE_TO_NESTED_KEY && @keys > 1){my ($a,$b)=@keys[0,1 ];$out->{$a }->{$b }=$ref}else {$out->{$k }={%{$out->{$k }|| {}},%$ref }}}return$out}sub requires_all_of {'Config::Tiny'}1;
CONFIG_ANY_INI

$fatpacked{"Config/Any/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_JSON';
  package Config::Any::JSON;use strict;use warnings;use base 'Config::Any::Base';sub extensions {return qw(json jsn)}sub load {my$class=shift;my$file=shift;open(my$fh,$file)or die $!;my$content=do {local $/;<$fh>};close$fh;eval {require JSON::DWIW};unless($@){my$decoder=JSON::DWIW->new;my ($data,$error)=$decoder->from_json($content);die$error if$error;return$data}eval {require JSON::XS};unless($@){my$decoder=JSON::XS->new->relaxed;return$decoder->decode($content)}eval {require JSON::Syck};unless($@){return JSON::Syck::Load($content)}eval {require JSON::PP;JSON::PP->VERSION(2)};unless($@){my$decoder=JSON::PP->new->relaxed;return$decoder->decode($content)}require JSON;eval {JSON->VERSION(2)};return $@ ? JSON::jsonToObj($content): JSON::from_json($content)}sub requires_any_of {'JSON::DWIW','JSON::XS','JSON::Syck','JSON::PP','JSON'}1;
CONFIG_ANY_JSON

$fatpacked{"Config/Any/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_PERL';
  package Config::Any::Perl;use strict;use warnings;use base 'Config::Any::Base';sub extensions {return qw(pl perl)}sub load {my$class=shift;my$file=shift;my($exception,$content);{local $@;$content=do$file;$exception=$@}die$exception if$exception;return$content}1;
CONFIG_ANY_PERL

$fatpacked{"Config/Any/XML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_XML';
  package Config::Any::XML;use strict;use warnings;use base 'Config::Any::Base';sub extensions {return qw(xml)}sub load {my$class=shift;my$file=shift;my$args=shift || {};require XML::Simple;my$config=XML::Simple::XMLin($file,ForceArray=>[qw(component model view controller) ],%$args);return$class->_coerce($config)}sub _coerce {my$class=shift;my$config=shift;my$out;for my$k (keys %$config){my$ref=$config->{$k };my$name=ref$ref eq 'HASH' ? delete$ref->{name }: undef;if (defined$name){$out->{$k }->{$name }=$ref}else {$out->{$k }=$ref}}$out}sub requires_all_of {'XML::Simple','XML::NamespaceSupport'}1;
CONFIG_ANY_XML

$fatpacked{"Config/Any/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_ANY_YAML';
  package Config::Any::YAML;use strict;use warnings;use base 'Config::Any::Base';use Carp ();sub extensions {return qw(yml yaml)}sub load {my$class=shift;my$file=shift;eval {require YAML::XS};unless ($@){return YAML::XS::LoadFile($file)}eval {require YAML::Syck;YAML::Syck->VERSION('0.70')};unless ($@){open(my$fh,$file)or die $!;my$content=do {local $/;<$fh>};close$fh;return YAML::Syck::Load($content)}require YAML;return YAML::LoadFile($file)}sub requires_any_of {'YAML::XS',['YAML::Syck','0.70' ],'YAML'}1;
CONFIG_ANY_YAML

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;use warnings;package Data::OptList;{$Data::OptList::VERSION='0.109'}use List::Util ();use Params::Util ();use Sub::Install 0.921 ();my%test_for;BEGIN {%test_for=(CODE=>\&Params::Util::_CODELIKE,HASH=>\&Params::Util::_HASHLIKE,ARRAY=>\&Params::Util::_ARRAYLIKE,SCALAR=>\&Params::Util::_SCALAR0,)}sub __is_a {my ($got,$expected)=@_;return List::Util::first {__is_a($got,$_)}@$expected if ref$expected;return defined (exists($test_for{$expected})? $test_for{$expected}->($got): Params::Util::_INSTANCE($got,$expected))}sub mkopt {my ($opt_list)=shift;my ($moniker,$require_unique,$must_be);my$name_test;if (@_==1 and Params::Util::_HASHLIKE($_[0])){my$arg=$_[0];($moniker,$require_unique,$must_be,$name_test)=@$arg{qw(moniker require_unique must_be name_test) }}else {($moniker,$require_unique,$must_be)=@_}$moniker='unnamed' unless defined$moniker;return []unless$opt_list;$name_test ||=sub {!ref $_[0]};$opt_list=[map {$_=>(ref$opt_list->{$_}? $opt_list->{$_}: ())}keys %$opt_list ]if ref$opt_list eq 'HASH';my@return;my%seen;for (my$i=0;$i < @$opt_list;$i++){my$name=$opt_list->[$i];my$value;if ($require_unique){Carp::croak "multiple definitions provided for $name" if$seen{$name}++}if ($i==$#$opt_list){$value=undef}elsif (not defined$opt_list->[$i+1]){$value=undef;$i++}elsif ($name_test->($opt_list->[$i+1])){$value=undef}else {$value=$opt_list->[++$i]}if ($must_be and defined$value){unless (__is_a($value,$must_be)){my$ref=ref$value;Carp::croak "$ref-ref values are not valid in $moniker opt list"}}push@return,[$name=>$value ]}return \@return}sub mkopt_hash {my ($opt_list,$moniker,$must_be)=@_;return {}unless$opt_list;$opt_list=mkopt($opt_list,$moniker,1,$must_be);my%hash=map {$_->[0]=>$_->[1]}@$opt_list;return \%hash}BEGIN {*import=Sub::Install::exporter {exports=>[qw(mkopt mkopt_hash)],}}1;
DATA_OPTLIST

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.13';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use base qw(Exporter);use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.4';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;$Devel::StackTrace::VERSION='1.34';use 5.006;use strict;use warnings;use Devel::StackTrace::Frame;use File::Spec;use Scalar::Util qw(blessed);use overload '""'=>\&as_string,fallback=>1;sub new {my$class=shift;my%p=@_;$p{no_refs}=delete$p{no_object_refs}if exists$p{no_object_refs};my$self=bless {index=>undef,frames=>[],raw=>[],%p,},$class;$self->_record_caller_data();return$self}sub _record_caller_data {my$self=shift;my$filter=$self->{filter_frames_early}&& $self->_make_frame_filter();my$x=1 + ($self->{skip_frames}|| 0);while (my@c =$self->{no_args}? caller($x++): do {package DB;@DB::args=();caller($x++)}){my@args;@args=$self->{no_args}? (): @DB::args;my$raw={caller=>\@c,args=>\@args,};next if$filter &&!$filter->($raw);if ($self->{no_refs}){$raw->{args}=[map {ref $_ ? $self->_ref_to_string($_): $_}@{$raw->{args}}]}push @{$self->{raw}},$raw}}sub _ref_to_string {my$self=shift;my$ref=shift;return overload::AddrRef($ref)if blessed$ref && $ref->isa('Exception::Class::Base');return overload::AddrRef($ref)unless$self->{respect_overload};local $@;local$SIG{__DIE__};my$str=eval {$ref .''};return $@ ? overload::AddrRef($ref): $str}sub _make_frames {my$self=shift;my$filter=!$self->{filter_frames_early}&& $self->_make_frame_filter();my$raw=delete$self->{raw};for my$r (@{$raw}){next if$filter &&!$filter->($r);$self->_add_frame($r->{caller},$r->{args})}}my$default_filter=sub {1};sub _make_frame_filter {my$self=shift;my (@i_pack_re,%i_class);if ($self->{ignore_package}){local $@;local$SIG{__DIE__};$self->{ignore_package}=[$self->{ignore_package}]unless eval {@{$self->{ignore_package}}};@i_pack_re =map {ref $_ ? $_ : qr/^\Q$_\E$/}@{$self->{ignore_package}}}my$p=__PACKAGE__;push@i_pack_re,qr/^\Q$p\E$/;if ($self->{ignore_class}){$self->{ignore_class}=[$self->{ignore_class}]unless ref$self->{ignore_class};%i_class=map {$_=>1}@{$self->{ignore_class}}}my$user_filter=$self->{frame_filter};return sub {return 0 if grep {$_[0]{caller}[0]=~ /$_/}@i_pack_re;return 0 if grep {$_[0]{caller}[0]->isa($_)}keys%i_class;if ($user_filter){return$user_filter->($_[0])}return 1}}sub _add_frame {my$self=shift;my$c=shift;my$p=shift;push @$c,(undef,undef)if scalar @$c==6;push @{$self->{frames}},Devel::StackTrace::Frame->new($c,$p,$self->{respect_overload},$self->{max_arg_length},$self->{message},$self->{indent})}sub next_frame {my$self=shift;$self->{index}=-1 unless defined$self->{index};my@f=$self->frames();if (defined$f[$self->{index}+ 1 ]){return$f[++$self->{index}]}else {$self->{index}=undef;return undef}}sub prev_frame {my$self=shift;my@f=$self->frames();$self->{index}=scalar@f unless defined$self->{index};if (defined$f[$self->{index}- 1 ]&& $self->{index}>= 1){return$f[--$self->{index}]}else {$self->{index}=undef;return undef}}sub reset_pointer {my$self=shift;$self->{index}=undef}sub frames {my$self=shift;if (@_){die "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n" if grep {!$_->isa('Devel::StackTrace::Frame')}@_;$self->{frames}=\@_}else {$self->_make_frames()if$self->{raw}}return @{$self->{frames}}}sub frame {my$self=shift;my$i=shift;return unless defined$i;return ($self->frames())[$i]}sub frame_count {my$self=shift;return scalar($self->frames())}sub as_string {my$self=shift;my$p=shift;my$st='';my$first=1;for my$f ($self->frames()){$st .= $f->as_string($first,$p)."\n";$first=0}return$st}{package Devel::StackTraceFrame;our@ISA='Devel::StackTrace::Frame'}1;
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;$Devel::StackTrace::Frame::VERSION='1.34';use strict;use warnings;BEGIN {no strict 'refs';for my$f (qw(package filename line subroutine hasargs wantarray evaltext is_require hints bitmask args)){next if$f eq 'args';*{$f}=sub {my$s=shift;return$s->{$f}}}}{my@fields=(qw(package filename line subroutine hasargs wantarray evaltext is_require hints bitmask));sub new {my$proto=shift;my$class=ref$proto || $proto;my$self=bless {},$class;@{$self}{@fields}=@{shift()};$self->{filename}=File::Spec->canonpath($self->{filename});$self->{args}=shift;$self->{respect_overload}=shift;$self->{max_arg_length}=shift;$self->{message}=shift;$self->{indent}=shift;return$self}}sub args {my$self=shift;return @{$self->{args}}}sub as_string {my$self=shift;my$first=shift;my$p=shift;my$sub=$self->subroutine;if ($first){$sub =defined$self->{message}? $self->{message}: 'Trace begun'}else {if (my$eval=$self->evaltext){if ($self->is_require){$sub="require $eval"}else {$eval =~ s/([\\\'])/\\$1/g;$sub="eval '$eval'"}}elsif ($sub eq '(eval)'){$sub='eval {...}'}if (my@a=$self->args){for (@a){$_="undef",next unless defined $_;$_=$self->Devel::StackTrace::_ref_to_string($_)if ref $_;local$SIG{__DIE__};local $@;eval {my$max_arg_length =exists$p->{max_arg_length}? $p->{max_arg_length}: $self->{max_arg_length};if ($max_arg_length && length $_ > $max_arg_length){substr($_,$max_arg_length)='...'}s/'/\\'/g;$_="'$_'" unless /^-?[\d.]+$/;s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg};if (my$e=$@){$_=$e =~ /malformed utf-8/i ? '(bad utf-8)' : '?'}}$sub .= '(' .join(', ',@a).')';$sub .= ' called'}}my$tab=$self->{indent}&&!$first ? "\t" : q{};return "${tab}$sub at " .$self->filename .' line ' .$self->line}1;
DEVEL_STACKTRACE_FRAME

$fatpacked{"Dist/CheckConflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_CHECKCONFLICTS';
  package Dist::CheckConflicts;BEGIN {$Dist::CheckConflicts::AUTHORITY='cpan:DOY'}$Dist::CheckConflicts::VERSION='0.11';use strict;use warnings;use 5.006;use base 'Exporter';our@EXPORT=our@EXPORT_OK=(qw(conflicts check_conflicts calculate_conflicts dist));use Carp;use Module::Runtime 0.009 'module_notional_filename','require_module';my%CONFLICTS;my%HAS_CONFLICTS;my%DISTS;sub import {my$pkg=shift;my$for=caller;my ($conflicts,$alsos,$dist);($conflicts,@_)=_strip_opt('-conflicts'=>@_);($alsos,@_)=_strip_opt('-also'=>@_);($dist,@_)=_strip_opt('-dist'=>@_);my%conflicts=%{$conflicts || {}};for my$also (@{$alsos || []}){eval {require_module($also)}or next;if (!exists$CONFLICTS{$also}){$also .= '::Conflicts';eval {require_module($also)}or next}if (!exists$CONFLICTS{$also}){next}my%also_confs=$also->conflicts;for my$also_conf (keys%also_confs){$conflicts{$also_conf}=$also_confs{$also_conf}if!exists$conflicts{$also_conf}|| $conflicts{$also_conf}lt $also_confs{$also_conf}}}$CONFLICTS{$for}=\%conflicts;$DISTS{$for}=$dist || $for;if (grep {$_ eq ':runtime'}@_){for my$conflict (keys%conflicts){$HAS_CONFLICTS{$conflict}||=[];push @{$HAS_CONFLICTS{$conflict}},$for}for my$conflict (keys%conflicts){if (exists$INC{module_notional_filename($conflict)}){_check_version([$for],$conflict)}}@INC=grep {!(ref($_)eq 'ARRAY' && @$_ > 1 && $_->[1]==\%CONFLICTS)}@INC;unshift@INC,[sub {my ($sub,$file)=@_;(my$mod=$file)=~ s{\.pm$}{};$mod =~ s{/}{::}g;return unless$mod =~ /[\w:]+/;return unless defined$HAS_CONFLICTS{$mod};{local$HAS_CONFLICTS{$mod};require$file}_check_version($HAS_CONFLICTS{$mod},$mod);my$called;return sub {return 0 if$called;$_="1;";$called=1;return 1}},\%CONFLICTS,]}$pkg->export_to_level(1,@_)}sub _strip_opt {my ($opt,@args)=@_;my$val;for my$idx (0 .. $#args - 1){if (defined$args[$idx]&& $args[$idx]eq $opt){$val=(splice@args,$idx,2)[1];last}}return ($val,@args)}sub _check_version {my ($fors,$mod)=@_;for my$for (@$fors){my$conflict_ver=$CONFLICTS{$for}{$mod};my$version=do {no strict 'refs';${${$mod .'::'}{VERSION}}};if ($version le $conflict_ver){warn <<EOF;return}}}sub conflicts {my$package=shift;return %{$CONFLICTS{$package }}}sub dist {my$package=shift;return$DISTS{$package }}sub check_conflicts {my$package=shift;my$dist=$package->dist;my@conflicts=$package->calculate_conflicts;return unless@conflicts;my$err="Conflicts detected for $dist:\n";for my$conflict (@conflicts){$err .= "  $conflict->{package} is version " ."$conflict->{installed}, but must be greater than version " ."$conflict->{required}\n"}die$err}sub calculate_conflicts {my$package=shift;my%conflicts=$package->conflicts;my@ret;CONFLICT: for my$conflict (keys%conflicts){my$success=do {local$SIG{__WARN__}=sub {};eval {require_module($conflict)}};my$error=$@;my$file=module_notional_filename($conflict);next if not $success and $error =~ /Can't locate \Q$file\E in \@INC/;warn "Warning: $conflict did not compile" if not $success;my$installed=$success ? $conflict->VERSION : 'unknown';push@ret,{package=>$conflict,installed=>$installed,required=>$conflicts{$conflict},}if not $success or $installed le $conflicts{$conflict}}return sort {$a->{package}cmp $b->{package}}@ret}1;
  Conflict detected for $DISTS{$for}:
    $mod is version $version, but must be greater than version $conflict_ver
  EOF
DIST_CHECKCONFLICTS

$fatpacked{"Eval/Closure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_CLOSURE';
  package Eval::Closure;BEGIN {$Eval::Closure::AUTHORITY='cpan:DOY'}{$Eval::Closure::VERSION='0.11'}use strict;use warnings;use Exporter 'import';@Eval::Closure::EXPORT=@Eval::Closure::EXPORT_OK='eval_closure';use Carp;use overload ();use Scalar::Util qw(reftype);use Try::Tiny;use constant HAS_LEXICAL_SUBS=>$] >= 5.018;sub eval_closure {my (%args)=@_;$args{alias}=0 if!exists$args{alias};$args{source}=_canonicalize_source($args{source});_validate_env($args{environment}||={});$args{source}=_line_directive(@args{qw(line description)}).$args{source}if defined$args{description}&&!($^P & 0x10);my ($code,$e)=_clean_eval_closure(@args{qw(source environment alias)});if (!$code){if ($args{terse_error}){die "$e\n"}else {croak("Failed to compile source: $e\n\nsource:\n$args{source}")}}return$code}sub _canonicalize_source {my ($source)=@_;if (defined($source)){if (ref($source)){if (reftype($source)eq 'ARRAY' || overload::Method($source,'@{}')){return join "\n",@$source}elsif (overload::Method($source,'""')){return "$source"}else {croak("The 'source' parameter to eval_closure must be a " ."string or array reference")}}else {return$source}}else {croak("The 'source' parameter to eval_closure is required")}}sub _validate_env {my ($env)=@_;croak("The 'environment' parameter must be a hashref")unless reftype($env)eq 'HASH';for my$var (keys %$env){if (HAS_LEXICAL_SUBS){croak("Environment key '$var' should start with \@, \%, \$, or \&")unless$var =~ /^([\@\%\$\&])/}else {croak("Environment key '$var' should start with \@, \%, or \$")unless$var =~ /^([\@\%\$])/}croak("Environment values must be references, not $env->{$var}")unless ref($env->{$var})}}sub _line_directive {my ($line,$description)=@_;$line=1 unless defined($line);return qq{#line $line "$description"\n}}sub _clean_eval_closure {my ($source,$captures,$alias)=@_;my@capture_keys=sort keys %$captures;if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}){_dump_source(_make_compiler_source($source,$alias,@capture_keys))}my ($compiler,$e)=_make_compiler($source,$alias,@capture_keys);my$code;if (defined$compiler){$code=$compiler->(@$captures{@capture_keys})}if (defined($code)&& (!ref($code)|| ref($code)ne 'CODE')){$e="The 'source' parameter must return a subroutine reference, " ."not $code";undef$code}if ($alias){require Devel::LexAlias;Devel::LexAlias::lexalias($code,$_,$captures->{$_})for grep!/^\&/,keys %$captures}return ($code,$e)}sub _make_compiler {my$source=_make_compiler_source(@_);return @{_clean_eval($source)}}sub _clean_eval {local $@;local$SIG{__DIE__};my$compiler=eval $_[0];my$e=$@;[$compiler,$e ]}$Eval::Closure::SANDBOX_ID=0;sub _make_compiler_source {my ($source,$alias,@capture_keys)=@_;$Eval::Closure::SANDBOX_ID++;my$i=0;return join "\n",("package Eval::Closure::Sandbox_$Eval::Closure::SANDBOX_ID;",'sub {',(map {_make_lexical_assignment($_,$i++,$alias)}@capture_keys),$source,'}',)}sub _make_lexical_assignment {my ($key,$index,$alias)=@_;my$sigil=substr($key,0,1);my$name=substr($key,1);if (HAS_LEXICAL_SUBS && $sigil eq '&'){my$tmpname='$__' .$name .'__' .$index;return 'use feature "lexical_subs"; ' .'no warnings "experimental::lexical_subs"; ' .'my ' .$tmpname .' = $_[' .$index .']; ' .'my sub ' .$name .' { goto ' .$tmpname .' }'}if ($alias){return 'my ' .$key .';'}else {return 'my ' .$key .' = ' .$sigil .'{$_[' .$index .']};'}}sub _dump_source {my ($source)=@_;my$output;if (try {require Perl::Tidy}){Perl::Tidy::perltidy(source=>\$source,destination=>\$output,argv=>[],)}else {$output=$source}warn "$output\n"}1;
EVAL_CLOSURE

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;$Exception::Class::VERSION='1.38';use 5.008001;use strict;use Exception::Class::Base;use Scalar::Util qw(blessed);our$BASE_EXC_CLASS;BEGIN {$BASE_EXC_CLASS ||='Exception::Class::Base'}our%CLASSES;sub import {my$class=shift;local$Exception::Class::Caller=caller();my%c;my%needs_parent;while (my$subclass=shift){my$def=ref $_[0]? shift : {};$def->{isa}=$def->{isa}? (ref$def->{isa}? $def->{isa}: [$def->{isa}]): [];$c{$subclass}=$def}MAKE_CLASSES: foreach my$subclass (sort {length$a <=> length$b}keys%c){my$def=$c{$subclass};next if$CLASSES{$subclass};{no strict 'refs';for my$parent (@{$def->{isa}}){unless (keys %{"$parent\::"}){$needs_parent{$subclass}={parents=>$def->{isa},def=>$def };next MAKE_CLASSES}}}$class->_make_subclass(subclass=>$subclass,def=>$def || {},)}for my$subclass (keys%needs_parent){my%seen;$class->_make_parents(\%needs_parent,$subclass,\%seen)}}sub _make_parents {my$class=shift;my$needs=shift;my$subclass=shift;my$seen=shift;my$child=shift;no strict 'refs';die "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n" unless exists$needs->{$subclass}|| $CLASSES{$subclass}|| keys %{"$subclass\::"};for my$c (@{$needs->{$subclass}{parents}}){next if$CLASSES{$c}|| keys %{"$c\::"};die "There appears to be some circularity involving $subclass\n" if$seen->{$subclass};$seen->{$subclass}=1;$class->_make_parents($needs,$c,$seen,$subclass)}return if$CLASSES{$subclass}|| keys %{"$subclass\::"};$class->_make_subclass(subclass=>$subclass,def=>$needs->{$subclass}{def})}sub _make_subclass {my$class=shift;my%p=@_;my$subclass=$p{subclass};my$def=$p{def};my$isa;if ($def->{isa}){$isa=ref$def->{isa}? join ' ',@{$def->{isa}}: $def->{isa}}$isa ||=$BASE_EXC_CLASS;my$version_name='VERSION';my$code=<<"EOPERL";if ($def->{description}){(my$desc=$def->{description})=~ s/([\\\'])/\\$1/g;$code .= <<"EOPERL"}my@fields;if (my$fields=$def->{fields}){@fields=UNIVERSAL::isa($fields,'ARRAY')? @$fields : $fields;$code .= "sub Fields { return (\$_[0]->SUPER::Fields, " .join(", ",map {"'$_'"}@fields).") }\n\n";for my$field (@fields){$code .= sprintf("sub %s { \$_[0]->{%s} }\n",$field,$field)}}if (my$alias=$def->{alias}){die "Cannot make alias without caller" unless defined$Exception::Class::Caller;no strict 'refs';*{"$Exception::Class::Caller\::$alias"}=sub {$subclass->throw(@_)}}if (my$defaults=$def->{defaults}){$code .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";no strict 'refs';*{"$subclass\::_DEFAULTS"}={%$defaults}}eval$code;die $@ if $@;$CLASSES{$subclass}=1}sub caught {my$e=$@;return$e unless $_[1];return unless blessed($e)&& $e->isa($_[1]);return$e}sub Classes {sort keys%Exception::Class::CLASSES}1;
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  sub description
  {
      return '$desc';
  }
  EOPERL
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;$Exception::Class::Base::VERSION='1.38';use strict;use warnings;use Class::Data::Inheritable 0.02;use Devel::StackTrace 1.20;use Scalar::Util qw(blessed);use base qw(Class::Data::Inheritable);BEGIN {__PACKAGE__->mk_classdata('Trace');__PACKAGE__->mk_classdata('NoRefs');__PACKAGE__->NoRefs(1);__PACKAGE__->mk_classdata('NoContextInfo');__PACKAGE__->NoContextInfo(0);__PACKAGE__->mk_classdata('RespectOverload');__PACKAGE__->RespectOverload(0);__PACKAGE__->mk_classdata('MaxArgLength');__PACKAGE__->MaxArgLength(0);sub Fields {()}}use overload bool=>sub {1},'""'=>'as_string',fallback=>1;BEGIN {my@fields=qw(message pid uid euid gid egid time trace);for my$f (@fields){my$sub=sub {my$s=shift;return$s->{$f}};no strict 'refs';*{$f}=$sub}*error=\&message;my%trace_fields=(package=>'package',file=>'filename',line=>'line',);while (my ($f,$m)=each%trace_fields){my$sub=sub {my$s=shift;return$s->{$f}if exists$s->{$f};my$frame=$s->trace->frame(0);return$s->{$f}=$frame ? $frame->$m(): undef};no strict 'refs';*{$f}=$sub}}sub Classes {Exception::Class::Classes()}sub throw {my$proto=shift;$proto->rethrow if ref$proto;die$proto->new(@_)}sub rethrow {my$self=shift;die$self}sub new {my$proto=shift;my$class=ref$proto || $proto;my$self=bless {},$class;$self->_initialize(@_);return$self}sub _initialize {my$self=shift;my%p=@_==1 ? (error=>$_[0]): @_;$self->{message}=$p{message}|| $p{error}|| '';$self->{show_trace}=$p{show_trace}if exists$p{show_trace};if ($self->NoContextInfo()){$self->{show_trace}=0;$self->{package}=$self->{file}=$self->{line}=undef}else {$self->{time}=CORE::time();$self->{pid}=$$;$self->{uid}=$<;$self->{euid}=$>;$self->{gid}=$(;$self->{egid}=$);my@ignore_class=(__PACKAGE__);my@ignore_package='Exception::Class';if (my$i=delete$p{ignore_class}){push@ignore_class,(ref($i)eq 'ARRAY' ? @$i : $i)}if (my$i=delete$p{ignore_package}){push@ignore_package,(ref($i)eq 'ARRAY' ? @$i : $i)}$self->{trace}=Devel::StackTrace->new(ignore_class=>\@ignore_class,ignore_package=>\@ignore_package,no_refs=>$self->NoRefs,respect_overload=>$self->RespectOverload,max_arg_length=>$self->MaxArgLength,)}my%fields=map {$_=>1}$self->Fields;while (my ($key,$value)=each%p){next if$key =~ /^(?:error|message|show_trace)$/;if ($fields{$key}){$self->{$key}=$value}else {Exception::Class::Base->throw(error=>"unknown field $key passed to constructor for class " .ref$self)}}}sub context_hash {my$self=shift;return {time=>$self->{time},pid=>$self->{pid},uid=>$self->{uid},euid=>$self->{euid},gid=>$self->{gid},egid=>$self->{egid},}}sub field_hash {my$self=shift;my$hash={};for my$field ($self->Fields){$hash->{$field}=$self->$field}return$hash}sub description {return 'Generic exception'}sub show_trace {my$self=shift;return 0 unless$self->{trace};if (@_){$self->{show_trace}=shift}return exists$self->{show_trace}? $self->{show_trace}: $self->Trace}sub as_string {my$self=shift;my$str=$self->full_message;unless (defined$str && length$str){my$desc=$self->description;$str=defined$desc && length$desc ? "[$desc]" : "[Generic exception]"}$str .= "\n\n" .$self->trace->as_string if$self->show_trace;return$str}sub full_message {$_[0]->{message}}eval <<'EOF' if $]==5.006;sub caught {my$class=shift;my$e=$@;return unless defined$e && blessed($e)&& $e->isa($class);return$e}1;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
EXCEPTION_CLASS_BASE

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args}: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||=Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Module::Load;our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');load($package);$package->import()}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||='lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Carp qw/croak/;use Config;use Text::ParseWords 3.24 qw/shellwords/;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return shellwords($string)}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use ExtUtils::Helpers::Unix qw/split_like_shell/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);my$newdirs;if ($arg =~ m#^~/#){$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs)}else {my@backup=File::Spec::Unix->splitdir(File::Spec::Unix->updir);$newdirs=File::Spec::Unix->catdir(@hdirs,@backup,@dirs)}$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Config;use Carp qw/carp croak/;sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){_pl2bat(in=>$script,update=>1)}return}sub _pl2bat {my%opts=@_;$opts{ntargs}='-x -S %0 %*';$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9';$opts{stripsuffix}=qr/\.plx?/ unless exists$opts{stripsuffix};if (not exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//i;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}eq '-'}my$head=<<"EOT";$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail=<<'EOT';$tail =~ s/^\s+//gm;my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start='#!perl' unless$start =~ /^#!.*perl/;open my$in,'<',$opts{in}or croak "Can't open $opts{in}: $!";my@file=<$in>;close$in;for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= '#line '.(1+$headlines)."\n"}else {$line .= '#line '.($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=''}}open my$out,'>',$opts{out}or croak "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? ' -w' : ''),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close$out;return$opts{out}}sub split_like_shell {local ($_)=@_;my@argv;return@argv unless defined && length;my$arg='';my ($i,$quote_mode)=(0,0);while ($i < length){my$ch=substr $_,$i,1;my$next_ch=substr $_,$i+1,1;if ($ch eq '\\' && $next_ch eq '"'){$arg .= '"';$i++}elsif ($ch eq '\\' && $next_ch eq '\\'){$arg .= '\\';$i++}elsif ($ch eq '"' && $next_ch eq '"' && $quote_mode){$quote_mode=!$quote_mode;$arg .= '"';$i++}elsif ($ch eq '"' && $next_ch eq '"' &&!$quote_mode && ($i + 2==length()|| substr($_,$i + 2,1)eq ' ')){push@argv,$arg;$arg='';$i += 2}elsif ($ch eq '"'){$quote_mode=!$quote_mode}elsif ($ch =~ /\s/ &&!$quote_mode){push@argv,$arg if$arg;$arg='';++$i while substr($_,$i + 1,1)=~ /\s/}else {$arg .= $ch}$i++}push@argv,$arg if defined$arg && length$arg;return@argv}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
  	\@rem = '--*-Perl-*--
  	\@echo off
  	if "%OS%" == "Windows_NT" goto WinNT
  	perl $opts{otherargs}
  	\@set ErrorLevel=%ErrorLevel%
  	goto endofperl
  	:WinNT
  	perl $opts{ntargs}
  	\@set ErrorLevel=%ErrorLevel%
  	if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
  	if %errorlevel% == 9009 echo You do not have Perl in your PATH.
  	goto endofperl
  	\@rem ';
  EOT
  	__END__
  	:endofperl
  	@"%COMSPEC%" /c exit /b %ErrorLevel%
  EOT
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;{$ExtUtils::InstallPaths::VERSION='0.010'}use 5.008001;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||=do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=qw/bin script man1dir man3dir html1dir html3dir/;my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||=$self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;use 5.00503;use strict;use Carp ();use Config ();use File::Spec ();use File::Which ();use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};BEGIN {$VERSION='1.00';require Exporter;@ISA=qw{Exporter};@EXPORT=qw{home};@EXPORT_OK=qw{home my_home my_desktop my_documents my_music my_pictures my_videos my_data my_dist_config my_dist_data users_home users_desktop users_documents users_music users_pictures users_videos users_data}}sub _CLASS ($) {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $_[0]: undef}sub _DRIVER ($$) {(defined _CLASS($_[0])and eval "require $_[0];" and!$@ and $_[0]->isa($_[1])and $_[0]ne $_[1])? $_[0]: undef}if ($IMPLEMENTED_BY){}elsif ($^O eq 'MSWin32'){$IMPLEMENTED_BY='File::HomeDir::Windows'}elsif ($^O eq 'darwin'){if (eval {require Mac::SystemDirectory;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Cocoa'}elsif (eval {require Mac::Files;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Carbon'}else {$IMPLEMENTED_BY='File::HomeDir::Darwin'}}elsif ($^O eq 'MacOS'){$IMPLEMENTED_BY='File::HomeDir::MacOS9'}elsif (File::Which::which('xdg-user-dir')){$IMPLEMENTED_BY='File::HomeDir::FreeDesktop'}else {$IMPLEMENTED_BY='File::HomeDir::Unix'}unless (_DRIVER($IMPLEMENTED_BY,'File::HomeDir::Driver')){Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY")}sub my_home {$IMPLEMENTED_BY->my_home}sub my_desktop {$IMPLEMENTED_BY->can('my_desktop')? $IMPLEMENTED_BY->my_desktop : Carp::croak("The my_desktop method is not implemented on this platform")}sub my_documents {$IMPLEMENTED_BY->can('my_documents')? $IMPLEMENTED_BY->my_documents : Carp::croak("The my_documents method is not implemented on this platform")}sub my_music {$IMPLEMENTED_BY->can('my_music')? $IMPLEMENTED_BY->my_music : Carp::croak("The my_music method is not implemented on this platform")}sub my_pictures {$IMPLEMENTED_BY->can('my_pictures')? $IMPLEMENTED_BY->my_pictures : Carp::croak("The my_pictures method is not implemented on this platform")}sub my_videos {$IMPLEMENTED_BY->can('my_videos')? $IMPLEMENTED_BY->my_videos : Carp::croak("The my_videos method is not implemented on this platform")}sub my_data {$IMPLEMENTED_BY->can('my_data')? $IMPLEMENTED_BY->my_data : Carp::croak("The my_data method is not implemented on this platform")}sub my_dist_data {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_data method requires an argument");my$data=my_data();return undef unless defined$data;my$var=$data eq home()? File::Spec->catdir($data,'.perl','dist',$dist): File::Spec->catdir($data,'Perl','dist',$dist);return$var if -d $var;return undef unless$params->{create};require File::Path;File::Path::mkpath($var);return$var}sub my_dist_config {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_config method requires an argument");my$config=$IMPLEMENTED_BY->can('my_config')? $IMPLEMENTED_BY->my_config : $IMPLEMENTED_BY->my_documents;return undef unless defined$config;my$etc=$config eq home()? File::Spec->catdir($config,'.perl',$dist): File::Spec->catdir($config,'Perl',$dist);return$etc if -d $etc;return undef unless$params->{create};require File::Path;File::Path::mkpath($etc);return$etc}sub users_home {$IMPLEMENTED_BY->can('users_home')? $IMPLEMENTED_BY->users_home($_[-1]): Carp::croak("The users_home method is not implemented on this platform")}sub users_desktop {$IMPLEMENTED_BY->can('users_desktop')? $IMPLEMENTED_BY->users_desktop($_[-1]): Carp::croak("The users_desktop method is not implemented on this platform")}sub users_documents {$IMPLEMENTED_BY->can('users_documents')? $IMPLEMENTED_BY->users_documents($_[-1]): Carp::croak("The users_documents method is not implemented on this platform")}sub users_music {$IMPLEMENTED_BY->can('users_music')? $IMPLEMENTED_BY->users_music($_[-1]): Carp::croak("The users_music method is not implemented on this platform")}sub users_pictures {$IMPLEMENTED_BY->can('users_pictures')? $IMPLEMENTED_BY->users_pictures($_[-1]): Carp::croak("The users_pictures method is not implemented on this platform")}sub users_videos {$IMPLEMENTED_BY->can('users_videos')? $IMPLEMENTED_BY->users_videos($_[-1]): Carp::croak("The users_videos method is not implemented on this platform")}sub users_data {$IMPLEMENTED_BY->can('users_data')? $IMPLEMENTED_BY->users_data($_[-1]): Carp::croak("The users_data method is not implemented on this platform")}sub home (;$) {if ($_[0]and $_[0]eq 'File::HomeDir'){shift()}return my_home()unless @_;my$name=shift;if (!defined$name){Carp::croak("Can't use undef as a username")}if (!length$name){Carp::croak("Can't use empty-string (\"\") as a username")}if ($name eq '.'){return my_home()}$IMPLEMENTED_BY->users_home($name)}CLASS: {package File::HomeDir::TIE;my$SINGLETON=bless {};sub TIEHASH {$SINGLETON}sub FETCH {unless (defined $_[1]){Carp::croak("Can't use undef as a username")}unless (length $_[1]){return File::HomeDir::my_home()}Carp::carp("The tied %~ hash has been deprecated");return File::HomeDir::home($_[1])}sub STORE {_bad('STORE')}sub EXISTS {_bad('EXISTS')}sub DELETE {_bad('DELETE')}sub CLEAR {_bad('CLEAR')}sub FIRSTKEY {_bad('FIRSTKEY')}sub NEXTKEY {_bad('NEXTKEY')}sub _bad ($) {Carp::croak("You can't $_[0] with the %~ hash")}}tie %~,'File::HomeDir::TIE';1;
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Unix'}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}my$home=(getpwuid($<))[7];return$home if$home && -d $home;return undef}sub _my_home {my($class,$path)=@_;my$home=$class->my_home;return undef unless defined$home;my$folder="$home/$path";unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub my_desktop {my$class=shift;$class->_my_home('Desktop')}sub my_documents {my$class=shift;$class->_my_home('Documents')}sub my_data {my$class=shift;$class->_my_home('Library/Application Support')}sub my_music {my$class=shift;$class->_my_home('Music')}sub my_pictures {my$class=shift;$class->_my_home('Pictures')}sub my_videos {my$class=shift;$class->_my_home('Movies')}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::Files;$class->_find_folder(Mac::Files::kCurrentUserFolderType(),)}sub my_desktop {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDesktopFolderType(),)}sub my_documents {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDocumentsFolderType(),)}sub my_data {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kApplicationSupportFolderType(),)}sub my_music {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMusicDocumentsFolderType(),)}sub my_pictures {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kPictureDocumentsFolderType(),)}sub my_videos {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMovieDocumentsFolderType(),)}sub _find_folder {my$class=shift;my$name=shift;require Mac::Files;my$folder=Mac::Files::FindFolder(Mac::Files::kUserDomain(),$name,);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::SystemDirectory'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::SystemDirectory;return Mac::SystemDirectory::HomeDirectory()}sub my_desktop {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())}|| $class->SUPER::my_desktop}sub my_documents {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())}|| $class->SUPER::my_documents}sub my_data {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())}|| $class->SUPER::my_data}sub my_music {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())}|| $class->SUPER::my_music}sub my_pictures {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())}|| $class->SUPER::my_pictures}sub my_videos {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())}|| $class->SUPER::my_videos}sub _find_folder {my$class=shift;my$name=shift;require Mac::SystemDirectory;my$folder=Mac::SystemDirectory::FindDirectory($name);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}1;
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;use 5.00503;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='1.00'}sub my_home {Carp::croak("$_[0] does not implement compulsory method $_[1]")}1;
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Which ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Unix'}my$xdgprog=File::Which::which('xdg-user-dir');sub _my {my$thingy=qx($xdgprog $_[1]);chomp$thingy;return$thingy}sub my_desktop {shift->_my('DESKTOP')}sub my_documents {shift->_my('DOCUMENTS')}sub my_music {shift->_my('MUSIC')}sub my_pictures {shift->_my('PICTURES')}sub my_videos {shift->_my('VIDEOS')}sub my_data {$ENV{XDG_DATA_HOME}or File::Spec->catdir(shift->my_home,qw{.local share})}sub my_config {$ENV{XDG_CONFIG_HOME}or File::Spec->catdir(shift->my_home,qw{.config})}sub my_download {shift->_my('DOWNLOAD')}sub my_publicshare {shift->_my('PUBLICSHARE')}sub my_templates {shift->_my('TEMPLATES')}sub my_cache {$ENV{XDG_CACHE_HOME}|| File::Spec->catdir(shift->my_home,qw{.cache})}sub users_desktop {Carp::croak('The users_desktop method is not available on an XDG based system.')}sub users_documents {Carp::croak('The users_documents method is not available on an XDG based system.')}sub users_music {Carp::croak('The users_music method is not available on an XDG based system.')}sub users_pictures {Carp::croak('The users_pictures method is not available on an XDG based system.')}sub users_videos {Carp::croak('The users_videos method is not available on an XDG based system.')}sub users_data {Carp::croak('The users_data method is not available on an XDG based system.')}1;
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Driver'}SCOPE: {local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (defined$ENV{HOME}){return$ENV{HOME}}SCOPE: {local $@;eval {my$home=$class->my_desktop;return$home if$home and -d $home}}SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwuid($<))[7];return$home if$home and -d $home}Carp::croak("Could not locate current user's home directory")}sub my_desktop {my$class=shift;local$SIG{'__DIE__'}='';require Mac::Files;my$home=Mac::Files::FindFolder(Mac::Files::kOnSystemDisk(),Mac::Files::kDesktopFolderType(),);return$home if$home and -d $home;Carp::croak("Could not locate current user's desktop")}sub users_home {my ($class,$name)=@_;SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwnam($name))[7];return$home if defined$home and -d $home}Carp::croak("Failed to find home directory for user '$name'")}1;
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Temp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA %DIR $ENABLED};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Driver';%DIR=();$ENABLED=0}sub import {my$class=shift;die "Attempted to initialise File::HomeDir::Test trice" if%DIR;my$BASE=File::Temp::tempdir(CLEANUP=>1);%DIR=map {$_=>File::Spec->catdir($BASE,$_)}qw{my_home my_desktop my_documents my_data my_music my_pictures my_videos};$ENV{HOME}=$DIR{my_home};$File::HomeDir::IMPLEMENTED_BY=$File::HomeDir::IMPLEMENTED_BY='File::HomeDir::Test';$ENABLED=1}sub my_home {mkdir($DIR{my_home},0755)unless -d $DIR{my_home};return$DIR{my_home}}sub my_desktop {mkdir($DIR{my_desktop},0755)unless -d $DIR{my_desktop};return$DIR{my_desktop}}sub my_documents {mkdir($DIR{my_documents},0755)unless -f $DIR{my_documents};return$DIR{my_documents}}sub my_data {mkdir($DIR{my_data},0755)unless -d $DIR{my_data};return$DIR{my_data}}sub my_music {mkdir($DIR{my_music},0755)unless -d $DIR{my_music};return$DIR{my_music}}sub my_pictures {mkdir($DIR{my_pictures},0755)unless -d $DIR{my_pictures};return$DIR{my_pictures}}sub my_videos {mkdir($DIR{my_videos},0755)unless -d $DIR{my_videos};return$DIR{my_videos}}sub users_home {return undef}1;
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Driver'}sub my_home {my$class=shift;my$home=$class->_my_home(@_);if (defined$home and!-d $home){$home=undef}return$home}sub _my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}if (exists$ENV{LOGDIR}and $ENV{LOGDIR}){return$ENV{LOGDIR}}SCOPE: {my$home=(getpwuid($<))[7];return$home if$home and -d $home}return undef}sub my_desktop {shift->my_home}sub my_documents {shift->my_home}sub my_data {shift->my_home}sub my_music {shift->my_home}sub my_pictures {shift->my_home}sub my_videos {shift->my_home}sub users_home {my ($class,$name)=@_;if ($name eq getpwuid($<)){return$class->my_home}SCOPE: {my$home=(getpwnam($name))[7];return$home if$home and -d $home}return undef}sub users_desktop {shift->users_home(@_)}sub users_documents {shift->users_home(@_)}sub users_data {shift->users_home(@_)}sub users_music {shift->users_home(@_)}sub users_pictures {shift->users_home(@_)}sub users_videos {shift->users_home(@_)}1;
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;use 5.00503;use strict;use Carp ();use File::Spec ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='1.00';@ISA='File::HomeDir::Driver'}sub CREATE () {1}sub my_home {my$class=shift;if (exists$ENV{HOME}and $ENV{HOME}){return$ENV{HOME}}if (exists$ENV{USERPROFILE}and $ENV{USERPROFILE}){return$ENV{USERPROFILE}}if (exists$ENV{HOMEDRIVE}and exists$ENV{HOMEPATH}and $ENV{HOMEDRIVE}and $ENV{HOMEPATH}){return File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},'',)}return undef}sub my_desktop {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_DESKTOP(),CREATE);return$dir if$dir and $class->_d($dir)}for my$e ('USERPROFILE','WINDIR'){next unless$ENV{$e};my$desktop=File::Spec->catdir($ENV{$e},'Desktop');return$desktop if$desktop and $class->_d($desktop)}for my$fixed ("C:\\windows\\desktop","C:\\win95\\desktop","C:/win95/desktop","C:/windows/desktop",){return$fixed if$class->_d($fixed)}return undef}sub my_documents {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_PERSONAL(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_data {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_music {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_pictures {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_videos {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub _d {my$self=shift;my$path=shift;if ($path =~ /\\\\/){return 1}return -d $path}1;
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use 5.004;use strict;use Exporter ();use File::Spec ();use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};BEGIN {$VERSION='1.09';@ISA='Exporter';@EXPORT='which';@EXPORT_OK='where'}use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_DOS=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');my@PATHEXT=('');if (IS_DOS){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless$exec;my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}my@path=File::Spec->path;if (IS_DOS or IS_VMS or IS_MAC){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || (IS_DOS and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||=tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||=do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||=tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"MRO/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MRO_COMPAT';
  package MRO::Compat;use strict;use warnings;require 5.006_000;our$VERSION='0.12';BEGIN {if($] < 5.009_005){$mro::VERSION =$VERSION;$INC{'mro.pm'}=__FILE__;*mro::import=\&__import;*mro::get_linear_isa=\&__get_linear_isa;*mro::set_mro=\&__set_mro;*mro::get_mro=\&__get_mro;*mro::get_isarev=\&__get_isarev;*mro::is_universal=\&__is_universal;*mro::method_changed_in=\&__method_changed_in;*mro::invalidate_all_method_caches =\&__invalidate_all_method_caches;require Class::C3;if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03){*mro::get_pkg_gen=\&__get_pkg_gen_c3xs}else {*mro::get_pkg_gen=\&__get_pkg_gen_pp}}else {require mro;no warnings 'redefine';*Class::C3::initialize=sub {1};*Class::C3::reinitialize=sub {1};*Class::C3::uninitialize=sub {1}}}sub __get_linear_isa_dfs {no strict 'refs';my$classname=shift;my@lin=($classname);my%stored;for my$parent (@{"$classname\::ISA"}){my$plin=__get_linear_isa_dfs($parent);for (@$plin){next if exists$stored{$_};push(@lin,$_);$stored{$_}=1}}return \@lin}sub __get_linear_isa {my ($classname,$type)=@_;die "mro::get_mro requires a classname" if!defined$classname;$type ||=__get_mro($classname);if($type eq 'dfs'){return __get_linear_isa_dfs($classname)}elsif($type eq 'c3'){return [Class::C3::calculateMRO($classname)]}die "type argument must be 'dfs' or 'c3'"}sub __import {if($_[1]){goto&Class::C3::import if $_[1]eq 'c3';__set_mro(scalar(caller),$_[1])}}sub __set_mro {my ($classname,$type)=@_;if(!defined$classname ||!$type){die q{Usage: mro::set_mro($classname, $type)}}if($type eq 'c3'){eval "package $classname; use Class::C3";die $@ if $@}elsif($type eq 'dfs'){if(defined$Class::C3::MRO{$classname}){Class::C3::_remove_method_dispatch_table($classname)}delete$Class::C3::MRO{$classname}}else {die qq{Invalid mro type "$type"}}return}sub __get_mro {my$classname=shift;die "mro::get_mro requires a classname" if!defined$classname;return 'c3' if exists$Class::C3::MRO{$classname};return 'dfs'}sub __get_all_pkgs_with_isas {no strict 'refs';no warnings 'recursion';my@retval;my$search=shift;my$pfx;my$isa;if(defined$search){$isa=\@{"$search\::ISA"};$pfx="$search\::"}else {$search='main';$isa=\@main::ISA;$pfx=''}push(@retval,$search)if scalar(@$isa);for my$cand (keys %{"$search\::"}){if($cand =~ s/::$//){next if$cand eq $search;push(@retval,@{__get_all_pkgs_with_isas($pfx .$cand)})}}return \@retval}sub __get_isarev_recurse {no strict 'refs';my ($class,$all_isas,$level)=@_;die "Recursive inheritance detected" if$level > 100;my%retval;for my$cand (@$all_isas){my$found_me;for (@{"$cand\::ISA"}){if($_ eq $class){$found_me=1;last}}if($found_me){$retval{$cand}=1;map {$retval{$_}=1}@{__get_isarev_recurse($cand,$all_isas,$level+1)}}}return [keys%retval]}sub __get_isarev {my$classname=shift;die "mro::get_isarev requires a classname" if!defined$classname;__get_isarev_recurse($classname,__get_all_pkgs_with_isas(),0)}sub __is_universal {my$classname=shift;die "mro::is_universal requires a classname" if!defined$classname;my$lin=__get_linear_isa('UNIVERSAL');for (@$lin){return 1 if$classname eq $_}return 0}sub __invalidate_all_method_caches {@f845a9c1ac41be33::ISA=@f845a9c1ac41be33::ISA;return}sub __method_changed_in {my$classname=shift;die "mro::method_changed_in requires a classname" if!defined$classname;__invalidate_all_method_caches()}{my$__pkg_gen=2;sub __get_pkg_gen_pp {my$classname=shift;die "mro::get_pkg_gen requires a classname" if!defined$classname;return$__pkg_gen++}}sub __get_pkg_gen_c3xs {my$classname=shift;die "mro::get_pkg_gen requires a classname" if!defined$classname;return Class::C3::XS::_plsubgen()}1;
MRO_COMPAT

$fatpacked{"Mixin/Linewise.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MIXIN_LINEWISE';
  use strict;use warnings;package Mixin::Linewise;$Mixin::Linewise::VERSION='0.106';use 5.006;use Carp ();Carp::confess "not meant to be loaded";1;
MIXIN_LINEWISE

$fatpacked{"Mixin/Linewise/Readers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MIXIN_LINEWISE_READERS';
  use strict;use warnings;package Mixin::Linewise::Readers;$Mixin::Linewise::Readers::VERSION='0.106';use 5.008001;use Carp ();use IO::File;use PerlIO::utf8_strict;use Sub::Exporter -setup=>{exports=>{map {;"read_$_"=>\"_mk_read_$_"}qw(file string) },groups=>{default=>[qw(read_file read_string) ],readers=>[qw(read_file read_string) ],},};sub _mk_read_file {my ($self,$name,$arg)=@_;my$method=defined$arg->{method}? $arg->{method}: 'read_handle';my$dflt_enc=defined$arg->{binmode}? $arg->{binmode}: 'utf8_strict';sub {my ($invocant,$options,$filename);if (ref $_[1]eq 'HASH'){($invocant,$options,$filename)=splice @_,0,3}else {($invocant,$filename)=splice @_,0,2}$options->{binmode}=$dflt_enc unless defined$options->{binmode};$options->{binmode}=~ s/^://;Carp::croak "no filename specified" unless$filename;Carp::croak "file '$filename' does not exist" unless -e $filename;Carp::croak "'$filename' is not a plain file" unless -f _;my$handle=IO::File->new($filename,"<:$options->{binmode}")or Carp::croak "couldn't read file '$filename': $!";$invocant->$method($handle,@_)}}sub _mk_read_string {my ($self,$name,$arg)=@_;my$method=defined$arg->{method}? $arg->{method}: 'read_handle';my$dflt_enc=defined$arg->{binmode}? $arg->{binmode}: 'utf8_strict';sub {my ($invocant,$string)=splice @_,0,2;my$binmode=$dflt_enc;$binmode =~ s/^://;Carp::croak "no string provided" unless defined$string;open my$handle,"<:$binmode",\$string or die "error opening string for reading: $!";$invocant->$method($handle,@_)}}1;
MIXIN_LINEWISE_READERS

$fatpacked{"Mixin/Linewise/Writers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MIXIN_LINEWISE_WRITERS';
  use strict;use warnings;package Mixin::Linewise::Writers;$Mixin::Linewise::Writers::VERSION='0.106';use 5.008001;use Carp ();use IO::File;use Sub::Exporter -setup=>{exports=>{map {;"write_$_"=>\"_mk_write_$_"}qw(file string) },groups=>{default=>[qw(write_file write_string) ],writers=>[qw(write_file write_string) ],},};sub _mk_write_file {my ($self,$name,$arg)=@_;my$method=defined$arg->{method}? $arg->{method}: 'write_handle';my$dflt_enc=defined$arg->{binmode}? $arg->{binmode}: 'encoding(UTF-8)';sub {my ($invocant,$data,$options,$filename);if (ref $_[2]eq 'HASH'){($invocant,$data,$options,$filename)=splice @_,0,4}else {($invocant,$data,$filename)=splice @_,0,3}$options->{binmode}=$dflt_enc unless defined$options->{binmode};$options->{binmode}=~ s/^://;Carp::croak "no filename specified" unless$filename;Carp::croak "'$filename' is not a plain file" if -e $filename &&!-f _;my$handle=IO::File->new($filename,">:$options->{binmode}")or Carp::croak "couldn't write to file '$filename': $!";$invocant->write_handle($data,$handle,@_)}}sub _mk_write_string {my ($self,$name,$arg)=@_;my$method=defined$arg->{method}? $arg->{method}: 'write_handle';my$dflt_enc=defined$arg->{binmode}? $arg->{binmode}: 'encoding(UTF-8)';sub {my ($invocant,$data)=splice @_,0,2;my$binmode=$dflt_enc;$binmode =~ s/^://;my$string='';open my$handle,">:$binmode",\$string or die "error opening string for output: $!";$invocant->write_handle($data,$handle,@_);close$handle or die "error closing string after output: $!";return$string}}1;
MIXIN_LINEWISE_WRITERS

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;$Module::Implementation::VERSION='0.09';use strict;use warnings;use Module::Runtime 0.012 qw(require_module);use Try::Tiny;unless (exists$Module::Implementation::{VERSION}&& ${$Module::Implementation::{VERSION}}){$Module::Implementation::{VERSION}=\42}my%Implementation;sub build_loader_sub {my$caller=caller();return _build_loader($caller,@_)}sub _build_loader {my$package=shift;my%args=@_;my@implementations=@{$args{implementations}};my@symbols=@{$args{symbols}|| []};my$implementation;my$env_var=uc$package;$env_var =~ s/::/_/g;$env_var .= '_IMPLEMENTATION';return sub {my ($implementation,$loaded)=_load_implementation($package,$ENV{$env_var},\@implementations,);$Implementation{$package}=$implementation;_copy_symbols($loaded,$package,\@symbols);return$loaded}}sub implementation_for {my$package=shift;return$Implementation{$package}}sub _load_implementation {my$package=shift;my$env_value=shift;my$implementations=shift;if ($env_value){die "$env_value is not a valid implementation for $package" unless grep {$_ eq $env_value}@{$implementations};my$requested="${package}::$env_value";($requested)=$requested =~ /^(.+)$/;try {require_module($requested)}catch {require Carp;Carp::croak("Could not load $requested: $_")};return ($env_value,$requested)}else {my$err;for my$possible (@{$implementations}){my$try="${package}::$possible";my$ok;try {require_module($try);$ok=1}catch {$err .= $_ if defined $_};return ($possible,$try)if$ok}require Carp;if (defined$err && length$err){Carp::croak("Could not find a suitable $package implementation: $err")}else {Carp::croak('Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken')}}}sub _copy_symbols {my$from_package=shift;my$to_package=shift;my$symbols=shift;for my$sym (@{$symbols}){my$type=$sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';my$from="${from_package}::$sym";my$to="${to_package}::$sym";{no strict 'refs';no warnings 'once';*{$to}=$type eq '&' ? \&{$from}: $type eq '$' ? \${$from}: $type eq '@' ? \@{$from}: $type eq '%' ? \%{$from}: $type eq '*' ? *{$from}: die "Can't copy symbol from $from_package to $to_package: $type$sym"}}}1;
MODULE_IMPLEMENTATION

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='5.1';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION);use if $] > 5.017,'deprecate';$VERSION='5.1';sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||=["${pkg}::Plugin"];$self->{'on_require_error'}||=sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||=sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {$self->_require($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}sub _require {my$self=shift;my$pack=shift;eval "CORE::require $pack";die ($@)if $@;return 1}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.014";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Module/Runtime/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME_CONFLICTS';
  use strict;use warnings;package Module::Runtime::Conflicts;$Module::Runtime::Conflicts::VERSION='0.001';package Module::Runtime::Conflicts;use Module::Runtime ();use Dist::CheckConflicts -dist=>'Module::Runtime',-conflicts=>{eval {Module::Runtime->VERSION('0.14');1}? ('Moose'=>'2.1202'): (),},-also=>['Package::Stash::Conflicts','Moose::Conflicts',];1;
MODULE_RUNTIME_CONFLICTS

$fatpacked{"Moose/Autobox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX';
  package Moose::Autobox;use 5.006;use strict;use warnings;use Carp qw(confess);use Scalar::Util ();use Moose::Util ();our$VERSION='0.15';use parent 'autobox';use Moose::Autobox::Undef;sub import {(shift)->SUPER::import(DEFAULT=>'Moose::Autobox::',UNDEF=>'Moose::Autobox::Undef',)}sub mixin_additional_role {my ($class,$type,$role)=@_;($type =~ /SCALAR|ARRAY|HASH|CODE/)|| confess "Can only add additional roles to SCALAR, ARRAY, HASH or CODE";Moose::Util::apply_all_roles(('Moose::Autobox::' .$type)->meta,($role))}{package Moose::Autobox::SCALAR;use Moose::Autobox::Scalar;use metaclass 'Moose::Meta::Class';Moose::Util::apply_all_roles(__PACKAGE__->meta,('Moose::Autobox::Scalar'));*does=\&Moose::Object::does;package Moose::Autobox::ARRAY;use Moose::Autobox::Array;use metaclass 'Moose::Meta::Class';Moose::Util::apply_all_roles(__PACKAGE__->meta,('Moose::Autobox::Array'));*does=\&Moose::Object::does;package Moose::Autobox::HASH;use Moose::Autobox::Hash;use metaclass 'Moose::Meta::Class';Moose::Util::apply_all_roles(__PACKAGE__->meta,('Moose::Autobox::Hash'));*does=\&Moose::Object::does;package Moose::Autobox::CODE;use Moose::Autobox::Code;use metaclass 'Moose::Meta::Class';Moose::Util::apply_all_roles(__PACKAGE__->meta,('Moose::Autobox::Code'));*does=\&Moose::Object::does}1;
MOOSE_AUTOBOX

$fatpacked{"Moose/Autobox/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_ARRAY';
  package Moose::Autobox::Array;use Moose::Role 'with';use Moose::Autobox;use Syntax::Keyword::Junction::All ();use Syntax::Keyword::Junction::Any ();use Syntax::Keyword::Junction::None ();use Syntax::Keyword::Junction::One ();our$VERSION='0.15';with 'Moose::Autobox::Ref','Moose::Autobox::List','Moose::Autobox::Indexed';sub pop {my ($array)=@_;CORE::pop @$array}sub push {my ($array,@rest)=@_;CORE::push @$array,@rest;$array}sub unshift {my ($array,@rest)=@_;CORE::unshift @$array,@rest;$array}sub delete {my ($array,$index)=@_;CORE::delete$array->[$index]}sub shift {my ($array)=@_;CORE::shift @$array}sub slice {my ($array,$indicies)=@_;[@{$array}[@{$indicies}]]}sub sprintf {CORE::sprintf $_[1],@{$_[0]}}sub head {$_[0]->[0]}sub tail {[@{$_[0]}[1 .. $#{$_[0]}]]}sub length {my ($array)=@_;CORE::scalar @$array}sub grep {my ($array,$sub)=@_;[CORE::grep {$sub->($_)}@$array ]}sub map {my ($array,$sub)=@_;[CORE::map {$sub->($_)}@$array ]}sub join {my ($array,$sep)=@_;$sep ||='';CORE::join$sep,@$array}sub reverse {my ($array)=@_;[CORE::reverse @$array ]}sub sort {my ($array,$sub)=@_;$sub ||=sub {$a cmp $b};[CORE::sort {$sub->($a,$b)}@$array ]}sub first {$_[0]->[0]}sub last {$_[0]->[$#{$_[0]}]}sub at {my ($array,$index)=@_;$array->[$index]}sub put {my ($array,$index,$value)=@_;$array->[$index]=$value}sub exists {my ($array,$index)=@_;CORE::exists$array->[$index]}sub keys {my ($array)=@_;[0 .. $#{$array}]}sub values {my ($array)=@_;[@$array ]}sub kv {my ($array)=@_;$array->keys->map(sub {[$_,$array->[$_]]})}sub each {my ($array,$sub)=@_;for my$i (0 .. $#$array){$sub->($i,$array->[$i ])}}sub each_key {my ($array,$sub)=@_;$sub->($_)for (0 .. $#$array)}sub each_value {my ($array,$sub)=@_;$sub->($_)for @$array}sub each_n_values {my ($array,$n,$sub)=@_;my$it=List::MoreUtils::natatime($n,@$array);while (my@vals=$it->()){$sub->(@vals)}return}sub flatten {@{$_[0]}}sub _flatten_deep {my@array=@_;my$depth=CORE::pop@array;--$depth if (defined($depth));CORE::map {(ref eq 'ARRAY')? (defined($depth)&& $depth==-1)? $_ : _flatten_deep(@$_,$depth): $_}@array}sub flatten_deep {my ($array,$depth)=@_;[_flatten_deep(@$array,$depth)]}sub all {my ($array)=@_;return Syntax::Keyword::Junction::All->new(@$array)}sub any {my ($array)=@_;return Syntax::Keyword::Junction::Any->new(@$array)}sub none {my ($array)=@_;return Syntax::Keyword::Junction::None->new(@$array)}sub one {my ($array)=@_;return Syntax::Keyword::Junction::One->new(@$array)}sub print {CORE::print @{$_[0]}}sub say {CORE::print @{$_[0]},"\n"}no Moose::Role;1;
MOOSE_AUTOBOX_ARRAY

$fatpacked{"Moose/Autobox/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_CODE';
  package Moose::Autobox::Code;use Moose::Role 'with';use Moose::Autobox;our$VERSION='0.15';with 'Moose::Autobox::Ref';sub curry {my ($f,@a)=@_;return sub {$f->(@a,@_)}}sub rcurry {my ($f,@a)=@_;return sub {$f->(@_,@a)}}sub compose {my ($f,$f2,@rest)=@_;return$f if!$f2;return (sub {$f2->($f->(@_))})->compose(@rest)}sub disjoin {my ($f,$f2)=@_;return sub {$f->(@_)|| $f2->(@_)}}sub conjoin {my ($f,$f2)=@_;return sub {$f->(@_)&& $f2->(@_)}}sub u {my$f=shift;sub {$f->($f,@_)}}sub y {my$f=shift;(sub {my$h=shift;sub {$f->(($h->u)->())->(@_)}}->u)->()}1;
MOOSE_AUTOBOX_CODE

$fatpacked{"Moose/Autobox/Defined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_DEFINED';
  package Moose::Autobox::Defined;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::Item';sub defined {1}1;
MOOSE_AUTOBOX_DEFINED

$fatpacked{"Moose/Autobox/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_HASH';
  package Moose::Autobox::Hash;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::Ref','Moose::Autobox::Indexed';sub delete {my ($hash,$key)=@_;CORE::delete$hash->{$key}}sub merge {my ($left,$right)=@_;Carp::confess "You must pass a hashref as argument to merge" unless ref$right eq 'HASH';return {%$left,%$right }}sub hslice {my ($hash,$keys)=@_;return {map {$_=>$hash->{$_}}@$keys }}sub flatten {return %{$_[0]}}sub at {my ($hash,$index)=@_;$hash->{$index}}sub put {my ($hash,$index,$value)=@_;$hash->{$index}=$value}sub exists {my ($hash,$key)=@_;CORE::exists$hash->{$key}}sub keys {my ($hash)=@_;[CORE::keys %$hash ]}sub values {my ($hash)=@_;[CORE::values %$hash ]}sub kv {my ($hash)=@_;[CORE::map {[$_,$hash->{$_}]}CORE::keys %$hash ]}sub slice {my ($hash,$keys)=@_;return [@{$hash}{@$keys}]}sub each {my ($hash,$sub)=@_;for my$key (CORE::keys %$hash){$sub->($key,$hash->{$key})}}sub each_key {my ($hash,$sub)=@_;$sub->($_)for CORE::keys %$hash}sub each_value {my ($hash,$sub)=@_;$sub->($_)for CORE::values %$hash}sub each_n_values {my ($hash,$n,$sub)=@_;my@keys=CORE::keys %$hash;my$it=List::MoreUtils::natatime($n,@keys);while (my@vals=$it->()){$sub->(@$hash{@vals })}return}sub print {CORE::print %{$_[0]}}sub say {CORE::print %{$_[0]},"\n"}1;
MOOSE_AUTOBOX_HASH

$fatpacked{"Moose/Autobox/Indexed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_INDEXED';
  package Moose::Autobox::Indexed;use Moose::Role 'requires';our$VERSION='0.15';requires 'at';requires 'put';requires 'exists';requires 'keys';requires 'values';requires 'kv';requires 'slice';requires qw(each each_key each_value each_n_values);1;
MOOSE_AUTOBOX_INDEXED

$fatpacked{"Moose/Autobox/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_ITEM';
  package Moose::Autobox::Item;use Moose::Role 'requires';our$VERSION='0.15';requires 'defined';sub dump {my$self=shift;require Data::Dumper;return Data::Dumper::Dumper($self)}*perl=\&dump;1;
MOOSE_AUTOBOX_ITEM

$fatpacked{"Moose/Autobox/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_LIST';
  package Moose::Autobox::List;use Moose::Role 'with','requires';use Moose::Autobox;our$VERSION='0.15';with 'Moose::Autobox::Value';requires 'head';requires 'tail';requires 'length';requires 'join';requires 'grep';requires 'map';requires 'sort';requires 'reverse';sub reduce {my ($array,$func)=@_;my$a=$array->values;my$acc=$a->head;$a->tail->map(sub {$acc=$func->($acc,$_)});return$acc}sub zip {my ($array,$other)=@_;($array->length < $other->length ? $other : $array)->keys ->map(sub {[$array->at($_),$other->at($_)]})}1;
MOOSE_AUTOBOX_LIST

$fatpacked{"Moose/Autobox/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_NUMBER';
  package Moose::Autobox::Number;use Moose::Role;our$VERSION='0.15';with 'Moose::Autobox::Value';sub to {return [$_[0].. $_[1]]if $_[0]<= $_[1];return [reverse $_[1].. $_[0]]}1;
MOOSE_AUTOBOX_NUMBER

$fatpacked{"Moose/Autobox/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_REF';
  package Moose::Autobox::Ref;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::Defined';1;
MOOSE_AUTOBOX_REF

$fatpacked{"Moose/Autobox/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_SCALAR';
  package Moose::Autobox::Scalar;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::String','Moose::Autobox::Number';sub flatten {$_[0]}sub first {$_[0]}sub last {$_[0]}sub print {CORE::print $_[0]}sub say {CORE::print $_[0],"\n"}1;
MOOSE_AUTOBOX_SCALAR

$fatpacked{"Moose/Autobox/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_STRING';
  package Moose::Autobox::String;use Moose::Role;our$VERSION='0.15';with 'Moose::Autobox::Value';sub lc {CORE::lc $_[0]}sub lcfirst {CORE::lcfirst $_[0]}sub uc {CORE::uc $_[0]}sub ucfirst {CORE::ucfirst $_[0]}sub chomp {CORE::chomp $_[0]}sub chop {CORE::chop $_[0]}sub reverse {CORE::reverse $_[0]}sub length {CORE::length $_[0]}sub lines {[CORE::split '\n',$_[0]]}sub words {[CORE::split ' ',$_[0]]}sub index {return CORE::index($_[0],$_[1])if scalar @_==2;return CORE::index($_[0],$_[1],$_[2])}sub rindex {return CORE::rindex($_[0],$_[1])if scalar @_==2;return CORE::rindex($_[0],$_[1],$_[2])}sub split {return [CORE::split($_[1],$_[0])]if scalar @_==2;return [CORE::split($_[1],$_[0],$_[2])]}1;
MOOSE_AUTOBOX_STRING

$fatpacked{"Moose/Autobox/Undef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_UNDEF';
  package Moose::Autobox::Undef;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::Item';sub defined {0}1;
MOOSE_AUTOBOX_UNDEF

$fatpacked{"Moose/Autobox/Value.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSE_AUTOBOX_VALUE';
  package Moose::Autobox::Value;use Moose::Role 'with';our$VERSION='0.15';with 'Moose::Autobox::Defined';sub do {my ($self,$block)=@_;local $_=$self;$block->($self)}1;
MOOSE_AUTOBOX_VALUE

$fatpacked{"MooseX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX';
  use strict;use warnings;package MooseX;{$MooseX::VERSION='0.001'}BEGIN {$MooseX::AUTHORITY='cpan:ETHER'}1;
MOOSEX

$fatpacked{"MooseX/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP';
  package MooseX::App;use 5.010;use utf8;use strict;use warnings;our$AUTHORITY='cpan:MAROS';our$VERSION='1.30';use MooseX::App::Meta::Role::Attribute::Option;use MooseX::App::Exporter qw(app_usage app_description app_base app_fuzzy app_strict app_prefer_commandline option parameter);use MooseX::App::Message::Envelope;use Moose::Exporter;use Scalar::Util qw(blessed);my ($IMPORT,$UNIMPORT,$INIT_META)=Moose::Exporter->build_import_methods(with_meta=>[qw(app_usage app_description app_namespace app_base app_fuzzy app_command_name app_strict option parameter) ],also=>['Moose' ],as_is=>['new_with_command' ],install=>['unimport','init_meta' ],);sub import {my ($class,@plugins)=@_;my ($caller_class)=caller();MooseX::App::Exporter->process_plugins($caller_class,@plugins);return$class->$IMPORT({into=>$caller_class })}sub init_meta {my ($class,%args)=@_;$args{roles}=['MooseX::App::Role::Base'];$args{metaroles}={class=>['MooseX::App::Meta::Role::Class::Base','MooseX::App::Meta::Role::Class::Documentation' ],attribute=>['MooseX::App::Meta::Role::Attribute::Option'],};return MooseX::App::Exporter->process_init_meta(%args)}sub app_command_name(&) {my ($meta,$namesub)=@_;return$meta->app_command_name($namesub)}sub app_namespace(@) {my ($meta,@namespaces)=@_;return$meta->app_namespace(\@namespaces)}sub new_with_command {my ($class,@args)=@_;Moose->throw_error('new_with_command is a class method')if!defined$class || blessed($class);my$meta=$class->meta;my$metameta=$meta->meta;Moose->throw_error('new_with_command may only be called from the application base package:'.$class)if$metameta->does_role('MooseX::App::Meta::Role::Class::Command')||!$metameta->does_role('MooseX::App::Meta::Role::Class::Base');my%args;if (scalar@args==1 && ref($args[0])eq 'HASH'){%args=%{$args[0]}}elsif (scalar@args % 2==0){%args=@args}else {Moose->throw_error('new_with_command got invalid extra arguments')}my$parsed_argv=MooseX::App::ParsedArgv->instance();my$first_argv=$parsed_argv->first_argv;if (defined$first_argv && lc($first_argv)=~ m/^(help|h|\?|usage|-h|--help|-\?|--usage)$/){return MooseX::App::Message::Envelope->new($meta->command_usage_global(),)}elsif (!defined$first_argv || $first_argv =~ m/^\s*$/ || $first_argv =~ m/^-{1,2}\w/){return MooseX::App::Message::Envelope->new($meta->command_message(header=>"Missing command",type=>"error",),$meta->command_usage_global(),)}else {my$return=$meta->command_find($first_argv);if (blessed$return && $return->isa('MooseX::App::Message::Block')){return MooseX::App::Message::Envelope->new($return,$meta->command_usage_global(),)}else {my$command_class=$meta->command_get($return);return$class->initialize_command_class($command_class,%args)}}}no Moose;1;
MOOSEX_APP

$fatpacked{"MooseX/App/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_COMMAND';
  package MooseX::App::Command;use 5.010;use utf8;use strict;use warnings;use Moose ();use MooseX::App::Meta::Role::Attribute::Option;use MooseX::App::Exporter qw(option parameter command_short_description command_long_description command_usage command_strict);use Moose::Exporter;Moose::Exporter->setup_import_methods(with_meta=>[qw(command_short_description command_long_description command_strict command_usage option parameter)],also=>'Moose',);sub init_meta {my ($class,%args)=@_;my$meta=Moose->init_meta(%args);Moose::Util::MetaRole::apply_metaroles(for=>$meta,class_metaroles=>{class=>['MooseX::App::Meta::Role::Class::Documentation','MooseX::App::Meta::Role::Class::Command' ],attribute=>['MooseX::App::Meta::Role::Attribute::Option'],},);Moose::Util::MetaRole::apply_base_class_roles(for=>$args{for_class},roles=>['MooseX::App::Role::Common'],);return$meta}1;
MOOSEX_APP_COMMAND

$fatpacked{"MooseX/App/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_EXPORTER';
  package MooseX::App::Exporter;use 5.010;use utf8;use strict;use warnings;use Moose::Exporter;use MooseX::App::Utils;use MooseX::App::ParsedArgv;no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);my%PLUGIN_SPEC;sub import {my ($class,@imports)=@_;my$caller_class=caller();my$caller_stash=Package::Stash->new($caller_class);my$exporter_stash=Package::Stash->new(__PACKAGE__);for my$import (@imports){my$symbol=$exporter_stash->get_symbol('&'.$import);Carp::confess(sprintf('Symbol %s not defined in %s',$import,__PACKAGE__))unless defined$symbol;$caller_stash->add_symbol('&'.$import,$symbol)}return}sub parameter {my ($meta,$name,@rest)=@_;return _handle_attribute($meta,$name,'parameter',@rest)}sub option {my ($meta,$name,@rest)=@_;return _handle_attribute($meta,$name,'option',@rest)}sub _handle_attribute {my ($meta,$name,$type,@rest)=@_;Moose->throw_error('Usage: option \'name\' => ( key => value, ... )')if@rest % 2==1;my%info;@info{qw(package file line)}=caller(2);my%attributes=(definition_context=>\%info,@rest);my$attrs=(ref($name)eq 'ARRAY')? $name : [($name)];$attributes{'cmd_type'}=$type;for my$attr (@$attrs){my%local_attributes=%attributes;if ($attr =~ m/^\+(.+)/){my$meta_attribute=$meta->find_attribute_by_name($1);unless ($meta_attribute->does('MooseX::App::Meta::Role::Attribute::Option')){$local_attributes{traits}||=[];push @{$local_attributes{traits}},'MooseX::App::Meta::Role::Attribute::Option' unless 'AppOption' ~~ $local_attributes{traits}|| 'MooseX::App::Meta::Role::Attribute::Option' ~~ $local_attributes{traits}}}$meta->add_attribute($attr,%local_attributes)}return}sub app_prefer_commandline($) {my ($meta,$value)=@_;return$meta->app_prefer_commandline($value)}sub app_strict($) {my ($meta,$value)=@_;return$meta->app_strict($value)}sub app_fuzzy($) {my ($meta,$value)=@_;return$meta->app_fuzzy($value)}sub app_base($) {my ($meta,$name)=@_;return$meta->app_base($name)}sub process_plugins {my ($self,$caller_class,@plugins)=@_;my@plugin_classes;for my$plugin (@plugins){my$plugin_class='MooseX::App::Plugin::'.$plugin;Class::Load::load_class($plugin_class);push (@plugin_classes,$plugin_class)}$PLUGIN_SPEC{$caller_class}=\@plugin_classes;return}sub process_init_meta {my ($self,%args)=@_;my$meta=Moose->init_meta(%args);my$plugins=$PLUGIN_SPEC{$args{for_class}}|| [];my$apply_metaroles=delete$args{metaroles}|| {};my$apply_roles=delete$args{roles}|| [];for my$plugin (@$plugins){push(@{$apply_roles},$plugin,{-excludes=>['plugin_metaroles' ]})}push(@{$apply_roles},'MooseX::App::Role::Common')unless$apply_roles ~~ 'MooseX::App::Role::Common';for my$plugin_class (@{$plugins}){if ($plugin_class->can('plugin_metaroles')){my ($metaroles)=$plugin_class->plugin_metaroles($args{for_class});if (ref$metaroles eq 'HASH'){for my$type (keys %$metaroles){$apply_metaroles->{$type}||=[];push (@{$apply_metaroles->{$type}},@{$metaroles->{$type}})}}}}Moose::Util::MetaRole::apply_metaroles(for=>$args{for_class},class_metaroles=>$apply_metaroles);Moose::Util::apply_all_roles($args{for_class},@{$apply_roles});for my$plugin_class (@{$plugins}){if ($plugin_class->can('init_plugin')){$plugin_class->init_plugin($args{for_class})}}return$meta}sub command_short_description($) {my ($meta,$description)=@_;return$meta->command_short_description($description)}sub command_long_description($) {my ($meta,$description)=@_;return$meta->command_long_description($description)}sub command_usage($) {my ($meta,$usage)=@_;return$meta->command_usage($usage)}*app_description=\&command_long_description;*app_usage=\&command_usage;sub command_strict($) {my ($meta,$value)=@_;return$meta->command_strict($value)}1;
MOOSEX_APP_EXPORTER

$fatpacked{"MooseX/App/Message/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_MESSAGE_BLOCK';
  package MooseX::App::Message::Block;use 5.010;use utf8;use namespace::autoclean;use Moose;use MooseX::App::Utils;use overload '""'=>"stringify";has 'header'=>(is=>'rw',isa=>'MooseX::App::Types::MessageString',predicate=>'has_header',);has 'type'=>(is=>'rw',isa=>'Str',default=>'default',);has 'body'=>(is=>'rw',isa=>'MooseX::App::Types::MessageString',predicate=>'has_body',);sub stringify {my ($self)=@_;my$message='';$message .= $self->header."\n" if$self->has_header;$message .= $self->body."\n\n" if$self->has_body;return$message}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_MESSAGE_BLOCK

$fatpacked{"MooseX/App/Message/BlockColor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_MESSAGE_BLOCKCOLOR';
  package MooseX::App::Message::BlockColor;use 5.010;use utf8;use namespace::autoclean;use Moose;extends qw(MooseX::App::Message::Block);no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);use Term::ANSIColor qw();use IO::Interactive qw(is_interactive);BEGIN {if ($^O eq 'MSWin32'){Class::Load::try_load_class('Win32::Console::ANSI')}};sub stringify {my ($self)=@_;my$header_color;my$body_color;given ($self->type){when('error'){$header_color='bright_red bold';$body_color='bright_red'}when('default'){$header_color='bold'}default {$header_color=$_}}my$message='';if ($self->has_header){$message .= $self->_wrap_color($header_color,$self->header)."\n"}if ($self->has_body){$message .= $self->_wrap_color($body_color,$self->body)."\n\n"}return$message}sub _wrap_color {my ($self,$color,$string)=@_;return$string unless is_interactive()&& defined$color;return Term::ANSIColor::color($color).$string .Term::ANSIColor::color('reset')}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_MESSAGE_BLOCKCOLOR

$fatpacked{"MooseX/App/Message/Envelope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_MESSAGE_ENVELOPE';
  package MooseX::App::Message::Envelope;use 5.010;use utf8;use namespace::autoclean;use Moose;use MooseX::App::Message::Block;use overload '""'=>"stringify";has 'blocks'=>(is=>'rw',isa=>'ArrayRef[MooseX::App::Message::Block]',traits=>['Array'],handles=>{add_block=>'push',list_blocks=>'elements',},);around 'BUILDARGS'=>sub {my$orig=shift;my$self=shift;my@args=@_;my@blocks;for my$element (@args){if (blessed$element && $element->isa('MooseX::App::Message::Block')){push(@blocks,$element)}else {push(@blocks,MooseX::App::Message::Block->new(header=>$element,))}}return$self->$orig({blocks=>\@blocks,})};sub stringify {my ($self)=@_;my$message='';for my$block ($self->list_blocks){$message .= $block->stringify}return$message}sub AUTOLOAD {my ($self)=@_;print$self->stringify;return$MooseX::App::Null::NULL}{package MooseX::App::Null;use strict;use warnings;use overload 'bool'=>sub {0},'""'=>sub {''},'0+'=>sub {0};our$NULL=bless {},__PACKAGE__;sub AUTOLOAD {return$NULL}}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_MESSAGE_ENVELOPE

$fatpacked{"MooseX/App/Meta/Role/Attribute/Option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_META_ROLE_ATTRIBUTE_OPTION';
  package MooseX::App::Meta::Role::Attribute::Option;use utf8;use 5.010;use namespace::autoclean;use Moose::Role;has 'cmd_type'=>(is=>'rw',isa=>'MooseX::App::Types::CmdTypes',predicate=>'has_cmd_type',);has 'cmd_tags'=>(is=>'rw',isa=>'ArrayRef[Str]',predicate=>'has_cmd_tags',);has 'cmd_flag'=>(is=>'rw',isa=>'Str',predicate=>'has_cmd_flag',);has 'cmd_aliases'=>(is=>'rw',isa=>'MooseX::App::Types::List',predicate=>'has_cmd_aliases',coerce=>1,);has 'cmd_split'=>(is=>'rw',isa=>Moose::Util::TypeConstraints::union([qw(Str RegexpRef)]),predicate=>'has_cmd_split',);has 'cmd_env'=>(is=>'rw',isa=>'MooseX::App::Types::Env',predicate=>'has_cmd_env',);has 'cmd_position'=>(is=>'rw',isa=>'Int',default=>0,);my$GLOBAL_COUNTER=1;around 'new'=>sub {my$orig=shift;my$class=shift;my$self=$class->$orig(@_);if ($self->has_cmd_type){if ($self->cmd_position==0){$GLOBAL_COUNTER++;$self->cmd_position($GLOBAL_COUNTER)}}return$self};sub cmd_is_bool {my ($self)=@_;if ($self->has_type_constraint && $self->type_constraint->is_a_type_of('Bool')){if ($self->has_default &&!$self->is_default_a_coderef && $self->default==1){return 0}return 1}my$ud=undef;return$ud}sub cmd_type_constraint_description {my ($self,$type_constraint,$singular)=@_;$type_constraint //= $self->type_constraint;$singular //= 1;if ($type_constraint->isa('Moose::Meta::TypeConstraint::Enum')){return 'one of these values: '.join(', ',@{$type_constraint->values})}elsif ($type_constraint->isa('Moose::Meta::TypeConstraint::Parameterized')){my$from=$type_constraint->parameterized_from;if ($from->is_a_type_of('ArrayRef')){return$self->cmd_type_constraint_description($type_constraint->type_parameter)}elsif ($from->is_a_type_of('HashRef')){return 'key-value pairs of '.$self->cmd_type_constraint_description($type_constraint->type_parameter,0)}}elsif ($type_constraint->equals('Int')){return$singular ? 'an integer':'integers'}elsif ($type_constraint->equals('Num')){return$singular ? 'a number':'numbers'}elsif ($type_constraint->equals('Str')){return$singular ? 'a string':'strings'}elsif ($type_constraint->equals('HashRef')){return 'key-value pairs'}if ($type_constraint->has_parent){return$self->cmd_type_constraint_description($type_constraint->parent)}return}sub cmd_type_constraint_check {my ($self,$value)=@_;return unless ($self->has_type_constraint);my$type_constraint=$self->type_constraint;unless ($type_constraint->check($value)){if (ref($value)eq 'ARRAY'){$value=join(', ',@$value)}elsif (ref($value)eq 'HASH'){$value=join(', ',map {$_.'='.$value->{$_}}keys %$value)}if ($type_constraint->has_message){return$type_constraint->get_message($value)}else {my$message_human=$self->cmd_type_constraint_description($type_constraint);if (defined$message_human){return "Value must be ".$message_human ." (not '$value')"}else {return$type_constraint->get_message($value)}}}return}sub cmd_usage_description {my ($self)=@_;my$description=($self->has_documentation)? $self->documentation : '';my@tags=$self->cmd_tags_list();if (scalar@tags){$description .= ' ' if$description;$description .= '['.join('; ',@tags).']'}return$description}sub cmd_usage_name {my ($self)=@_;if ($self->cmd_type eq 'parameter'){return$self->cmd_name_primary}else {return join(' ',map {(length($_)==1)? "-$_":"--$_"}$self->cmd_name_possible)}}sub cmd_name_primary {my ($self)=@_;if ($self->has_cmd_flag){return$self->cmd_flag}else {return$self->name}}sub cmd_name_possible {my ($self)=@_;my@names=($self->cmd_name_primary);if ($self->has_cmd_aliases){push(@names,@{$self->cmd_aliases})}return@names}sub cmd_tags_list {my ($self)=@_;my@tags;if ($self->is_required &&!$self->is_lazy_build &&!$self->has_default){push(@tags,'Required')}if ($self->has_default &&!$self->is_default_a_coderef){if ($self->has_type_constraint && $self->type_constraint->is_a_type_of('Bool')){}else {push(@tags,'Default:"'.$self->default.'"')}}if ($self->has_type_constraint){my$type_constraint=$self->type_constraint;if ($type_constraint->is_subtype_of('ArrayRef')){if ($self->has_cmd_split){my$split=$self->cmd_split;if (ref($split)eq 'Regexp'){$split="$split";$split =~ s/^\(\?\^\w*:(.+)\)$/$1/x}push(@tags,'Multiple','Split by "'.$split.'"')}else {push(@tags,'Multiple')}}elsif ($type_constraint->is_a_type_of('HashRef')){push(@tags,'Key-Value')}unless ($self->should_coerce){if ($type_constraint->is_a_type_of('Int')){push(@tags,'Integer')}elsif ($type_constraint->is_a_type_of('Num')){push(@tags,'Number')}elsif ($type_constraint->is_a_type_of('Bool')){push(@tags,'Flag')}elsif ($type_constraint->isa('Moose::Meta::TypeConstraint::Enum')){push(@tags,'Possible values: '.join(', ',@{$type_constraint->values}))}}}if ($self->can('has_cmd_env')&& $self->has_cmd_env){push(@tags,'Env: '.$self->cmd_env)}if ($self->can('cmd_tags')&& $self->can('cmd_tags')&& $self->has_cmd_tags){push(@tags,@{$self->cmd_tags})}return@tags}{package Moose::Meta::Attribute::Custom::Trait::AppOption;use strict;use warnings;sub register_implementation {return 'MooseX::App::Meta::Role::Attribute::Option'}}1;
MOOSEX_APP_META_ROLE_ATTRIBUTE_OPTION

$fatpacked{"MooseX/App/Meta/Role/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_META_ROLE_CLASS_BASE';
  package MooseX::App::Meta::Role::Class::Base;use utf8;use 5.010;use List::Util qw(max);use namespace::autoclean;use Moose::Role;use MooseX::App::Utils;use Path::Class;use Module::Pluggable::Object;no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);has 'app_messageclass'=>(is=>'rw',isa=>'ClassName',lazy_build=>1,);has 'app_namespace'=>(is=>'rw',isa=>'MooseX::App::Types::List',coerce=>1,lazy_build=>1,);has 'app_base'=>(is=>'rw',isa=>'Str',default=>sub {Path::Class::File->new($0)->basename},);has 'app_strict'=>(is=>'rw',isa=>'Bool',default=>0,);has 'app_fuzzy'=>(is=>'rw',isa=>'Bool',default=>1,);has 'app_command_name'=>(is=>'rw',isa=>'CodeRef',default=>sub {\&MooseX::App::Utils::class_to_command},);has 'app_prefer_commandline'=>(is=>'rw',isa=>'Bool',default=>0,);has 'app_commands'=>(is=>'rw',isa=>'HashRef[Str]',traits=>['Hash'],handles=>{command_register=>'set',command_get=>'get',},lazy_build=>1,);sub _build_app_messageclass {my ($self)=@_;return 'MooseX::App::Message::Block'}sub _build_app_namespace {my ($self)=@_;return [$self->name ]}sub _build_app_commands {my ($self)=@_;my@list;for my$namespace (@{$self->app_namespace}){push(@list,$self->command_scan_namespace($namespace))}return {@list }}sub command_scan_namespace {my ($self,$namespace)=@_;my$mpo=Module::Pluggable::Object->new(search_path=>[$namespace ],);my$commandsub=$self->app_command_name;my%return;for my$command_class ($mpo->plugins){my$command_class_name=substr($command_class,length($namespace)+2);next if$command_class_name =~ m/::/;$command_class_name =~ s/^\Q$namespace\E:://;$command_class_name =~ s/^.+::([^:]+)$/$1/;my$command=$commandsub->($command_class_name,$command_class);$return{$command}=$command_class}return%return}sub command_args {my ($self,$metaclass)=@_;$metaclass ||=$self;my$parsed_argv=MooseX::App::ParsedArgv->instance;my@attributes_option=$self->command_usage_attributes($metaclass,'option');my ($return,$errors)=$self->command_parse_options(\@attributes_option);my%raw_error;for my$option ($parsed_argv->available('option')){my$key=$option->key;my$raw=$option->original;my$message;next if defined$raw_error{$raw};if (length$key==1 && $raw =~ m/^-(\w+)$/){POSSIBLE_ATTRIBUTES: foreach my$attribute ($self->command_usage_attributes($metaclass,[qw(option proto)])){for my$name ($attribute->cmd_name_possible){if ($name eq $1){$raw_error{$raw}=1;$message="Did you mean '--$name'?";last POSSIBLE_ATTRIBUTES}}}}my$error;if (defined$message){$error=$self->command_message(header=>"Unknown option '".$raw."'",body=>$message,type=>"error",)}else {$error=$self->command_message(header=>"Unknown option '".$option->key."'",type=>"error",)}unshift(@{$errors},$error)}my@attributes_parameter=$self->command_usage_attributes($metaclass,'parameter');for my$attribute (@attributes_parameter){my$value=$parsed_argv->consume('parameter');last unless defined$value;my ($parameter_value,$parameter_errors)=$self->command_process_attribute($attribute,$value->key);push(@{$errors},@{$parameter_errors});$return->{$attribute->name}=$parameter_value}if ($self->app_strict || $metaclass->command_strict){for my$parameter ($parsed_argv->available('parameter')){unshift(@{$errors},$self->command_message(header=>"Unknown parameter '".$parameter->key."'",type=>"error",))}}for my$attribute ($self->command_usage_attributes($metaclass,'all')){next unless$attribute->can('has_cmd_env')&& $attribute->has_cmd_env;my$cmd_env=$attribute->cmd_env;if (exists$ENV{$cmd_env}&&!defined$return->{$attribute->name}){$return->{$attribute->name}=$ENV{$cmd_env};my$error=$attribute->cmd_type_constraint_check($ENV{$cmd_env});if ($error){push(@{$errors},$self->command_message(header=>"Invalid environment value for '".$cmd_env."'",type=>"error",body=>$error,))}}}return ($return,$errors)}sub command_proto {my ($self,$metaclass)=@_;$metaclass ||=$self;my@attributes;for my$attribute ($self->command_usage_attributes($metaclass,'proto')){next unless$attribute->does('AppOption')&& $attribute->has_cmd_type;push(@attributes,$attribute)}return$self->command_parse_options(\@attributes)}sub command_parse_options {my ($self,$attributes)=@_;my%option_to_attribute;for my$attribute (@{$attributes}){for my$name ($attribute->cmd_name_possible){if (defined$option_to_attribute{$name}&& $option_to_attribute{$name}!=$attribute){Moose->throw_error('Command line option conflict: '.$name)}$option_to_attribute{$name}=$attribute}}my$match={};my$return={};my@errors;my$parsed_argv=MooseX::App::ParsedArgv->instance;for my$option ($parsed_argv->available('option')){if (my$attribute=$option_to_attribute{$option->key}){$match->{$attribute->name}=$option->value;$option->consume($attribute)}}if ($self->app_fuzzy){for my$option (sort {length($b->key)<=> length($a->key)}$parsed_argv->available('option')){my$option_length=length($option->key);next if$option_length==1;my ($match_attributes)=[];for my$name (keys%option_to_attribute){next if ($option_length >= length($name));my$name_short=lc(substr($name,0,$option_length));if (lc($option->key)eq $name_short){my$attribute=$option_to_attribute{$name};unless (grep {$attribute==$_}@{$match_attributes}){push(@{$match_attributes},$attribute)}}}given (scalar @{$match_attributes}){when(0){}when(1){my$attribute=$match_attributes->[0];$option->consume();$match->{$attribute->name}||=[];push(@{$match->{$attribute->name}},@{$option->value})}default {$option->consume();push(@errors,$self->command_message(header=>"Ambiguous option '".$option->key."'",type=>"error",body=>"Could be\n".MooseX::App::Utils::format_list(map {[$_ ]}sort map {$_->cmd_name_primary}@{$match_attributes}),))}}}}for my$attribute (@{$attributes}){next unless exists$match->{$attribute->name};my ($value,$errors)=$self->command_process_attribute($attribute,$match->{$attribute->name});push(@errors,@{$errors});$return->{$attribute->name}=$value}return ($return,\@errors)}sub command_process_attribute {my ($self,$attribute,$raw)=@_;$raw=[$raw]unless ref($raw)eq 'ARRAY';my@errors;my$value;if ($attribute->has_cmd_split){my@raw_unfolded;for (@{$raw}){push(@raw_unfolded,split($attribute->cmd_split,$_))}$raw=\@raw_unfolded}if ($attribute->has_type_constraint){my$type_constraint=$attribute->type_constraint;if ($type_constraint->is_a_type_of('ArrayRef')){$value=$raw}elsif ($type_constraint->is_a_type_of('HashRef')){$value={};for my$element (@{$raw}){if ($element =~ m/^([^=]+)=(.+?)$/){$value->{$1}||=$2}else {push(@errors,$self->command_message(header=>"Invalid value for '".$attribute->cmd_name_primary."'",type=>"error",body=>"Value must be supplied as 'key=value' (not '$element')",))}}}elsif ($type_constraint->is_a_type_of('Bool')){$value=$attribute->cmd_is_bool}elsif ($type_constraint->is_a_type_of('Int')){$value=$raw->[-1]}else {$value=$raw->[-1]}unless(defined$value){push(@errors,$self->command_message(header=>"Missing value for '".$attribute->cmd_name_primary."'",type=>"error",))}else {if ($attribute->should_coerce && $type_constraint->has_coercion){my$coercion=$type_constraint->coercion;$value=$coercion->coerce($value)// $value}my$error=$attribute->cmd_type_constraint_check($value);if (defined$error){push(@errors,$self->command_message(header=>"Invalid value for '".$attribute->cmd_name_primary."'",type=>"error",body=>$error,))}}}else {$value=$raw->[-1]}return ($value,\@errors)}sub command_candidates {my ($self,$command)=@_;my$lc_command=lc($command);my$commands=$self->app_commands;my@candidates;my$candidate_length=length($command);for my$command_name (keys %$commands){if ($command_name eq $lc_command){return$command_name}elsif ($lc_command eq substr($command_name,0,$candidate_length)){push(@candidates,$command_name)}}return [sort@candidates ]}sub command_find {my ($self,$command)=@_;my$lc_command=lc($command);my$commands=$self->app_commands;if (defined$commands->{$lc_command}){return$lc_command}else {my$candidate=$self->command_candidates($command);if (ref$candidate eq ''){return$candidate}else {given (scalar @{$candidate}){when (0){return$self->command_message(header=>"Unknown command '$command'",type=>"error",)}when (1){if ($self->app_fuzzy){return$candidate->[0]}else {return$self->command_message(header=>"Unknown command '$command'",type=>"error",body=>"Did you mean '".$candidate->[0]."'?",)}}default {return$self->command_message(header=>"Ambiguous command '$command'",type=>"error",body=>"Which command did you mean?\n".MooseX::App::Utils::format_list(map {[$_ ]}sort @{$candidate}),)}}}}}sub command_parser_hints {my ($self,$metaclass)=@_;$metaclass ||=$self;my%hints;my%names;for my$attribute ($self->command_usage_attributes($metaclass,[qw(option proto)])){for my$name ($attribute->cmd_name_possible){$names{$name}={name=>$attribute->name,bool=>$attribute->cmd_is_bool };$hints{$name}=$names{$name}}}if ($self->app_fuzzy){my$length=max(map {length($_)}keys%names)// 0;for my$l (reverse(1..$length)){my%tmp;for my$name (keys%names){next if length($name)< $l;my$short_name=substr($name,0,$l);next if defined$hints{$short_name};$tmp{$short_name}||=[];next if defined$tmp{$short_name}->[0]&& $tmp{$short_name}->[0]->{name}eq $names{$name}->{name};push(@{$tmp{$short_name}},$names{$name})}for my$short_name (keys%tmp){next if scalar @{$tmp{$short_name}}> 1;$hints{$short_name}=$tmp{$short_name}->[0]}}}my@return;for my$name (keys%hints){next unless defined$hints{$name}->{bool};push(@return,$name)}return \@return}sub command_message {my ($self,@args)=@_;my$messageclass=$self->app_messageclass;Class::Load::load_class($messageclass);return$messageclass->new(@args)}sub command_check_attributes {my ($self,$command_meta,$errors,$params)=@_;$command_meta ||=$self;for my$attribute ($self->command_usage_attributes($command_meta,[qw(option proto parameter)])){if ($attribute->is_required &&!exists$params->{$attribute->name}&&!$attribute->has_default){push(@{$errors},$self->command_message(header=>"Required ".($attribute->cmd_type eq 'parameter' ? 'parameter':'option')." '".$attribute->cmd_name_primary."' missing",type=>"error",))}}return$errors}sub command_usage_attributes {my ($self,$metaclass,$types)=@_;$metaclass ||=$self;$types ||=[qw(option proto)];my@return;for my$attribute ($metaclass->get_all_attributes){next unless$attribute->does('AppOption')&& $attribute->has_cmd_type;next unless$types eq 'all' || $attribute->cmd_type ~~ $types;push(@return,$attribute)}return (sort {$a->cmd_position <=> $b->cmd_position}@return)}sub command_usage_options {my ($self,$metaclass,$headline)=@_;$headline ||='options:';$metaclass ||=$self;my@options;for my$attribute ($self->command_usage_attributes($metaclass,[qw(option proto)])){push(@options,[$attribute->cmd_usage_name(),$attribute->cmd_usage_description()])}@options=sort {$a->[0]cmp $b->[0]}@options;return unless scalar@options > 0;return$self->command_message(header=>$headline,body=>MooseX::App::Utils::format_list(@options),)}sub command_usage_parameters {my ($self,$metaclass,$headline)=@_;$headline ||='parameter:';$metaclass ||=$self;my@parameters;for my$attribute (sort {$a->cmd_position <=> $b->cmd_position}$self->command_usage_attributes($metaclass,'parameter')){push(@parameters,[$attribute->cmd_usage_name(),$attribute->cmd_usage_description()])}return unless scalar@parameters > 0;return$self->command_message(header=>$headline,body=>MooseX::App::Utils::format_list(@parameters),)}sub command_usage_header {my ($self,$command_meta_class)=@_;my$caller=$self->app_base;my ($command_name,$usage);if ($command_meta_class){$command_name=$self->command_class_to_command($command_meta_class->name)}else {$command_name='<command>'}$command_meta_class ||=$self;if ($command_meta_class->can('command_usage')&& $command_meta_class->command_usage_predicate){$usage=MooseX::App::Utils::format_text($command_meta_class->command_usage)}unless (defined$usage){$usage="$caller $command_name ";my@parameter=$self->command_usage_attributes($command_meta_class,'parameter');for my$attribute (@parameter){if ($attribute->is_required){$usage .= "<".$attribute->cmd_usage_name.'> '}else {$usage .= '['.$attribute->cmd_usage_name.'] '}}$usage .= "[long options...]
  $caller help
  $caller $command_name --help";$usage=MooseX::App::Utils::format_text($usage)}return$self->command_message(header=>'usage:',body=>$usage,)}sub command_usage_description {my ($self,$command_meta_class)=@_;$command_meta_class ||=$self;if ($command_meta_class->can('command_long_description')&& $command_meta_class->command_long_description_predicate){return$self->command_message(header=>'description:',body=>MooseX::App::Utils::format_text($command_meta_class->command_long_description),)}elsif ($command_meta_class->can('command_short_description')&& $command_meta_class->command_short_description_predicate){return$self->command_message(header=>'short description:',body=>MooseX::App::Utils::format_text($command_meta_class->command_short_description),)}return}sub command_class_to_command {my ($self,$command_class)=@_;my$commands=$self->app_commands;for my$element (keys %$commands){if ($command_class eq $commands->{$element}){return$element}}return}sub command_usage_command {my ($self,$command_meta_class)=@_;$command_meta_class ||=$self;my$command_class=$command_meta_class->name;my$command_name=$self->command_class_to_command($command_class);my@usage;push(@usage,$self->command_usage_header($command_meta_class));push(@usage,$self->command_usage_description($command_meta_class));push(@usage,$self->command_usage_parameters($command_meta_class,'parameters:'));push(@usage,$self->command_usage_options($command_meta_class,'options:'));return@usage}sub command_usage_global {my ($self)=@_;my@commands;push(@commands,['help','Prints this usage information']);my$commands=$self->app_commands;while (my ($command,$class)=each %$commands){Class::Load::load_class($class);my$command_description;$command_description=$class->meta->command_short_description if$class->meta->can('command_short_description');$command_description ||='';push(@commands,[$command,$command_description])}@commands=sort {$a->[0]cmp $b->[0]}@commands;my@usage;push(@usage,$self->command_usage_header());my$description=$self->command_usage_description($self);push(@usage,$description)if$description;push(@usage,$self->command_usage_parameters($self,'global parameters:'));push(@usage,$self->command_usage_options($self,'global options:'));push(@usage,$self->command_message(header=>'available commands:',body=>MooseX::App::Utils::format_list(@commands),));return@usage}1;
MOOSEX_APP_META_ROLE_CLASS_BASE

$fatpacked{"MooseX/App/Meta/Role/Class/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_META_ROLE_CLASS_COMMAND';
  package MooseX::App::Meta::Role::Class::Command;use utf8;use 5.010;use Moose::Role;1;
MOOSEX_APP_META_ROLE_CLASS_COMMAND

$fatpacked{"MooseX/App/Meta/Role/Class/Documentation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_META_ROLE_CLASS_DOCUMENTATION';
  package MooseX::App::Meta::Role::Class::Documentation;use utf8;use 5.010;use namespace::autoclean;use Moose::Role;use Pod::Elemental;use Pod::Elemental::Selectors qw();use Pod::Elemental::Transformer::Pod5;use Pod::Elemental::Transformer::Nester;has 'command_short_description'=>(is=>'rw',isa=>'Maybe[Str]',lazy_build=>1,);has 'command_long_description'=>(is=>'rw',isa=>'Maybe[Str]',lazy_build=>1,);has 'command_usage'=>(is=>'rw',isa=>'Maybe[Str]',lazy_build=>1,);has 'command_strict'=>(is=>'rw',isa=>'Bool',default=>0,);sub command_short_description_predicate {my ($self)=@_;return$self->_command_pod_predicate('command_short_description')}sub _build_command_short_description {my ($self)=@_;my%pod=$self->_build_command_pod();return$pod{'command_short_description'}if defined$pod{'command_short_description'};return}sub command_long_description_predicate {my ($self)=@_;return$self->_command_pod_predicate('command_long_description')}sub _build_command_long_description {my ($self)=@_;my%pod=$self->_build_command_pod();return$pod{'command_long_description'}if defined$pod{'command_long_description'};return}sub command_usage_predicate {my ($self)=@_;return$self->_command_pod_predicate('command_usage')}sub _build_command_usage {my ($self)=@_;my%pod=$self->_build_command_pod();return$pod{'command_usage'}if defined$pod{'command_usage'};return}sub _command_pod_predicate {my ($self,$field)=@_;my$attribute=$self->meta->find_attribute_by_name($field);unless ($attribute->has_value($self)){$self->_build_command_pod($field)}my$value=$attribute->get_value($self);return (defined$value && $value ? 1:0)}sub _build_command_pod {my ($self)=@_;my%pod_raw=MooseX::App::Utils::parse_pod($self->name);my%pod=(command_usage=>($pod_raw{SYNOPSIS}|| $pod_raw{USAGE}),command_long_description=>($pod_raw{DESCRIPTION}|| $pod_raw{OVERVIEW}),command_short_description=>($pod_raw{NAME}|| $pod_raw{ABSTRACT}),);while (my ($key,$value)=each%pod){my$meta_attribute=$self->meta->find_attribute_by_name($key);next unless defined$meta_attribute;next if$meta_attribute->has_value($self);$meta_attribute->set_raw_value($self,$value)}return%pod}1;
MOOSEX_APP_META_ROLE_CLASS_DOCUMENTATION

$fatpacked{"MooseX/App/Meta/Role/Class/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_META_ROLE_CLASS_SIMPLE';
  package MooseX::App::Meta::Role::Class::Simple;use utf8;use 5.010;use namespace::autoclean;use Moose::Role;around 'command_usage_header'=>sub {my ($orig,$self)=@_;my$caller=$self->app_base;my$usage;if ($self->can('command_usage')&& $self->command_usage_predicate){$usage=MooseX::App::Utils::format_text($self->command_usage)}unless ($usage){my$command=$caller;my@parameter=$self->command_usage_attributes($self,'parameter');for my$attribute (@parameter){if ($attribute->is_required){$command .= " <".$attribute->cmd_usage_name.'>'}else {$command .= ' ['.$attribute->cmd_usage_name.']'}}$usage=MooseX::App::Utils::format_text("$command [long options...]
  $caller --help")}return$self->command_message(header=>'usage:',body=>$usage)};1;
MOOSEX_APP_META_ROLE_CLASS_SIMPLE

$fatpacked{"MooseX/App/ParsedArgv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PARSEDARGV';
  package MooseX::App::ParsedArgv;use 5.010;use utf8;use Moose;use Encode qw(decode);use MooseX::App::ParsedArgv::Element;no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);my$SINGLETON;has 'argv'=>(is=>'rw',isa=>'ArrayRef[Str]',default=>sub {my@argv;@argv=eval {require I18N::Langinfo;I18N::Langinfo->import(qw(langinfo CODESET));my$codeset=langinfo(CODESET());binmode(STDOUT,":encoding(UTF-8)")if$codeset =~ m/^UTF-?8$/i;return map {decode($codeset,$_)}@ARGV};if ($@){@argv=@ARGV}return \@argv},);has 'hints'=>(is=>'rw',isa=>'ArrayRef[Str]',default=>sub {[]},);has 'elements'=>(is=>'rw',isa=>'ArrayRef[MooseX::App::ParsedArgv::Element]',lazy_build=>1,clearer=>'reset_elements',);sub BUILD {my ($self)=@_;$SINGLETON=$self;return$self}sub instance {my ($class)=@_;unless (defined$SINGLETON){return$class->new()}return$SINGLETON}sub first_argv {my ($self)=@_;$self->reset_elements;return shift(@{$self->argv})}sub _build_elements {my ($self)=@_;my (@elements);my%options;my$lastkey;my$stopprocessing;for my$element (@{$self->argv}){if ($stopprocessing){push (@elements,MooseX::App::ParsedArgv::Element->new(key=>$element,type=>'extra',))}else {given ($element){when (m/^-([^-][[:alnum:]]*)$/){undef$lastkey;for my$flag (split(//,$1)){unless (defined$options{$flag}){$options{$flag}=MooseX::App::ParsedArgv::Element->new(key=>$flag,type=>'option',raw=>$element,);push(@elements,$options{$flag})}$lastkey=$options{$flag}}}when (m/^--([^-=][^=]*)=(.+)$/){undef$lastkey;my ($key,$value)=($1,$2);unless (defined$options{$key}){$options{$key}=MooseX::App::ParsedArgv::Element->new(key=>$key,type=>'option',raw=>$element,);push(@elements,$options{$key})}$options{$key}->add_value($value)}when (m/^--([^-].*)/){my$key=$1;unless (defined$options{$key}){$options{$key}=MooseX::App::ParsedArgv::Element->new(key=>$key,type=>'option',raw=>$element,);push(@elements,$options{$key})}$lastkey=$options{$key}}when ('--'){undef$lastkey;$stopprocessing=1}default {if (defined$lastkey){if ($lastkey->key ~~ $self->hints){push(@elements,MooseX::App::ParsedArgv::Element->new(key=>$element,type=>'parameter'))}else {$lastkey->add_value($element)}undef$lastkey}else {push(@elements,MooseX::App::ParsedArgv::Element->new(key=>$element,type=>'parameter'))}}}}}return \@elements}sub available {my ($self,$type)=@_;my@elements;for my$element (@{$self->elements}){next if$element->consumed;next if defined$type && $element->type ne $type;push(@elements,$element)}return@elements}sub consume {my ($self,$type)=@_;for my$element (@{$self->elements}){next if$element->consumed;next if defined$type && $element->type ne $type;$element->consume;return$element}return}sub extra {my ($self)=@_;my@extra;for my$element (@{$self->elements}){next if$element->consumed;next unless$element->type eq 'parameter' || $element->type eq 'extra';push(@extra,$element->key)}return@extra}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_PARSEDARGV

$fatpacked{"MooseX/App/ParsedArgv/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PARSEDARGV_ELEMENT';
  package MooseX::App::ParsedArgv::Element;use 5.010;use utf8;use Moose;no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);has 'key'=>(is=>'ro',isa=>'Str',required=>1,);has 'value'=>(is=>'rw',isa=>'ArrayRef[Str]',traits=>['Array'],default=>sub {[]},handles=>{add_value=>'push',has_values=>'count',get_value=>'get',});has 'consumed'=>(is=>'rw',isa=>'Bool',default=>0,);has 'type'=>(is=>'rw',isa=>'Str',required=>1,);has 'raw'=>(is=>'rw',isa=>'Str',predicate=>'has_raw',);sub original {my ($self)=@_;if ($self->has_raw){return$self->raw}else {return$self->key}}sub consume {my ($self,$attribute)=@_;Moose->throw_error('Element '.$self->type.' '.$self->key.' is already consumed')if$self->consumed;$self->consumed(1);return$self}sub serialize {my ($self)=@_;given ($self->type){when ('extra'){return$self->key}when ('parameter'){return$self->key}when ('option'){my$key=(length$self->key==1 ? '-':'--').$self->key;return join(' ',map {$key.' '.$_}@{$self->value})}}return}__PACKAGE__->meta->make_immutable();1;
MOOSEX_APP_PARSEDARGV_ELEMENT

$fatpacked{"MooseX/App/Plugin/BashCompletion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_BASHCOMPLETION';
  package MooseX::App::Plugin::BashCompletion;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::BashCompletion::Meta::Class'],}}around 'initialize_command_class'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);if (blessed$return && $return->isa('MooseX::App::Plugin::BashCompletion::Command')){return$return->bash_completion($self)}return$return};1;
MOOSEX_APP_PLUGIN_BASHCOMPLETION

$fatpacked{"MooseX/App/Plugin/BashCompletion/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_BASHCOMPLETION_COMMAND';
  package MooseX::App::Plugin::BashCompletion::Command;use 5.010;use utf8;use namespace::autoclean;use Moose;use MooseX::App::Command;command_short_description q(Bash completion automator);sub bash_completion {my ($self,$app)=@_;my%command_map;my$app_meta=$app->meta;my$commands=$app_meta->app_commands;my$command_list=join (' ',keys %{$commands});my$package=__PACKAGE__;my$prefix=$app_meta->app_base;my ($sec,$min,$hour,$mday,$mon,$year)=localtime(time);$year += 1900;$mday=sprintf('%02i',$mday);$mon=sprintf('%02i',$mon+1);$prefix =~ tr/./_/;while (my ($command,$command_class)=each %$commands){Class::Load::load_class($command_class);my@options=$app_meta->command_usage_attributes($command_class->meta,[qw(option proto)]);$command_map{$command}={options=>[map {$_->cmd_usage_name}@options ],}}my$syntax='';;$syntax .= <<"EOT";while (my ($command,$data)=each%command_map){$syntax .= "_${prefix}_macc_${command}() {\n    _${prefix}_compreply \"";$syntax .= join(" ",@{$data->{options}});$syntax .= "\"\n}\n\n"}$syntax .= <<"EOT";$syntax .= "complete -o default -F _${prefix}_macc ".$app_meta->app_base."\n";return MooseX::App::Message::Envelope->new(MooseX::App::Message::Block->new({body=>$syntax }))}__PACKAGE__->meta->make_immutable;1;
  #!/bin/bash
   
  # Built with $package on $year/$mon/$mday
   
  ${prefix}_COMMANDS='help $command_list'
   
  _${prefix}_macc_help() {
      if [ \$COMP_CWORD = 2 ]; then
          _${prefix}_compreply "\$${prefix}_COMMANDS"
      else
          COMPREPLY=()
      fi
  }
  
  EOT
  _${prefix}_compreply() {
      COMPREPLY=(\$(compgen -W "\$1" -- \${COMP_WORDS[COMP_CWORD]}))
  }
   
  _${prefix}_macc() {
      case \$COMP_CWORD in
          0)
              ;;
          1)
              _${prefix}_compreply "\$${prefix}_COMMANDS"
              ;;
          *)
              eval _${prefix}_macc_\${COMP_WORDS[1]}
               
      esac
  }
   
  EOT
MOOSEX_APP_PLUGIN_BASHCOMPLETION_COMMAND

$fatpacked{"MooseX/App/Plugin/BashCompletion/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_BASHCOMPLETION_META_CLASS';
  package MooseX::App::Plugin::BashCompletion::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use MooseX::App::Plugin::BashCompletion::Command;around '_build_app_commands'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);$return->{bash_completion}||='MooseX::App::Plugin::BashCompletion::Command';return$return};1;
MOOSEX_APP_PLUGIN_BASHCOMPLETION_META_CLASS

$fatpacked{"MooseX/App/Plugin/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_COLOR';
  package MooseX::App::Plugin::Color;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Color::Meta::Class'],}}1;
MOOSEX_APP_PLUGIN_COLOR

$fatpacked{"MooseX/App/Plugin/Color/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_COLOR_META_CLASS';
  package MooseX::App::Plugin::Color::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use MooseX::App::Message::BlockColor;around '_build_app_messageclass'=>sub {return 'MooseX::App::Message::BlockColor'};1;
MOOSEX_APP_PLUGIN_COLOR_META_CLASS

$fatpacked{"MooseX/App/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_CONFIG';
  package MooseX::App::Plugin::Config;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use MooseX::App::Role;use MooseX::Types::Path::Class;use Config::Any;has 'config'=>(is=>'ro',isa=>'Path::Class::File',coerce=>1,predicate=>'has_config',documentation=>q[Path to command config file],traits=>['AppOption'],cmd_type=>'proto',cmd_position=>99990,);has '_config_data'=>(is=>'ro',isa=>'HashRef',predicate=>'has_config_data',);sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Config::Meta::Class'],}}1;
MOOSEX_APP_PLUGIN_CONFIG

$fatpacked{"MooseX/App/Plugin/Config/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_CONFIG_META_CLASS';
  package MooseX::App::Plugin::Config::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;around 'command_proto'=>sub {my ($orig,$self,$metaclass)=@_;my ($result,$errors)=$self->$orig($metaclass);delete$result->{config}unless defined$result->{config};return$self->proto_config($metaclass,$result,$errors)};sub proto_config {my ($self,$metaclass,$result,$errors)=@_;return ($result,$errors)unless defined$result->{config};my$config_file=Path::Class::File->new($result->{config});unless (-e $config_file->stringify){push(@{$errors},$self->command_message(header=>"Could not find config file '".$config_file->stringify."'",type=>"error",),);return ($result,$errors)}my$config_file_name=$config_file->stringify;my$configs=Config::Any->load_files({files=>[$config_file_name ],use_ext=>1,});my$command_name=$self->command_class_to_command($metaclass->name);my ($config_data)=values %{$configs->[0]};$config_data->{global}||={};$config_data->{$command_name}||={};$result->{config}=$result->{config};$result->{_config_data}=$config_data;for my$attribute ($self->command_usage_attributes($metaclass,'all')){my$attribute_name=$attribute->name;next if$attribute_name eq 'config' || $attribute_name eq 'help_flag';$result->{$attribute_name}=$config_data->{global}{$attribute_name}if defined$config_data->{global}{$attribute_name};$result->{$attribute_name}=$config_data->{$command_name}{$attribute_name}if defined$config_data->{$command_name}{$attribute_name}}return ($result,$errors)};1;
MOOSEX_APP_PLUGIN_CONFIG_META_CLASS

$fatpacked{"MooseX/App/Plugin/ConfigHome.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_CONFIGHOME';
  package MooseX::App::Plugin::ConfigHome;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;with qw(MooseX::App::Plugin::Config);sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Config::Meta::Class','MooseX::App::Plugin::ConfigHome::Meta::Class' ],}}1;
MOOSEX_APP_PLUGIN_CONFIGHOME

$fatpacked{"MooseX/App/Plugin/ConfigHome/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_CONFIGHOME_META_CLASS';
  package MooseX::App::Plugin::ConfigHome::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use File::HomeDir qw();around 'proto_config'=>sub {my$orig=shift;my ($self,$command_class,$result,$errors)=@_;unless (defined$result->{config}){my$home_dir=Path::Class::Dir->new(File::HomeDir->my_home);my$data_dir=$home_dir->subdir('.'.$self->app_base);for my$extension (Config::Any->extensions){my$check_file=$data_dir->file('config.'.$extension);if (-e $check_file){$result->{config}=$check_file;last}}}return$self->$orig($command_class,$result,$errors)};1;
MOOSEX_APP_PLUGIN_CONFIGHOME_META_CLASS

$fatpacked{"MooseX/App/Plugin/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_ENV';
  package MooseX::App::Plugin::Env;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;warn "MooseX::App Env plugin is deprecated. Functionality moved to core";return}1;
MOOSEX_APP_PLUGIN_ENV

$fatpacked{"MooseX/App/Plugin/Fuzzy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_FUZZY';
  package MooseX::App::Plugin::Fuzzy;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;warn "MooseX::App Fuzzy plugin is deprecated. Use Typo instead";return}1;
MOOSEX_APP_PLUGIN_FUZZY

$fatpacked{"MooseX/App/Plugin/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_MAN';
  package MooseX::App::Plugin::Man;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Man::Meta::Class'],}}around 'initialize_command_class'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);if (blessed$return && $return->isa('MooseX::App::Plugin::Man::Command')){return$return->man($self)}return$return};1;
MOOSEX_APP_PLUGIN_MAN

$fatpacked{"MooseX/App/Plugin/Man/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_MAN_COMMAND';
  package MooseX::App::Plugin::Man::Command;use 5.010;use utf8;use namespace::autoclean;use Moose;use MooseX::App::Command;use Pod::Perldoc;command_short_description q(Full manpage);has 'command'=>(is=>'ro',isa=>'Str',predicate=>'has_command',documentation=>q[Command],traits=>['AppOption'],cmd_type=>'parameter',cmd_position=>1,);sub man {my ($self,$app)=@_;my$meta=$app->meta;my$class;if ($self->has_command){my$return=$meta->command_find($self->command);if (blessed$return && $return->isa('MooseX::App::Message::Block')){return MooseX::App::Message::Envelope->new($return,$meta->command_usage_command($self->meta),)}$class=$meta->command_get($return)}else {$class=$meta->name}Class::Load::load_class($class);my$filename=MooseX::App::Utils::package_to_filename($class);exec('perldoc',$filename)}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_PLUGIN_MAN_COMMAND

$fatpacked{"MooseX/App/Plugin/Man/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_MAN_META_CLASS';
  package MooseX::App::Plugin::Man::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use MooseX::App::Plugin::Man::Command;around '_build_app_commands'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);$return->{man}||='MooseX::App::Plugin::Man::Command';return$return};1;
MOOSEX_APP_PLUGIN_MAN_META_CLASS

$fatpacked{"MooseX/App/Plugin/Term.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_TERM';
  package MooseX::App::Plugin::Term;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Term::Meta::Class'],attribute=>['MooseX::App::Plugin::Term::Meta::Attribute'],}}1;
MOOSEX_APP_PLUGIN_TERM

$fatpacked{"MooseX/App/Plugin/Term/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_TERM_META_ATTRIBUTE';
  package MooseX::App::Plugin::Term::Meta::Attribute;use utf8;use 5.010;use namespace::autoclean;use Moose::Role;no if $] >= 5.018000,warnings=>qw(experimental::smartmatch);use Term::ReadKey;has 'cmd_term'=>(is=>'rw',isa=>'Bool',default=>0,);has 'cmd_term_label'=>(is=>'rw',isa=>'Str',predicate=>'has_cmd_term_label',);sub cmd_term_label_full {my ($self)=@_;my$label=$self->cmd_term_label_name;my@tags;if ($self->is_required){push(@tags,'Required')}else {push(@tags,'Optional')}if ($self->has_type_constraint){my$type_constraint=$self->type_constraint;if ($type_constraint->is_a_type_of('Bool')){push(@tags,'Y/N')}else {push(@tags,$self->cmd_type_constraint_description($type_constraint))}}if (scalar@tags){$label .= ' ('.join(', ',@tags).')'}return$label}sub cmd_term_label_name {my ($self)=@_;my$label;if ($self->has_cmd_term_label){return$self->cmd_term_label}elsif ($self->has_documentation){return$self->documentation}else {return$self->name}}sub cmd_term_read {my ($self)=@_;if ($self->has_type_constraint && $self->type_constraint->is_a_type_of('Bool')){return$self->cmd_term_read_bool()}else {return$self->cmd_term_read_string()}}sub cmd_term_read_string {my ($self)=@_;my$label=$self->cmd_term_label_full;my$return;binmode STDIN,':encoding(UTF-8)';ReadMode 4;TRY_STRING: while (1){print "\n" if defined$return && $return !~ /^\s*$/;$return='';if (defined$Term::ANSIColor::VERSION){say Term::ANSIColor::color('white bold').$label.' :'.Term::ANSIColor::color('reset')}else {say$label.": "}KEY_STRING: while (1){1 while defined ReadKey -1;my$key=ReadKey 0;given (ord($key)){when (10){print "\n";if ($return =~ m/^\s*$/){if ($self->is_required){next TRY_STRING}else {$return=undef;last TRY_STRING}}my$error=$self->cmd_type_constraint_check($return);if ($error){if (defined$Term::ANSIColor::VERSION){say Term::ANSIColor::color('bright_red bold').$error.Term::ANSIColor::color('reset')}else {say$error}next TRY_STRING}else {last TRY_STRING}}when (3){print "\n" if$return !~ /^\s*$/;ReadMode 0;kill INT=>$$}when (27){next TRY_STRING}when (127){chop($return);print "\b \b"}default {if ($_ <= 31){next KEY_STRING}$return .= $key;print$key}}}}ReadMode 0;return$return}sub cmd_term_read_bool {my ($self)=@_;my$label=$self->cmd_term_label_full;my$return;ReadMode 4;TRY: while (1){1 while defined ReadKey -1;say "$label: ";my$key=ReadKey 0;if ($key =~ /^[yn]$/i){say uc($key);$return=uc($key)eq 'Y' ? 1:0;last}elsif (ord($key)==10 &&!$self->is_required){last}}ReadMode 0;return$return}around 'cmd_tags_list'=>sub {my$orig=shift;my ($self)=@_;my@tags=$self->$orig();push(@tags,'Term')if$self->can('cmd_term')&& $self->cmd_term;return@tags};{package Moose::Meta::Attribute::Custom::Trait::AppTerm;use strict;use warnings;sub register_implementation {return 'MooseX::App::Plugin::Term::Meta::Attribute'}}1;
MOOSEX_APP_PLUGIN_TERM_META_ATTRIBUTE

$fatpacked{"MooseX/App/Plugin/Term/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_TERM_META_CLASS';
  package MooseX::App::Plugin::Term::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use IO::Interactive qw(is_interactive);around 'command_check_attributes'=>sub {my ($orig,$self,$command_meta,$errors,$params)=@_;$command_meta ||=$self;if (scalar @{$errors}==0 && is_interactive()){my$prompt=1;for my$attribute ($self->command_usage_attributes($command_meta,'all')){if ($attribute->is_required &&!exists$params->{$attribute->name}&& (!$attribute->can('cmd_term')|| $attribute->cmd_term==0)){$prompt=0}}if ($prompt){for my$attribute ($self->command_usage_attributes($command_meta,'all')){next unless$attribute->can('cmd_term')&& $attribute->cmd_term;if (!defined$params->{$attribute->name}){my$return=$attribute->cmd_term_read();$params->{$attribute->name}=$return if defined$return}}}}return$self->$orig($command_meta,$errors,$params)};1;
MOOSEX_APP_PLUGIN_TERM_META_CLASS

$fatpacked{"MooseX/App/Plugin/Typo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_TYPO';
  package MooseX::App::Plugin::Typo;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Typo::Meta::Class'],}}1;
MOOSEX_APP_PLUGIN_TYPO

$fatpacked{"MooseX/App/Plugin/Typo/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_TYPO_META_CLASS';
  package MooseX::App::Plugin::Typo::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use Text::WagnerFischer qw(distance);around 'command_candidates'=>sub {my ($orig,$self,$command)=@_;my$lc_command=lc($command);my$commands=$self->app_commands;my@candidates;my$candidate_length=length($command);for my$command_name (keys %$commands){my$candidate_substr=substr($command_name,0,$candidate_length+1);if ($lc_command eq $command_name){return$command_name}elsif ($lc_command eq $candidate_substr || distance($lc_command,$candidate_substr)<= 1){push(@candidates,$command_name)}}return [sort@candidates ]};1;
MOOSEX_APP_PLUGIN_TYPO_META_CLASS

$fatpacked{"MooseX/App/Plugin/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_VERSION';
  package MooseX::App::Plugin::Version;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub plugin_metaroles {my ($self,$class)=@_;return {class=>['MooseX::App::Plugin::Version::Meta::Class'],}}around 'initialize_command_class'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);if (blessed$return && $return->isa('MooseX::App::Plugin::Version::Command')){return$return->version($self)}return$return};1;
MOOSEX_APP_PLUGIN_VERSION

$fatpacked{"MooseX/App/Plugin/Version/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_VERSION_COMMAND';
  package MooseX::App::Plugin::Version::Command;use 5.010;use utf8;use namespace::autoclean;use Moose;use MooseX::App::Command;command_short_description q(Print the current version);sub version {my ($self,$app)=@_;my$version='';$version .= $app->meta->app_base.' version '.$app->VERSION."\n";$version .= "MooseX::App version ".$MooseX::App::VERSION."\n";$version .= "Perl version ".sprintf("%vd",$^V);my$message_class=$app->meta->app_messageclass;my@parts=($message_class->new({header=>'VERSION',body=>MooseX::App::Utils::format_text($version)}));my%pod_raw=MooseX::App::Utils::parse_pod($app->meta->name);for my$part ('COPYRIGHT','LICENSE','COPYRIGHT AND LICENSE','AUTHOR','AUTHORS'){if (defined$pod_raw{$part}){push(@parts,$message_class->new({header=>$part,body=>MooseX::App::Utils::format_text($pod_raw{$part}),}))}}return MooseX::App::Message::Envelope->new(@parts)}__PACKAGE__->meta->make_immutable;1;
MOOSEX_APP_PLUGIN_VERSION_COMMAND

$fatpacked{"MooseX/App/Plugin/Version/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_PLUGIN_VERSION_META_CLASS';
  package MooseX::App::Plugin::Version::Meta::Class;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;use MooseX::App::Plugin::Version::Command;around '_build_app_commands'=>sub {my$orig=shift;my$self=shift;my$return=$self->$orig(@_);$return->{version}||='MooseX::App::Plugin::Version::Command';return$return};1;
MOOSEX_APP_PLUGIN_VERSION_META_CLASS

$fatpacked{"MooseX/App/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_ROLE';
  package MooseX::App::Role;use 5.010;use utf8;use strict;use warnings;use Moose::Role ();use MooseX::App::Exporter qw(option parameter);use Moose::Exporter;Moose::Exporter->setup_import_methods(also=>'Moose::Role',with_meta=>[qw(option parameter)],);sub init_meta {my (undef,%args)=@_;my$meta=Moose::Role->init_meta(%args);Moose::Util::MetaRole::apply_metaroles(for=>$meta,role_metaroles=>{applied_attribute=>['MooseX::App::Meta::Role::Attribute::Option'],},);return$meta}1;
MOOSEX_APP_ROLE

$fatpacked{"MooseX/App/Role/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_ROLE_BASE';
  package MooseX::App::Role::Base;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;sub initialize_command_class {my ($class,$command_class,%args)=@_;my$meta=$class->meta;Moose->throw_error('initialize_command_class is a class method')if blessed($class);my ($ok,$error)=Class::Load::try_load_class($command_class);unless ($ok){Moose->throw_error($error)}my$command_meta=$command_class->meta || $meta;my$parsed_argv=MooseX::App::ParsedArgv->instance();$parsed_argv->hints($meta->command_parser_hints($command_meta));my ($proto_result,$proto_errors)=$meta->command_proto($command_meta);return unless defined$proto_result;my@errors=@{$proto_errors};if ($proto_result->{help_flag}){return MooseX::App::Message::Envelope->new($meta->command_usage_command($command_class->meta),)}my ($result,$errors)=$meta->command_args($command_meta);push(@errors,@{$errors});my%params;if ($meta->app_prefer_commandline){%params=(%args,%{$proto_result},%{$result},)}else {%params=(%{$proto_result},%{$result},%args,)}$meta->command_check_attributes($command_meta,\@errors,\%params);if (scalar@errors){return MooseX::App::Message::Envelope->new(@errors,$meta->command_usage_command($command_meta),)}my$command_object=$command_class->new(%params,extra_argv=>[$parsed_argv->extra ],);if (scalar@errors){return MooseX::App::Message::Envelope->new(@errors,$meta->command_usage_command($command_meta),)}return$command_object}1;
MOOSEX_APP_ROLE_BASE

$fatpacked{"MooseX/App/Role/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_ROLE_COMMON';
  package MooseX::App::Role::Common;use 5.010;use utf8;use namespace::autoclean;use Moose::Role;has extra_argv=>(is=>'rw',isa=>'ArrayRef',);has 'help_flag'=>(is=>'ro',isa=>'Bool',traits=>['AppOption'],cmd_flag=>'help',cmd_aliases=>[qw(h usage ?) ],cmd_type=>'proto',cmd_position=>99999,documentation=>'Prints this usage information.',);1;
MOOSEX_APP_ROLE_COMMON

$fatpacked{"MooseX/App/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_SIMPLE';
  package MooseX::App::Simple;use 5.010;use utf8;use strict;use warnings;our$AUTHORITY='cpan:MAROS';our$VERSION=1.27;use Moose::Exporter;use MooseX::App::Exporter qw(app_usage app_description app_base app_fuzzy app_strict app_prefer_commandline option parameter command_short_description command_long_description command_usage command_strict);use MooseX::App::Meta::Role::Attribute::Option;use MooseX::App::Message::Envelope;use Scalar::Util qw(blessed);my ($IMPORT,$UNIMPORT,$INIT_META)=Moose::Exporter->build_import_methods(with_meta=>[qw(app_usage app_description app_base app_fuzzy app_strict option parameter command_short_description command_long_description command_usage command_strict) ],also=>['Moose' ],as_is=>['new_with_options' ],install=>['unimport','init_meta' ],);sub import {my ($class,@plugins)=@_;my ($caller_class)=caller();MooseX::App::Exporter->process_plugins($caller_class,@plugins);return$class->$IMPORT({into=>$caller_class })}sub init_meta {my ($class,%args)=@_;my$for_class=$args{for_class};$args{roles}=['MooseX::App::Role::Base' ];$args{metaroles}={class=>['MooseX::App::Meta::Role::Class::Base','MooseX::App::Meta::Role::Class::Simple','MooseX::App::Meta::Role::Class::Documentation' ],attribute=>['MooseX::App::Meta::Role::Attribute::Option' ],};my$meta=MooseX::App::Exporter->process_init_meta(%args);$for_class->meta->app_commands({'self'=>$for_class });return$meta}sub new_with_options {my ($class,@args)=@_;Moose->throw_error('new_with_options is a class method')if!defined$class || blessed($class);my%args;if (scalar@args==1 && ref($args[0])eq 'HASH'){%args=%{$args[0]}}elsif (scalar@args % 2==0){%args=@args}else {Moose->throw_error('new_with_command got invalid extra arguments')}my$parsed_argv=MooseX::App::ParsedArgv->instance();return$class->initialize_command_class($class,%args)}no Moose;1;
MOOSEX_APP_SIMPLE

$fatpacked{"MooseX/App/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_APP_UTILS';
  package MooseX::App::Utils;use 5.010;use utf8;use strict;use warnings;use List::Util qw(max);our$SCREEN_WIDTH=78;our$INDENT=4;use Moose::Util::TypeConstraints;subtype 'MooseX::App::Types::List' =>as 'ArrayRef';coerce 'MooseX::App::Types::List' =>from 'Str' =>via {[$_]};subtype 'MooseX::App::Types::CmdTypes' =>as enum([qw(proto option parameter)]);subtype 'MooseX::App::Types::MessageString' =>as 'Str';coerce 'MooseX::App::Types::MessageString' =>from 'ArrayRef' =>via {sprintf(@{$_})};subtype 'MooseX::App::Types::Env' =>as 'Str' =>where {m/^[A-Z0-9_]+$/};no Moose::Util::TypeConstraints;no if $] >= 5.018000,warnings=>qw/experimental::smartmatch/;sub class_to_command {my ($class)=@_;return unless defined$class;my@parts=split(/[_\s]+|\b|(?<![A-Z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])/,$class);return lc(join('_',@parts))}sub format_text {my ($text)=@_;my@lines;for my$line (split(/\n/,$text)){push(@lines,split_string($SCREEN_WIDTH-$INDENT,$line))}return join("\n",map {(' ' x $INDENT).$_}@lines)}sub format_list {my (@list)=@_;my$max_length=max(map {length($_->[0])}@list);my$description_length=$SCREEN_WIDTH - $max_length - 7;my$prefix_length=$max_length + $INDENT + 2;my@return;for my$command (@list){my$description=$command->[1]// '';my@lines=split_string($description_length,$description);push (@return,(' 'x$INDENT).sprintf('%-*s  %s',$max_length,$command->[0],shift(@lines)));while (my$line=shift (@lines)){push(@return,' 'x $prefix_length.$line)}}return join("\n",@return)}sub split_string {my ($maxlength,$string)=@_;return unless defined$string;return$string if length$string <= $maxlength;my (@lines,$line);$line='';for my$word (split(m/(\p{IsPunct}|\p{IsSpace})/,$string)){if (length($line.$word)<= $maxlength){$line .= $word}else {push(@lines,$line)if ($line ne '');$line='';if (length($word)> $maxlength){my (@parts)=grep {$_ ne ''}split(/(.{$maxlength})/,$word);my$lastline=pop(@parts);push(@lines,@parts);if (defined$lastline && $lastline ne ''){$line=$lastline}}else {$line=$word}}}push(@lines,$line)if ($line ne '');@lines=map {m/^\s*(.+?)\s*$/ ? $1 : $_}@lines;return@lines}sub package_to_filename {my ($package)=@_;my$package_filename=$package;$package_filename =~ s/::/\//g;$package_filename .= '.pm';my$package_filepath;if (defined$INC{$package_filename}){$package_filepath=$INC{$package_filename};$package_filepath =~ s/\/{2,}/\//g}return unless defined$package_filepath && -e $package_filepath;return$package_filepath}sub parse_pod {my ($package)=@_;my$package_filepath=package_to_filename($package);return unless$package_filepath;my$document=Pod::Elemental->read_file($package_filepath);Pod::Elemental::Transformer::Pod5->new->transform_node($document);my$nester_head=Pod::Elemental::Transformer::Nester->new({top_selector=>Pod::Elemental::Selectors::s_command('head1'),content_selectors=>[Pod::Elemental::Selectors::s_command([qw(head2 head3 head4 over back item) ]),Pod::Elemental::Selectors::s_flat()],});$document=$nester_head->transform_node($document);my%pod;for my$element (@{$document->children}){if ($element->isa('Pod::Elemental::Element::Pod5::Nonpod')){if ($element->content =~ m/^\s*#+\s*ABSTRACT:\s*(.+)$/m){$pod{ABSTRACT}||=$1}}elsif ($element->isa('Pod::Elemental::Element::Nested')&& $element->command eq 'head1'){if ($element->content eq 'NAME'){my$content=_pod_node_to_text($element->children);next unless defined$content;$content =~ s/^$package(\s-)?\s//;chomp($content);$pod{NAME}=$content}else {my$content=_pod_node_to_text($element->children);next unless defined$content;chomp($content);$pod{uc($element->content)}=$content}}}return%pod}sub _pod_node_to_text {my ($node,$indent)=@_;unless (defined$indent){my$indent_init=0;$indent=\$indent_init}my (@lines);if (ref$node eq 'ARRAY'){for my$element (@$node){push (@lines,_pod_node_to_text($element,$indent))}}else {given (ref($node)){when ('Pod::Elemental::Element::Pod5::Ordinary'){my$content=$node->content;return if$content =~ m/^=cut/;$content =~ s/\n/ /g;$content =~ s/\s+/ /g;push (@lines,$content."\n")}when ('Pod::Elemental::Element::Pod5::Verbatim'){push (@lines,$node->content."\n")}when ('Pod::Elemental::Element::Pod5::Command'){given ($node->command){when ('over'){${$indent}++}when ('item'){push (@lines,('  ' x ($$indent-1)).$node->content)}when ('back'){push (@lines,"\n");${$indent}--}}}}}return unless scalar@lines;my$return=join ("\n",grep {defined $_}@lines);$return =~ s/\n\n\n+/\n\n/g;$return =~ s/I<([^>]+)>/_$1_/g;$return =~ s/B<([^>]+)>/*$1*/g;$return =~ s/[LCBI]<([^>]+)>/$1/g;$return =~ s/[LCBI]<([^>]+)>/$1/g;return$return}1;
MOOSEX_APP_UTILS

$fatpacked{"MooseX/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES';
  package MooseX::Types;$MooseX::Types::VERSION='0.45';use Moose;use Moose::Util::TypeConstraints;use MooseX::Types::TypeDecorator;use MooseX::Types::Base ();use MooseX::Types::Util qw(filter_tags);use MooseX::Types::UndefinedType;use MooseX::Types::CheckedUtilExports ();use Carp::Clan qw(^MooseX::Types);use Sub::Name;use Scalar::Util 'reftype';use namespace::autoclean;use 5.008;my$UndefMsg=q{Action for type '%s' not yet defined in library '%s'};sub import {my ($class,%args)=@_;my$caller=caller;strict->import;warnings->import;{no strict 'refs';unshift @{$caller .'::ISA'},'MooseX::Types::Base'}if (my@orig_declare=@{$args{-declare }|| []}){my ($tags,$declare)=filter_tags@orig_declare;my@to_export;for my$type (@$declare){croak "Cannot create a type containing '::' ($type) at the moment" if$type =~ /::/;$caller->add_type($type);push@to_export,$type}$caller->import({-full=>1,-into=>$caller,installer=>sub {my ($arg,$to_export)=@_;my$into=$arg->{into};for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];next if ref$as;my$sub=sub {$code->(@_)};my$subtype=blessed$code;bless$sub,$subtype if$subtype;$to_export->[$i + 1 ]=Sub::Name::subname(join(q{::},$into,$as),$sub,)}Sub::Exporter::default_installer($arg,$to_export)},},@to_export)}Moose::Util::TypeConstraints->import({into=>$caller });MooseX::Types::CheckedUtilExports->import({into=>$caller });1}sub type_export_generator {my ($class,$type,$name)=@_;return subname "__TYPE__::$name"=>sub {my$type_constraint=$class->create_base_type_constraint($name);if(defined(my$params=shift @_)){if(reftype$params eq 'ARRAY'){$type_constraint=$class->create_arged_type_constraint($name,@$params)}elsif(!defined$type_constraint){croak "Syntax error in type definition (did you forget a comma" ." after $type?)"}else {croak "Argument must be an ArrayRef to create a parameterized " ."type, Eg.: ${type}[Int]. Got: ".ref($params)."."}}$type_constraint=defined($type_constraint)? $type_constraint : MooseX::Types::UndefinedType->new($name);my$type_decorator=$class->create_type_decorator($type_constraint);if(@_){return ($type_decorator,@_)}else {return$type_decorator}}}sub create_arged_type_constraint {my ($class,$name,@args)=@_;my$type_constraint=Moose::Util::TypeConstraints::find_or_create_type_constraint("$name");my$parameterized=$type_constraint->parameterize(@args);return$parameterized}sub create_base_type_constraint {my ($class,$name)=@_;return find_type_constraint($name)}sub create_type_decorator {my ($class,$type_constraint)=@_;return MooseX::Types::TypeDecorator->new($type_constraint)}sub coercion_export_generator {my ($class,$type,$full,$undef_msg)=@_;return sub {my ($value)=@_;my$tobj=find_type_constraint($full)or croak$undef_msg;my$return=$tobj->coerce($value);return unless$tobj->check($return);return$return}}sub check_export_generator {my ($class,$type,$full,$undef_msg)=@_;return sub {my ($value)=@_;my$tobj=find_type_constraint($full)or croak$undef_msg;return$tobj->check($value)}}
MOOSEX_TYPES

$fatpacked{"MooseX/Types/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_BASE';
  package MooseX::Types::Base;$MooseX::Types::Base::VERSION='0.45';use Moose;use Carp::Clan qw(^MooseX::Types);use MooseX::Types::Util qw(filter_tags);use Sub::Exporter qw(build_exporter);use Moose::Util::TypeConstraints;use namespace::autoclean;my$UndefMsg=q{Unable to find type '%s' in library '%s'};sub import {my ($class,@args)=@_;my$options=(@args and (ref($args[0])eq 'HASH'))? $args[0]: undef;my%ex_spec=%{$options || {}};delete@ex_spec{qw(-wrapper -into -full) };unless ($options){$options={foo=>23};unshift@args,$options}my@types=$class->type_names;my$wrapper=$options->{-wrapper }|| 'MooseX::Types';$args[0]->{into}=$options->{-into }if exists$options->{-into };my%ex_util;TYPE: for my$type_short (@types){my$type_full=$class->get_type($type_short)or croak "No fully qualified type name stored for '$type_short'";my$type_cons=find_type_constraint($type_full);my$undef_msg=sprintf($UndefMsg,$type_short,$class);push @{$ex_spec{exports}},$type_short,sub {bless$wrapper->type_export_generator($type_short,$type_full),'MooseX::Types::EXPORTED_TYPE_CONSTRAINT'};push @{$ex_spec{exports}},"is_${type_short}",sub {$wrapper->check_export_generator($type_short,$type_full,$undef_msg)};next TYPE unless$options->{-full }or ($type_cons and $type_cons->has_coercion);push @{$ex_spec{exports}},"to_${type_short}",sub {$wrapper->coercion_export_generator($type_short,$type_full,$undef_msg)};$ex_util{$type_short }{to}++}my$exporter=build_exporter \%ex_spec;$options->{into_level}++ unless$options->{into};my%was_requested=map {($_=>1)}grep {not ref}@args;my%add;EXPORT: for my$type (grep {exists$was_requested{$_ }}@types){$add{"is_$type" }++ unless$was_requested{"is_$type" };next EXPORT unless exists$ex_util{$type }{to};$add{"to_$type" }++ unless$was_requested{"to_$type" }}my@new_args=(@args,keys%add);return$class->$exporter(@new_args)}sub get_type {my ($class,$type)=@_;croak "Unknown type '$type' in library '$class'" unless$class->has_type($type);return$class->type_storage->{$type }}sub type_names {my ($class)=@_;return keys %{$class->type_storage}}sub add_type {my ($class,$type)=@_;$class->type_storage->{$type }="${class}::${type}"}sub has_type {my ($class,$type)=@_;return!!$class->type_storage->{$type }}sub type_storage {my ($class)=@_;{no strict 'refs';return \%{$class .'::__MOOSEX_TYPELIBRARY_STORAGE'}}}sub registered_class_types {my ($class)=@_;{no strict 'refs';return \%{$class .'::__MOOSEX_TYPELIBRARY_CLASS_TYPES'}}}sub register_class_type {my ($class,$type)=@_;croak "Not a class_type" unless$type->isa('Moose::Meta::TypeConstraint::Class');$class->registered_class_types->{$type->class}=$type}sub get_registered_class_type {my ($class,$name)=@_;$class->registered_class_types->{$name}}sub registered_role_types {my ($class)=@_;{no strict 'refs';return \%{$class .'::__MOOSEX_TYPELIBRARY_ROLE_TYPES'}}}sub register_role_type {my ($class,$type)=@_;croak "Not a role_type" unless$type->isa('Moose::Meta::TypeConstraint::Role');$class->registered_role_types->{$type->role}=$type}sub get_registered_role_type {my ($class,$name)=@_;$class->registered_role_types->{$name}}1;
MOOSEX_TYPES_BASE

$fatpacked{"MooseX/Types/CheckedUtilExports.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_CHECKEDUTILEXPORTS';
  package MooseX::Types::CheckedUtilExports;$MooseX::Types::CheckedUtilExports::VERSION='0.45';use strict;use warnings;use Moose::Util::TypeConstraints ();use Moose::Exporter;use Carp;use namespace::autoclean;my$StringFoundMsg=q{WARNING: String found where Type expected (did you use a => instead of a , ?)};my@exports=qw/type subtype maybe_type duck_type enum coerce from as/;for my$export (@exports){no strict 'refs';Sub::Install::install_sub({into=>__PACKAGE__,as=>$export,code=>sub {my$caller=shift;local$Carp::CarpLevel=$Carp::CarpLevel + 1;carp$StringFoundMsg unless ref($_[0])|| $_[0]=~ /\b::\b/ || $caller->get_registered_class_type($_[0])|| $caller->get_registered_role_type($_[0]);goto &{"Moose::Util::TypeConstraints::$export"}}})}Moose::Exporter->setup_import_methods(with_caller=>[@exports,'class_type','role_type' ]);sub class_type {my$caller=shift;$caller->register_class_type(Moose::Util::TypeConstraints::class_type(@_))}sub role_type ($;$) {my ($caller,$name,$opts)=@_;$caller->register_role_type(Moose::Util::TypeConstraints::role_type($name,$opts))}1;
MOOSEX_TYPES_CHECKEDUTILEXPORTS

$fatpacked{"MooseX/Types/Combine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_COMBINE';
  use strict;use warnings;package MooseX::Types::Combine;$MooseX::Types::Combine::VERSION='0.45';use Module::Runtime 'use_module';use namespace::autoclean;sub import {my ($class,@types)=@_;my$caller=caller;my%types=$class->_provided_types;if (grep {$_ eq ':all'}@types){$_->import({-into=>$caller },q{:all})for$class->provide_types_from;return}my%from;for my$type (@types){unless ($types{$type}){my@type_libs=$class->provide_types_from;die "$caller asked for a type ($type) which is not found in any of the" ." type libraries (@type_libs) combined by $class\n"}push @{$from{$types{$type}}},$type}$_->import({-into=>$caller },@{$from{$_ }})for keys%from}sub provide_types_from {my ($class,@libs)=@_;my$store=do {no strict 'refs';\@{"${class}::__MOOSEX_TYPELIBRARY_LIBRARIES"}};if (@libs){$class->_check_type_lib($_)for@libs;@$store=@libs;my%types=map {my$lib=$_;map +($_=>$lib),$lib->type_names}@libs;$class->_provided_types(%types)}@$store}sub _check_type_lib {my ($class,$lib)=@_;use_module($lib);die "Cannot use $lib in a combined type library, it does not provide any types" unless$lib->can('type_names')}sub _provided_types {my ($class,%types)=@_;my$types=do {no strict 'refs';\%{"${class}::__MOOSEX_TYPELIBRARY_TYPES"}};%$types=%types if keys%types;%$types}1;
MOOSEX_TYPES_COMBINE

$fatpacked{"MooseX/Types/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_MOOSE';
  use warnings;use strict;package MooseX::Types::Moose;$MooseX::Types::Moose::VERSION='0.45';use MooseX::Types;use Moose::Util::TypeConstraints ();use namespace::autoclean;my%BuiltIn_Storage =map {($_)x 2}Moose::Util::TypeConstraints->list_all_builtin_type_constraints;sub type_storage {\%BuiltIn_Storage}1;
MOOSEX_TYPES_MOOSE

$fatpacked{"MooseX/Types/Path/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_PATH_CLASS';
  package MooseX::Types::Path::Class;{$MooseX::Types::Path::Class::VERSION='0.06'}use warnings FATAL=>'all';use strict;use Path::Class ();use MooseX::Types -declare=>[qw(Dir File)];use MooseX::Types::Moose qw(Str ArrayRef);class_type('Path::Class::Dir');class_type('Path::Class::File');subtype Dir,as 'Path::Class::Dir';subtype File,as 'Path::Class::File';for my$type ('Path::Class::Dir',Dir){coerce$type,from Str,via {Path::Class::Dir->new($_)},from ArrayRef,via {Path::Class::Dir->new(@$_)}}for my$type ('Path::Class::File',File){coerce$type,from Str,via {Path::Class::File->new($_)},from ArrayRef,via {Path::Class::File->new(@$_)}}eval {require MooseX::Getopt};if (!$@){MooseX::Getopt::OptionTypeMap->add_option_type_to_map($_,'=s',)for ('Path::Class::Dir','Path::Class::File',Dir,File,)}1;
MOOSEX_TYPES_PATH_CLASS

$fatpacked{"MooseX/Types/TypeDecorator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_TYPEDECORATOR';
  use strict;use warnings;package MooseX::Types::TypeDecorator;$MooseX::Types::TypeDecorator::VERSION='0.45';use Carp::Clan '^MooseX::Types';use Moose::Util::TypeConstraints ();use Moose::Meta::TypeConstraint::Union;use Scalar::Util qw(blessed);use namespace::autoclean 0.16;use overload('0+'=>sub {my$self=shift @_;my$tc=$self->{__type_constraint};return 0+$tc},'=='=>sub {0+$_[0]==0+$_[1]},'""'=>sub {my$self=shift @_;if(blessed$self){return$self->__type_constraint->name}else {return "$self"}},bool=>sub {1},'|'=>sub {my@args=@_[0,1];my@tc=grep {blessed $_}map {blessed $_ ? $_ : Moose::Util::TypeConstraints::find_or_parse_type_constraint($_)|| __PACKAGE__->_throw_error("$_ is not a type constraint")}@args;(scalar@tc==scalar@args)|| __PACKAGE__->_throw_error("one of your type constraints is bad.  Passed: ".join(', ',@args)." Got: ".join(', ',@tc));(scalar@tc >= 2)|| __PACKAGE__->_throw_error("You must pass in at least 2 type names to make a union");my$union=Moose::Meta::TypeConstraint::Union->new(type_constraints=>\@tc);return Moose::Util::TypeConstraints::register_type_constraint($union)},fallback=>1,);sub new {my$proto=shift;if (ref($proto)){return$proto->_try_delegate('new',@_)}my$class=$proto;if(my$arg=shift @_){if(blessed$arg && $arg->isa('Moose::Meta::TypeConstraint')){return bless {'__type_constraint'=>$arg},$class}elsif(blessed$arg && $arg->isa('MooseX::Types::UndefinedType')){return bless {'__type_constraint'=>$arg},$class}elsif(blessed$arg){__PACKAGE__->_throw_error("Argument must be ->isa('Moose::Meta::TypeConstraint') or ->isa('MooseX::Types::UndefinedType'), not ".blessed$arg)}else {__PACKAGE__->_throw_error("Argument cannot be '$arg'")}}else {__PACKAGE__->_throw_error("This method [new] requires a single argument.")}}sub __type_constraint {my$self=shift @_;if(blessed$self){if(defined(my$tc=shift @_)){$self->{__type_constraint}=$tc}return$self->{__type_constraint}}else {__PACKAGE__->_throw_error('cannot call __type_constraint as a class method')}}sub isa {my$self=shift;return blessed$self ? $self->__type_constraint->isa(@_)|| $self->_try_delegate('isa',@_): $self->SUPER::isa(@_)}sub can {my$self=shift;return blessed$self ? $self->_try_delegate('can',@_): $self->SUPER::can(@_)}sub _throw_error {shift;require Moose;unshift @_,'Moose';goto&Moose::throw_error}sub DESTROY {return}sub AUTOLOAD {my ($self,@args)=@_;my ($method)=(our$AUTOLOAD =~ /([^:]+)$/);$self->_try_delegate($method,@args)}sub _try_delegate {my ($self,$method,@args)=@_;my$tc=$self->__type_constraint;my$class;if ($tc->can('is_subtype_of')){my$search_tc=$tc;while (1){if ($search_tc->isa('Moose::Meta::TypeConstraint::Class')){$class=$search_tc->class;last}$search_tc=$search_tc->parent;last unless$search_tc && $search_tc->is_subtype_of('Object')}}my$inv=do {if ($method eq 'new'){die "new called on type decorator for non-class-type ".$tc->name unless$class;die "new called on class type decorator ".$tc->name."\n" ." for class ${class}\n" ." which does not provide a new method - did you forget to load it?" unless$class->can('new');$class}elsif ($class &&!$tc->can($method)){$class}else {$tc}};$inv->$method(@args)}1;
MOOSEX_TYPES_TYPEDECORATOR

$fatpacked{"MooseX/Types/UndefinedType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_UNDEFINEDTYPE';
  use warnings;use strict;package MooseX::Types::UndefinedType;$MooseX::Types::UndefinedType::VERSION='0.45';use Moose::Util::TypeConstraints ();use Carp::Clan '^MooseX::Types';use namespace::autoclean 0.16;use overload '""'=>sub {shift->name},fallback=>1;sub new {return bless {name=>$_[1]},$_[0]}sub name {return $_[0]->{name}}sub __autovivify {my ($self)=@_;if(my$tc=$self->{instance}){return$tc}elsif(my$new_tc=Moose::Util::TypeConstraints::find_type_constraint($self->name)){$self->{instance}=$new_tc;return$new_tc}else {return}}sub can_be_inlined {my$self=shift;if(my$type_constraint=$self->__autovivify){return$type_constraint->can_be_inlined}else {return}}sub AUTOLOAD {my ($self,@args)=@_;my ($method)=our$AUTOLOAD =~ /([^:]+)$/;if(my$type_constraint=$self->__autovivify){return$type_constraint->$method(@args)}else {croak "Method '$method' is not supported for " .$self->name}}sub DESTROY {return}1;
MOOSEX_TYPES_UNDEFINEDTYPE

$fatpacked{"MooseX/Types/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_UTIL';
  use warnings;use strict;package MooseX::Types::Util;$MooseX::Types::Util::VERSION='0.45';use Scalar::Util 'blessed';use base 'Exporter';use namespace::autoclean;our@EXPORT_OK=qw(filter_tags has_available_type_export);sub filter_tags {my (@list)=@_;my (%tags,@other);for (@list){if (/^:(.*)$/){$tags{$1 }++;next}push@other,$_}return \%tags,\@other}sub has_available_type_export {my ($package,$name)=@_;my$sub=$package->can($name)or return undef;return undef unless blessed$sub && $sub->isa('MooseX::Types::EXPORTED_TYPE_CONSTRAINT');return$sub->()}1;
MOOSEX_TYPES_UTIL

$fatpacked{"MooseX/Types/Wrapper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOSEX_TYPES_WRAPPER';
  package MooseX::Types::Wrapper;$MooseX::Types::Wrapper::VERSION='0.45';use Moose;use Carp::Clan qw(^MooseX::Types);use Module::Runtime 'use_module';use namespace::autoclean;extends 'MooseX::Types';sub import {my ($class,@args)=@_;my%libraries=@args==1 ? (Moose=>$args[0]): @args;for my$l (keys%libraries){croak qq($class expects an array reference as import spec) unless ref$libraries{$l }eq 'ARRAY';my$library_class =($l eq 'Moose' ? 'MooseX::Types::Moose' : $l);use_module($library_class);$library_class->import({-into=>scalar(caller),-wrapper=>$class,},@{$libraries{$l }})}return 1}1;
MOOSEX_TYPES_WRAPPER

$fatpacked{"Package/DeprecationManager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_DEPRECATIONMANAGER';
  package Package::DeprecationManager;{$Package::DeprecationManager::VERSION='0.13'}use strict;use warnings;use Carp qw(croak);use List::MoreUtils qw(any);use Params::Util qw(_HASH0);use Sub::Install;sub import {shift;my%args=@_;croak 'You must provide a hash reference -deprecations parameter when importing Package::DeprecationManager' unless$args{-deprecations}&& _HASH0($args{-deprecations});my%registry;my$import=_build_import(\%registry);my$warn=_build_warn(\%registry,$args{-deprecations},$args{-ignore});my$caller=caller();Sub::Install::install_sub({code=>$import,into=>$caller,as=>'import',});Sub::Install::install_sub({code=>$warn,into=>$caller,as=>'deprecated',});return}sub _build_import {my$registry=shift;return sub {my$class=shift;my%args=@_;$args{-api_version}||=delete$args{-compatible};$registry->{caller()}=$args{-api_version}if$args{-api_version};return}}sub _build_warn {my$registry=shift;my$deprecated_at=shift;my$ignore=shift;my%ignore=map {$_=>1}grep {!ref}@{$ignore || []};my@ignore_res=grep {ref}@{$ignore || []};my%warned;return sub {my%args=@_ < 2 ? (message=>shift): @_;my ($package,undef,undef,$sub)=caller(1);my$skipped=1;if (@ignore_res || keys%ignore){while (defined$package && ($ignore{$package}|| any {$package =~ $_}@ignore_res)){$package=caller($skipped++)}}$package='unknown package' unless defined$package;unless (defined$args{feature}){$args{feature}=$sub}my$compat_version=$registry->{$package};my$deprecated_at=$deprecated_at->{$args{feature}};return if defined$compat_version && defined$deprecated_at && $compat_version lt $deprecated_at;my$msg;if (defined$args{message}){$msg=$args{message}}else {$msg="$args{feature} has been deprecated";$msg .= " since version $deprecated_at" if defined$deprecated_at}return if$warned{$package}{$args{feature}}{$msg};$warned{$package}{$args{feature}}{$msg}=1;local$Carp::CarpLevel=$Carp::CarpLevel + $skipped;Carp::cluck($msg)}}1;
PACKAGE_DEPRECATIONMANAGER

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;BEGIN {$Package::Stash::AUTHORITY='cpan:DOY'}$Package::Stash::VERSION='0.37';use strict;use warnings;use 5.008001;our$IMPLEMENTATION;use Module::Implementation 0.06;BEGIN {local$ENV{PACKAGE_STASH_IMPLEMENTATION}=$IMPLEMENTATION if ($IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION});Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>[qw(new name namespace add_symbol remove_glob has_symbol get_symbol get_or_add_symbol remove_symbol list_all_symbols get_all_symbols)],)->();$IMPLEMENTATION=Module::Implementation::implementation_for(__PACKAGE__)}1;
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package Package::Stash::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Package::Stash',-conflicts=>{'Class::MOP'=>'1.08','MooseX::Method::Signatures'=>'0.36','MooseX::Role::WithOverloading'=>'0.08','namespace::clean'=>'0.18',},-also=>[qw(B Carp Dist::CheckConflicts Getopt::Long Module::Implementation Scalar::Util Symbol constant strict warnings) ],;1;
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;BEGIN {$Package::Stash::PP::AUTHORITY='cpan:DOY'}$Package::Stash::PP::VERSION='0.37';use strict;use warnings;use B;use Carp qw(confess);use Scalar::Util qw(blessed reftype weaken);use Symbol;use constant BROKEN_ISA_ASSIGNMENT=>($] < 5.012);use constant BROKEN_WEAK_STASH=>($] < 5.010);use constant BROKEN_SCALAR_INITIALIZATION=>($] < 5.010);use constant BROKEN_GLOB_ASSIGNMENT=>($] < 5.013004);use constant HAS_ISA_CACHE=>($] < 5.010);sub new {my$class=shift;my ($package)=@_;if (!defined($package)|| (ref($package)&& reftype($package)ne 'HASH')){confess "Package::Stash->new must be passed the name of the " ."package to access"}elsif (ref($package)&& reftype($package)eq 'HASH'){confess "The PP implementation of Package::Stash does not support " ."anonymous stashes before perl 5.14" if BROKEN_GLOB_ASSIGNMENT;return bless {'namespace'=>$package,},$class}elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/){return bless {'package'=>$package,},$class}else {confess "$package is not a module name"}}sub name {confess "Can't call name as a class method" unless blessed($_[0]);confess "Can't get the name of an anonymous package" unless defined($_[0]->{package});return $_[0]->{package}}sub namespace {confess "Can't call namespace as a class method" unless blessed($_[0]);if (BROKEN_WEAK_STASH){no strict 'refs';return \%{$_[0]->name .'::'}}else {return $_[0]->{namespace}if defined $_[0]->{namespace};{no strict 'refs';$_[0]->{namespace}=\%{$_[0]->name .'::'}}weaken($_[0]->{namespace});return $_[0]->{namespace}}}{my%SIGIL_MAP=('$'=>'SCALAR','@'=>'ARRAY','%'=>'HASH','&'=>'CODE',''=>'IO',);sub _deconstruct_variable_name {my ($variable)=@_;my@ret;if (ref($variable)eq 'HASH'){@ret=@{$variable}{qw[name sigil type]}}else {(defined$variable && length$variable)|| confess "You must pass a variable name";my$sigil=substr($variable,0,1,'');if (exists$SIGIL_MAP{$sigil}){@ret=($variable,$sigil,$SIGIL_MAP{$sigil})}else {@ret=("${sigil}${variable}",'',$SIGIL_MAP{''})}}($ret[0]!~ /::/)|| confess "Variable names may not contain ::";return@ret}}sub _valid_for_type {my ($value,$type)=@_;if ($type eq 'HASH' || $type eq 'ARRAY' || $type eq 'IO' || $type eq 'CODE'){return reftype($value)eq $type}else {my$ref=reftype($value);return!defined($ref)|| $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING'}}sub add_symbol {my ($self,$variable,$initial_value,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);if (@_ > 2){_valid_for_type($initial_value,$type)|| confess "$initial_value is not of type $type";if ($^P and $^P & 0x10 && $sigil eq '&'){my$filename=$opts{filename};my$first_line_num=$opts{first_line_num};(undef,$filename,$first_line_num)=caller if not defined$filename;my$last_line_num=$opts{last_line_num}|| ($first_line_num ||=0);$DB::sub{$self->name .'::' .$name}="$filename:$first_line_num-$last_line_num"}}if (BROKEN_GLOB_ASSIGNMENT){if (@_ > 2){no strict 'refs';no warnings 'redefine';*{$self->name .'::' .$name}=ref$initial_value ? $initial_value : \$initial_value}else {no strict 'refs';if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA'){*{$self->name .'::' .$name}}else {my$undef=_undef_ref_for_type($type);*{$self->name .'::' .$name}=$undef}}}else {my$namespace=$self->namespace;{local*__ANON__::=$namespace;no strict 'refs';no warnings 'void';no warnings 'once';*{"__ANON__::$name"}}if (@_ > 2){no warnings 'redefine';*{$namespace->{$name}}=ref$initial_value ? $initial_value : \$initial_value}else {return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';*{$namespace->{$name}}=_undef_ref_for_type($type)}}}sub _undef_ref_for_type {my ($type)=@_;if ($type eq 'ARRAY'){return []}elsif ($type eq 'HASH'){return {}}elsif ($type eq 'SCALAR'){return \undef}elsif ($type eq 'IO'){return Symbol::geniosym}elsif ($type eq 'CODE'){confess "Don't know how to vivify CODE variables"}else {confess "Unknown type $type in vivication"}}sub remove_glob {my ($self,$name)=@_;delete$self->namespace->{$name}}sub has_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;return unless exists$namespace->{$name};my$entry_ref=\$namespace->{$name};if (reftype($entry_ref)eq 'GLOB'){if ($type eq 'SCALAR'){if (BROKEN_SCALAR_INITIALIZATION){return defined ${*{$entry_ref}{$type}}}else {my$sv=B::svref_2object($entry_ref)->SV;return$sv->isa('B::SV')|| ($sv->isa('B::SPECIAL')&& $B::specialsv_name[$$sv]ne 'Nullsv')}}else {return defined *{$entry_ref}{$type}}}else {return$type eq 'CODE'}}sub get_symbol {my ($self,$variable,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;if (!exists$namespace->{$name}){if ($opts{vivify}){$self->add_symbol($variable)}else {return undef}}my$entry_ref=\$namespace->{$name};if (ref($entry_ref)eq 'GLOB'){return *{$entry_ref}{$type}}else {if ($type eq 'CODE'){if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})){no strict 'refs';return \&{$self->name .'::' .$name}}if (blessed($namespace)&& $namespace->isa('Package::Anon')){$namespace->bless(\(my$foo))->can($name)}else {confess "Don't know how to inflate a " .ref($entry_ref)." into a full coderef (perhaps you could use" ." Package::Anon instead of a bare stash?)"}return *{$namespace->{$name}}{CODE}}else {return undef}}}sub get_or_add_symbol {my$self=shift;$self->get_symbol(@_,vivify=>1)}sub remove_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my%desc=(SCALAR=>{sigil=>'$',type=>'SCALAR',name=>$name },ARRAY=>{sigil=>'@',type=>'ARRAY',name=>$name },HASH=>{sigil=>'%',type=>'HASH',name=>$name },CODE=>{sigil=>'&',type=>'CODE',name=>$name },IO=>{sigil=>'',type=>'IO',name=>$name },);confess "This should never ever ever happen" if!$desc{$type};my@types_to_store=grep {$type ne $_ && $self->has_symbol($desc{$_})}keys%desc;my%values=map {$_,$self->get_symbol($desc{$_})}@types_to_store;$values{SCALAR}=$self->get_symbol($desc{SCALAR})if!defined$values{SCALAR}&& $type ne 'SCALAR' && BROKEN_SCALAR_INITIALIZATION;$self->remove_glob($name);$self->add_symbol($desc{$_}=>$values{$_})for grep {defined$values{$_}}keys%values}sub list_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;if (HAS_ISA_CACHE){return grep {$_ ne '::ISA::CACHE::'}keys %{$namespace}unless defined$type_filter}else {return keys %{$namespace}unless defined$type_filter}if ($type_filter eq 'CODE'){return grep {ref(\$namespace->{$_})ne 'GLOB' || defined(*{$namespace->{$_}}{CODE})}keys %{$namespace}}elsif ($type_filter eq 'SCALAR'){return grep {!(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::')&& (BROKEN_SCALAR_INITIALIZATION ? (ref(\$namespace->{$_})eq 'GLOB' && defined(${*{$namespace->{$_}}{'SCALAR'}})): (do {my$entry=\$namespace->{$_};ref($entry)eq 'GLOB' && B::svref_2object($entry)->SV->isa('B::SV')}))}keys %{$namespace}}else {return grep {ref(\$namespace->{$_})eq 'GLOB' && defined(*{$namespace->{$_}}{$type_filter})}keys %{$namespace}}}sub get_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;return {%{$namespace}}unless defined$type_filter;return {map {$_=>$self->get_symbol({name=>$_,type=>$type_filter})}$self->list_all_symbols($type_filter)}}1;
PACKAGE_STASH_PP

$fatpacked{"Path/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS';
  use strict;package Path::Class;{$Path::Class::VERSION='0.35'}{no strict 'vars';@ISA=qw(Exporter);@EXPORT=qw(file dir);@EXPORT_OK=qw(file dir foreign_file foreign_dir tempdir)}use Exporter;use Path::Class::File;use Path::Class::Dir;use File::Temp ();sub file {Path::Class::File->new(@_)}sub dir {Path::Class::Dir ->new(@_)}sub foreign_file {Path::Class::File->new_foreign(@_)}sub foreign_dir {Path::Class::Dir ->new_foreign(@_)}sub tempdir {Path::Class::Dir->new(File::Temp::tempdir(@_))}1;
PATH_CLASS

$fatpacked{"Path/Class/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_DIR';
  use strict;package Path::Class::Dir;{$Path::Class::Dir::VERSION='0.35'}use Path::Class::File;use Carp();use parent qw(Path::Class::Entity);use IO::Dir ();use File::Path ();use File::Temp ();use Scalar::Util ();my$Updir=__PACKAGE__->_spec->updir;my$Curdir=__PACKAGE__->_spec->curdir;sub new {my$self=shift->SUPER::new();return if @_==1 &&!defined($_[0]);my$s=$self->_spec;my$first=(@_==0 ? $s->curdir : $_[0]eq '' ? (shift,$s->rootdir): shift());$self->{dirs}=[];if (Scalar::Util::blessed($first)&& $first->isa("Path::Class::Dir")){$self->{volume}=$first->{volume};push @{$self->{dirs}},@{$first->{dirs}}}else {($self->{volume},my$dirs)=$s->splitpath($s->canonpath("$first"),1);push @{$self->{dirs}},$dirs eq $s->rootdir ? "" : $s->splitdir($dirs)}push @{$self->{dirs}},map {Scalar::Util::blessed($_)&& $_->isa("Path::Class::Dir")? @{$_->{dirs}}: $s->splitdir($_)}@_;return$self}sub file_class {"Path::Class::File"}sub is_dir {1}sub as_foreign {my ($self,$type)=@_;my$foreign=do {local$self->{file_spec_class}=$self->_spec_class($type);$self->SUPER::new};$foreign->{volume}=$self->{volume};my ($u,$fu)=($self->_spec->updir,$foreign->_spec->updir);$foreign->{dirs}=[map {$_ eq $u ? $fu : $_}@{$self->{dirs}}];return$foreign}sub stringify {my$self=shift;my$s=$self->_spec;return$s->catpath($self->{volume},$s->catdir(@{$self->{dirs}}),'')}sub volume {shift()->{volume}}sub file {local$Path::Class::Foreign=$_[0]->{file_spec_class}if $_[0]->{file_spec_class};return $_[0]->file_class->new(@_)}sub basename {shift()->{dirs}[-1]}sub dir_list {my$self=shift;my$d=$self->{dirs};return @$d unless @_;my$offset=shift;if ($offset < 0){$offset=$#$d + $offset + 1}return wantarray ? @$d[$offset .. $#$d]: $d->[$offset]unless @_;my$length=shift;if ($length < 0){$length=$#$d + $length + 1 - $offset}return @$d[$offset .. $length + $offset - 1]}sub components {my$self=shift;return$self->dir_list(@_)}sub subdir {my$self=shift;return$self->new($self,@_)}sub parent {my$self=shift;my$dirs=$self->{dirs};my ($curdir,$updir)=($self->_spec->curdir,$self->_spec->updir);if ($self->is_absolute){my$parent=$self->new($self);pop @{$parent->{dirs}}if @$dirs > 1;return$parent}elsif ($self eq $curdir){return$self->new($updir)}elsif (!grep {$_ ne $updir}@$dirs){return$self->new($self,$updir)}elsif (@$dirs==1){return$self->new($curdir)}else {my$parent=$self->new($self);pop @{$parent->{dirs}};return$parent}}sub relative {my$self=shift;my$rel=$self->_spec->abs2rel($self->stringify,@_);return$self->new(length$rel ? $rel : $self->_spec->curdir)}sub open {IO::Dir->new(@_)}sub mkpath {File::Path::mkpath(shift()->stringify,@_)}sub rmtree {File::Path::rmtree(shift()->stringify,@_)}sub remove {rmdir(shift())}sub traverse {my$self=shift;my ($callback,@args)=@_;my@children=$self->children;return$self->$callback(sub {my@inner_args=@_;return map {$_->traverse($callback,@inner_args)}@children},@args)}sub traverse_if {my$self=shift;my ($callback,$condition,@args)=@_;my@children=grep {$condition->($_)}$self->children;return$self->$callback(sub {my@inner_args=@_;return map {$_->traverse_if($callback,$condition,@inner_args)}@children},@args)}sub recurse {my$self=shift;my%opts=(preorder=>1,depthfirst=>0,@_);my$callback=$opts{callback}or Carp::croak("Must provide a 'callback' parameter to recurse()");my@queue=($self);my$visit_entry;my$visit_dir=$opts{depthfirst}&& $opts{preorder}? sub {my$dir=shift;my$ret=$callback->($dir);unless(($ret||'')eq $self->PRUNE){unshift@queue,$dir->children}}: $opts{preorder}? sub {my$dir=shift;my$ret=$callback->($dir);unless(($ret||'')eq $self->PRUNE){push@queue,$dir->children}}: sub {my$dir=shift;$visit_entry->($_)foreach$dir->children;$callback->($dir)};$visit_entry=sub {my$entry=shift;if ($entry->is_dir){$visit_dir->($entry)}else {$callback->($entry)}};while (@queue){$visit_entry->(shift@queue)}}sub children {my ($self,%opts)=@_;my$dh=$self->open or Carp::croak("Can't open directory $self: $!");my@out;while (defined(my$entry=$dh->read)){next if!$opts{all}&& $self->_is_local_dot_dir($entry);next if ($opts{no_hidden}&& $entry =~ /^\./);push@out,$self->file($entry);$out[-1]=$self->subdir($entry)if -d $out[-1]}return@out}sub _is_local_dot_dir {my$self=shift;my$dir=shift;return ($dir eq $Updir or $dir eq $Curdir)}sub next {my$self=shift;unless ($self->{dh}){$self->{dh}=$self->open or Carp::croak("Can't open directory $self: $!")}my$next=$self->{dh}->read;unless (defined$next){delete$self->{dh};return undef}my$file=$self->file($next);$file=$self->subdir($next)if -d $file;return$file}sub subsumes {my ($self,$other)=@_;die "No second entity given to subsumes()" unless$other;$other=$self->new($other)unless UNIVERSAL::isa($other,"Path::Class::Entity");$other=$other->dir unless$other->is_dir;if ($self->is_absolute){$other=$other->absolute}elsif ($other->is_absolute){$self=$self->absolute}$self=$self->cleanup;$other=$other->cleanup;if ($self->volume){return 0 unless$other->volume eq $self->volume}return 1 if "@{$self->{dirs}}" eq "@{$self->new('')->{dirs}}";my$i=0;while ($i <= $#{$self->{dirs}}){return 0 if$i > $#{$other->{dirs}};return 0 if$self->{dirs}[$i]ne $other->{dirs}[$i];$i++}return 1}sub contains {my ($self,$other)=@_;return!!(-d $self and (-e $other or -l $other)and $self->subsumes($other))}sub tempfile {my$self=shift;return File::Temp::tempfile(@_,DIR=>$self->stringify)}1;
PATH_CLASS_DIR

$fatpacked{"Path/Class/Entity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_ENTITY';
  use strict;package Path::Class::Entity;{$Path::Class::Entity::VERSION='0.35'}use File::Spec 3.26;use File::stat ();use Cwd;use Carp();use overload (q[""]=>'stringify','bool'=>'boolify',fallback=>1,);sub new {my$from=shift;my ($class,$fs_class)=(ref($from)? (ref$from,$from->{file_spec_class}): ($from,$Path::Class::Foreign));return bless {file_spec_class=>$fs_class},$class}sub is_dir {0}sub _spec_class {my ($class,$type)=@_;die "Invalid system type '$type'" unless ($type)=$type =~ /^(\w+)$/;my$spec="File::Spec::$type";eval "require $spec; 1" or die $@;return$spec}sub new_foreign {my ($class,$type)=(shift,shift);local$Path::Class::Foreign=$class->_spec_class($type);return$class->new(@_)}sub _spec {(ref($_[0])&& $_[0]->{file_spec_class})|| 'File::Spec'}sub boolify {1}sub is_absolute {$_[0]->_spec->file_name_is_absolute($_[0]->stringify)}sub is_relative {!$_[0]->is_absolute}sub cleanup {my$self=shift;my$cleaned=$self->new($self->_spec->canonpath("$self"));%$self=%$cleaned;return$self}sub resolve {my$self=shift;Carp::croak($! ." $self")unless -e $self;my$cleaned=$self->new(scalar Cwd::realpath($self->stringify));$cleaned=$cleaned->relative if$self->is_relative;%$self=%$cleaned;return$self}sub absolute {my$self=shift;return$self if$self->is_absolute;return$self->new($self->_spec->rel2abs($self->stringify,@_))}sub relative {my$self=shift;return$self->new($self->_spec->abs2rel($self->stringify,@_))}sub stat {File::stat::stat("$_[0]")}sub lstat {File::stat::lstat("$_[0]")}sub PRUNE {return \&PRUNE}1;
PATH_CLASS_ENTITY

$fatpacked{"Path/Class/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_FILE';
  use strict;package Path::Class::File;{$Path::Class::File::VERSION='0.35'}use Path::Class::Dir;use parent qw(Path::Class::Entity);use Carp;use IO::File ();use Perl::OSType ();use File::Copy ();sub new {my$self=shift->SUPER::new;my$file=pop();my@dirs=@_;my ($volume,$dirs,$base)=$self->_spec->splitpath($file);if (length$dirs){push@dirs,$self->_spec->catpath($volume,$dirs,'')}$self->{dir}=@dirs ? $self->dir_class->new(@dirs): undef;$self->{file}=$base;return$self}sub dir_class {"Path::Class::Dir"}sub as_foreign {my ($self,$type)=@_;local$Path::Class::Foreign=$self->_spec_class($type);my$foreign=ref($self)->SUPER::new;$foreign->{dir}=$self->{dir}->as_foreign($type)if defined$self->{dir};$foreign->{file}=$self->{file};return$foreign}sub stringify {my$self=shift;return$self->{file}unless defined$self->{dir};return$self->_spec->catfile($self->{dir}->stringify,$self->{file})}sub dir {my$self=shift;return$self->{dir}if defined$self->{dir};return$self->dir_class->new($self->_spec->curdir)}BEGIN {*parent=\&dir}sub volume {my$self=shift;return '' unless defined$self->{dir};return$self->{dir}->volume}sub components {my$self=shift;die "Arguments are not currently supported by File->components()" if @_;return ($self->dir->components,$self->basename)}sub basename {shift->{file}}sub open {IO::File->new(@_)}sub openr {$_[0]->open('r')or croak "Can't read $_[0]: $!"}sub openw {$_[0]->open('w')or croak "Can't write to $_[0]: $!"}sub opena {$_[0]->open('a')or croak "Can't append to $_[0]: $!"}sub touch {my$self=shift;if (-e $self){utime undef,undef,$self}else {$self->openw}}sub slurp {my ($self,%args)=@_;my$iomode=$args{iomode}|| 'r';my$fh=$self->open($iomode)or croak "Can't read $self: $!";if (wantarray){my@data=<$fh>;chomp@data if$args{chomped}or $args{chomp};if (my$splitter=$args{split}){@data=map {[split$splitter,$_ ]}@data}return@data}croak "'split' argument can only be used in list context" if$args{split};if ($args{chomped}or $args{chomp}){chomp(my@data=<$fh>);return join '',@data}local $/;return <$fh>}sub spew {my$self=shift;my%args=splice(@_,0,@_-1);my$iomode=$args{iomode}|| 'w';my$fh=$self->open($iomode)or croak "Can't write to $self: $!";if (ref($_[0])eq 'ARRAY'){for (my$i=0;$i < @{$_[0]};$i++){print$fh $_[0]->[$i]}}else {print$fh $_[0]}return}sub spew_lines {my$self=shift;my%args=splice(@_,0,@_-1);my$content=$_[0];$content =ref($content)eq 'ARRAY' ? [map {$_,$/}@$content ]: "$content$/";return$self->spew(%args,$content)}sub remove {my$file=shift->stringify;return unlink$file unless -e $file;1 while unlink$file;return not -e $file}sub copy_to {my ($self,$dest)=@_;if (UNIVERSAL::isa($dest,Path::Class::File::)){$dest=$dest->stringify;die "Can't copy to file $dest: it is a directory" if -d $dest}elsif (UNIVERSAL::isa($dest,Path::Class::Dir::)){$dest=$dest->stringify;die "Can't copy to directory $dest: it is a file" if -f $dest;die "Can't copy to directory $dest: no such directory" unless -d $dest}elsif (ref$dest){die "Don't know how to copy files to objects of type '".ref($self)."'"}if (!Perl::OSType::is_os_type('Unix')){return unless File::Copy::cp($self->stringify,"${dest}")}else {return unless (system('cp',$self->stringify,"${dest}")==0)}return$self->new($dest)}sub move_to {my ($self,$dest)=@_;if (File::Copy::move($self->stringify,"${dest}")){my$new=$self->new($dest);$self->{$_}=$new->{$_}foreach (qw/dir file/);return$self}else {return}}sub traverse {my$self=shift;my ($callback,@args)=@_;return$self->$callback(sub {()},@args)}sub traverse_if {my$self=shift;my ($callback,$condition,@args)=@_;return$self->$callback(sub {()},@args)}1;
PATH_CLASS_FILE

$fatpacked{"Pod/Elemental.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL';
  package Pod::Elemental;$Pod::Elemental::VERSION='0.103001';use Moose;use namespace::autoclean;use Sub::Exporter::ForMethods ();use Mixin::Linewise::Readers {installer=>Sub::Exporter::ForMethods::method_installer },-readers;use Moose::Autobox 0.10;use MooseX::Types;use Pod::Eventual::Simple 0.004;use Pod::Elemental::Document;use Pod::Elemental::Transformer::Pod5;use Pod::Elemental::Objectifier;sub read_handle {my ($self,$handle)=@_;$self=$self->new unless ref$self;my$events=$self->event_reader->read_handle($handle);my$elements=$self->objectifier->objectify_events($events);my$document=$self->document_class->new({children=>$elements,});return$document}has event_reader=>(is=>'ro',required=>1,default=>sub {return Pod::Eventual::Simple->new},);has objectifier=>(is=>'ro',isa=>duck_type([qw(objectify_events) ]),required=>1,default=>sub {return Pod::Elemental::Objectifier->new},);has document_class=>(is=>'ro',required=>1,default=>'Pod::Elemental::Document',);__PACKAGE__->meta->make_immutable;no Moose;1;
POD_ELEMENTAL

$fatpacked{"Pod/Elemental/Autoblank.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_AUTOBLANK';
  package Pod::Elemental::Autoblank;$Pod::Elemental::Autoblank::VERSION='0.103001';use namespace::autoclean;use Moose::Role;around as_pod_string=>sub {my ($orig,$self,@arg)=@_;my$str=$self->$orig(@arg);"$str\n\n"};1;
POD_ELEMENTAL_AUTOBLANK

$fatpacked{"Pod/Elemental/Autochomp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_AUTOCHOMP';
  package Pod::Elemental::Autochomp;$Pod::Elemental::Autochomp::VERSION='0.103001';use namespace::autoclean;use Moose::Role;use Pod::Elemental::Types qw(ChompedString);1;
POD_ELEMENTAL_AUTOCHOMP

$fatpacked{"Pod/Elemental/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_COMMAND';
  package Pod::Elemental::Command;$Pod::Elemental::Command::VERSION='0.103001';use Moose::Role 0.90;with 'Pod::Elemental::Paragraph'=>{-excludes=>['as_pod_string' ]};use Moose::Autobox;requires 'command';sub as_pod_string {my ($self)=@_;my$content=$self->content;sprintf "=%s%s",$self->command,($content =~ /\S/ ? " $content" : $content)}sub as_debug_string {my ($self)=@_;my$str=$self->_summarize_string($self->content);return sprintf '=%s %s',$self->command,$str}1;
POD_ELEMENTAL_COMMAND

$fatpacked{"Pod/Elemental/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_DOCUMENT';
  package Pod::Elemental::Document;$Pod::Elemental::Document::VERSION='0.103001';use Moose;with 'Pod::Elemental::Node';use Class::Load ();use Moose::Autobox;use namespace::autoclean;use Pod::Elemental::Element::Generic::Blank;use String::RewritePrefix;sub _expand_name {my ($self,$name)=@_;return String::RewritePrefix->rewrite({''=>'Pod::Elemental::Element::','='=>'' },$name,)}sub as_pod_string {my ($self)=@_;my$str=join q{},$self->children->map(sub {$_->as_pod_string})->flatten;$str="=pod\n\n$str" unless$str =~ /\A=pod\n/;$str .= "=cut\n" unless$str =~ /=cut\n+\z/;return$str}sub as_debug_string {return 'Document'}sub _elem_from_lol_entry {my ($self,$entry)=@_;my ($type,$content,$arg)=@$entry;$arg ||={};if (!defined$type){my$n_class=$self->_expand_name($arg->{class}|| 'Generic::Text');Class::Load::load_class($n_class);return$n_class->new({content=>"$content\n" })}elsif ($type =~ /\A=(\w+)\z/){my$command=$1;my$n_class=$self->_expand_name($arg->{class}|| 'Generic::Command');Class::Load::load_class($n_class);return$n_class->new({command=>$command,content=>"$content\n" })}else {my$n_class=$self->_expand_name($arg->{class}|| 'Pod5::Region');Class::Load::load_class($n_class);my@children;for my$child (@$content){push@children,$self->_elem_from_lol_entry($child)}continue {my$blank=$self->_expand_name('Generic::Blank');push@children,$blank->new({content=>"\n" })}pop@children while$children[-1]->isa('Pod::Elemental::Element::Generic::Blank');my ($colon,$target)=$type =~ /\A(:)?(.+)\z/;return$n_class->new({format_name=>$target,is_pod=>$colon ? 1 : 0,content=>"\n",children=>\@children,})}}sub new_from_lol {my ($class,$lol)=@_;my$self=$class->new;my@children;ENTRY: for my$entry (@$lol){my$elem=$self->_elem_from_lol_entry($entry);push@children,$elem}continue {my$blank=$self->_expand_name('Generic::Blank');push@children,$blank->new({content=>"\n" })}push @{$self->children},@children;return$self}1;
POD_ELEMENTAL_DOCUMENT

$fatpacked{"Pod/Elemental/Element/Generic/Blank.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_GENERIC_BLANK';
  package Pod::Elemental::Element::Generic::Blank;$Pod::Elemental::Element::Generic::Blank::VERSION='0.103001';use Moose;with 'Pod::Elemental::Flat';use namespace::autoclean;sub as_debug_string {'|'}1;
POD_ELEMENTAL_ELEMENT_GENERIC_BLANK

$fatpacked{"Pod/Elemental/Element/Generic/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_GENERIC_COMMAND';
  package Pod::Elemental::Element::Generic::Command;$Pod::Elemental::Element::Generic::Command::VERSION='0.103001';use Moose;use namespace::autoclean;use Moose::Autobox;has command=>(is=>'rw',isa=>'Str',required=>1,);with 'Pod::Elemental::Command';1;
POD_ELEMENTAL_ELEMENT_GENERIC_COMMAND

$fatpacked{"Pod/Elemental/Element/Generic/Nonpod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_GENERIC_NONPOD';
  package Pod::Elemental::Element::Generic::Nonpod;$Pod::Elemental::Element::Generic::Nonpod::VERSION='0.103001';use Moose;with 'Pod::Elemental::Flat';use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_GENERIC_NONPOD

$fatpacked{"Pod/Elemental/Element/Generic/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_GENERIC_TEXT';
  package Pod::Elemental::Element::Generic::Text;$Pod::Elemental::Element::Generic::Text::VERSION='0.103001';use Moose;with 'Pod::Elemental::Flat';use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_GENERIC_TEXT

$fatpacked{"Pod/Elemental/Element/Nested.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_NESTED';
  package Pod::Elemental::Element::Nested;$Pod::Elemental::Element::Nested::VERSION='0.103001';use Moose;extends 'Pod::Elemental::Element::Generic::Command';with 'Pod::Elemental::Node';with 'Pod::Elemental::Autochomp';use namespace::autoclean;use Moose::Autobox 0.10;use Pod::Elemental::Types qw(ChompedString);has '+content'=>(coerce=>1,isa=>ChompedString);override as_pod_string=>sub {my ($self)=@_;my$string=super;$string=join q{},"$string\n\n",$self->children->map(sub {$_->as_pod_string})->flatten;$string =~ s/\n{3,}\z/\n\n/g;return$string};1;
POD_ELEMENTAL_ELEMENT_NESTED

$fatpacked{"Pod/Elemental/Element/Pod5/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_COMMAND';
  package Pod::Elemental::Element::Pod5::Command;$Pod::Elemental::Element::Pod5::Command::VERSION='0.103001';use Moose;extends 'Pod::Elemental::Element::Generic::Command';with 'Pod::Elemental::Autoblank';with 'Pod::Elemental::Autochomp';use Pod::Elemental::Types qw(ChompedString);has '+content'=>(coerce=>1,isa=>ChompedString,);use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_POD5_COMMAND

$fatpacked{"Pod/Elemental/Element/Pod5/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_DATA';
  package Pod::Elemental::Element::Pod5::Data;$Pod::Elemental::Element::Pod5::Data::VERSION='0.103001';use Moose;extends 'Pod::Elemental::Element::Generic::Text';use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_POD5_DATA

$fatpacked{"Pod/Elemental/Element/Pod5/Nonpod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_NONPOD';
  package Pod::Elemental::Element::Pod5::Nonpod;$Pod::Elemental::Element::Pod5::Nonpod::VERSION='0.103001';use Moose;with 'Pod::Elemental::Flat';with 'Pod::Elemental::Autoblank';use namespace::autoclean;sub as_pod_string {my ($self)=@_;return sprintf "=cut\n%s=pod\n",$self->content}1;
POD_ELEMENTAL_ELEMENT_POD5_NONPOD

$fatpacked{"Pod/Elemental/Element/Pod5/Ordinary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_ORDINARY';
  package Pod::Elemental::Element::Pod5::Ordinary;$Pod::Elemental::Element::Pod5::Ordinary::VERSION='0.103001';use Moose;extends 'Pod::Elemental::Element::Generic::Text';with 'Pod::Elemental::Autoblank';with 'Pod::Elemental::Autochomp';use Pod::Elemental::Types qw(ChompedString);has '+content'=>(coerce=>1,isa=>ChompedString);use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_POD5_ORDINARY

$fatpacked{"Pod/Elemental/Element/Pod5/Region.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_REGION';
  package Pod::Elemental::Element::Pod5::Region;$Pod::Elemental::Element::Pod5::Region::VERSION='0.103001';use Moose;with qw(Pod::Elemental::Paragraph Pod::Elemental::Node Pod::Elemental::Command);use Moose::Autobox;use Pod::Elemental::Types qw(FormatName);use MooseX::Types::Moose qw(Bool);has format_name=>(is=>'ro',isa=>FormatName,required=>1);has is_pod=>(is=>'ro',isa=>Bool,required=>1,default=>1);sub command {'begin'}sub closing_command {'end'}sub _display_as_for {my ($self)=@_;return if$self->content =~ /\S/;return if$self->children->length!=1;my$child=$self->children->[0];return if$child->content =~ m{^\s*$}m;my$base='Pod::Elemental::Element::Pod5::';return 1 if$self->is_pod and $child->isa("${base}Ordinary");return 1 if!$self->is_pod and $child->isa("${base}Data");return}sub as_pod_string {my ($self)=@_;my$string;if ($self->_display_as_for){$string=$self->__as_pod_string_for($self)}else {$string=$self->__as_pod_string_begin($self)}$string =~ s/\n*\z//g;return$string}sub __as_pod_string_begin {my ($self)=@_;my$content=$self->content;my$colon=$self->is_pod ? ':' : '';my$string=sprintf "=%s %s%s\n",$self->command,$colon .$self->format_name,($content =~ /\S/ ? " $content\n" : "\n");$string .= $self->children->map(sub {$_->as_pod_string})->join(q{});$string .= "\n\n" if$self->children->length and $self->children->[-1]->isa('Pod::Elemental::Element::Pod5::Data');$string .= sprintf "=%s %s",$self->closing_command,$colon .$self->format_name;return$string}sub __as_pod_string_for {my ($self)=@_;my$content=$self->content;my$colon=$self->is_pod ? ':' : '';my$string=sprintf "=for %s %s",$colon .$self->format_name,$self->children->[0]->as_pod_string;return$string}sub as_debug_string {my ($self)=@_;my$colon=$self->is_pod ? ':' : '';my$string=sprintf "=%s %s",$self->command,$colon .$self->format_name;return$string}with 'Pod::Elemental::Autoblank';with 'Pod::Elemental::Autochomp';use Pod::Elemental::Types qw(ChompedString);has '+content'=>(coerce=>1,isa=>ChompedString);no Moose;1;
POD_ELEMENTAL_ELEMENT_POD5_REGION

$fatpacked{"Pod/Elemental/Element/Pod5/Verbatim.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_ELEMENT_POD5_VERBATIM';
  package Pod::Elemental::Element::Pod5::Verbatim;$Pod::Elemental::Element::Pod5::Verbatim::VERSION='0.103001';use Moose;extends 'Pod::Elemental::Element::Generic::Text';with 'Pod::Elemental::Autoblank';with 'Pod::Elemental::Autochomp';use Pod::Elemental::Types qw(ChompedString);has '+content'=>(coerce=>1,isa=>ChompedString);use namespace::autoclean;1;
POD_ELEMENTAL_ELEMENT_POD5_VERBATIM

$fatpacked{"Pod/Elemental/Flat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_FLAT';
  package Pod::Elemental::Flat;$Pod::Elemental::Flat::VERSION='0.103001';use Moose::Role;use namespace::autoclean;with 'Pod::Elemental::Paragraph';excludes 'Pod::Elemental::Node';sub as_debug_string {my ($self)=@_;my$moniker=ref$self;$moniker =~ s/\APod::Elemental::Element:://;my$summary=$self->_summarize_string($self->content);return "$moniker <$summary>"}1;
POD_ELEMENTAL_FLAT

$fatpacked{"Pod/Elemental/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_NODE';
  package Pod::Elemental::Node;$Pod::Elemental::Node::VERSION='0.103001';use Moose::Role;use namespace::autoclean;use Moose::Autobox;use MooseX::Types;use MooseX::Types::Moose qw(ArrayRef);use Moose::Util::TypeConstraints qw(class_type);requires 'as_pod_string';requires 'as_debug_string';has children=>(is=>'rw',isa=>ArrayRef[role_type('Pod::Elemental::Paragraph')],required=>1,default=>sub {[]},);around as_debug_string=>sub {my ($orig,$self)=@_;my$str=$self->$orig;my@children=map {$_->as_debug_string}$self->children->flatten;s/^/  /sgm for@children;$str=join "\n",$str,@children;return$str};1;
POD_ELEMENTAL_NODE

$fatpacked{"Pod/Elemental/Objectifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_OBJECTIFIER';
  package Pod::Elemental::Objectifier;$Pod::Elemental::Objectifier::VERSION='0.103001';use Moose;use Moose::Autobox;use namespace::autoclean;use Pod::Elemental::Element::Generic::Blank;use Pod::Elemental::Element::Generic::Command;use Pod::Elemental::Element::Generic::Nonpod;use Pod::Elemental::Element::Generic::Text;sub objectify_events {my ($self,$events)=@_;return$events->map(sub {Carp::croak("not a valid event")unless ref $_;my$class=$self->element_class_for_event($_);my%guts=(content=>$_->{content},start_line=>$_->{start_line},($_->{type}eq 'command' ? (command=>$_->{command}): ()),);$class->new(\%guts)})}sub __class_for {return {blank=>'Pod::Elemental::Element::Generic::Blank',command=>'Pod::Elemental::Element::Generic::Command',nonpod=>'Pod::Elemental::Element::Generic::Nonpod',text=>'Pod::Elemental::Element::Generic::Text',}}sub element_class_for_event {my ($self,$event)=@_;my$t=$event->{type};my$class_for=$self->__class_for;Carp::croak "unknown event type: $t" unless exists$class_for->{$t };return$class_for->{$t }}1;
POD_ELEMENTAL_OBJECTIFIER

$fatpacked{"Pod/Elemental/Paragraph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_PARAGRAPH';
  package Pod::Elemental::Paragraph;$Pod::Elemental::Paragraph::VERSION='0.103001';use namespace::autoclean;use Moose::Role;use Moose::Autobox;use Encode qw(encode);use String::Truncate qw(elide);has content=>(is=>'rw',isa=>'Str',required=>1);has start_line=>(is=>'ro',isa=>'Int',required=>0);sub as_pod_string {my ($self)=@_;return$self->content}sub _summarize_string {my ($self,$str,$length)=@_;$length ||=30;use utf8;chomp$str;my$elided=elide($str,$length,{truncate=>'middle',marker=>'' });$elided =~ tr/\n\t//;return encode('utf-8',$elided)}requires 'as_debug_string';1;
POD_ELEMENTAL_PARAGRAPH

$fatpacked{"Pod/Elemental/Selectors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_SELECTORS';
  use strict;use warnings;package Pod::Elemental::Selectors;$Pod::Elemental::Selectors::VERSION='0.103001';use Moose::Autobox 0.10;use Sub::Exporter -setup=>{exports=>[qw(s_blank s_flat s_node s_command) ],};sub s_blank {my$code=sub {my$para=shift;return$para->isa('Pod::Elemental::Element::Generic::Blank')};return @_ ? $code->(@_): $code}sub s_flat {my$code=sub {my$para=shift;return$para->does('Pod::Elemental::Flat')};return @_ ? $code->(@_): $code}sub s_node {my$code=sub {my$para=shift;return$para->does('Pod::Elemental::Node')};return @_ ? $code->(@_): $code}sub s_command {my$command=shift;my$code=sub {my$para=shift;return unless$para->does('Pod::Elemental::Command');return 1 unless defined$command;my$alts=ref$command ? $command : [$command ];return$para->command eq $alts->any};return @_ ? $code->(@_): $code}1;
POD_ELEMENTAL_SELECTORS

$fatpacked{"Pod/Elemental/Transformer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_TRANSFORMER';
  package Pod::Elemental::Transformer;$Pod::Elemental::Transformer::VERSION='0.103001';use Moose::Role;use Moose::Autobox;use namespace::autoclean;requires 'transform_node';1;
POD_ELEMENTAL_TRANSFORMER

$fatpacked{"Pod/Elemental/Transformer/Gatherer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_TRANSFORMER_GATHERER';
  package Pod::Elemental::Transformer::Gatherer;$Pod::Elemental::Transformer::Gatherer::VERSION='0.103001';use Moose;with 'Pod::Elemental::Transformer';use namespace::autoclean;use Moose::Autobox 0.10;use MooseX::Types::Moose qw(CodeRef);use Pod::Elemental::Node;has gather_selector=>(is=>'ro',isa=>CodeRef,required=>1,);has container=>(is=>'ro',does=>'Pod::Elemental::Node',required=>1,);sub transform_node {my ($self,$node)=@_;my@indexes;for my$i (0 .. $node->children->length - 1){push@indexes,$i if$self->gather_selector->($node->children->[$i ])}my@paras;for my$idx (reverse@indexes){unshift@paras,splice @{$node->children},$idx,1}$self->container->children(\@paras);splice @{$node->children},$indexes[0],0,$self->container;return$node}1;
POD_ELEMENTAL_TRANSFORMER_GATHERER

$fatpacked{"Pod/Elemental/Transformer/Nester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_TRANSFORMER_NESTER';
  package Pod::Elemental::Transformer::Nester;$Pod::Elemental::Transformer::Nester::VERSION='0.103001';use Moose;with 'Pod::Elemental::Transformer';use Moose::Autobox 0.10;use MooseX::Types::Moose qw(ArrayRef CodeRef);use Pod::Elemental::Element::Nested;use Pod::Elemental::Selectors -all;use namespace::autoclean;has top_selector=>(is=>'ro',isa=>CodeRef,required=>1,);has content_selectors=>(is=>'ro',isa=>ArrayRef[CodeRef ],required=>1,);sub _is_containable {my ($self,$para)=@_;for my$sel ($self->content_selectors->flatten){return 1 if$sel->($para)}return}sub transform_node {my ($self,$node)=@_;PASS: for my$i (0 .. $node->children->length - 1){last PASS if$i >= $node->children->length;my$para=$node->children->[$i ];next unless$self->top_selector->($para);if (s_command(undef,$para)and not s_node($para)){$para=$node->children->[$i ]=Pod::Elemental::Element::Nested->new({command=>$para->command,content=>$para->content,})}if (!s_node($para)or $para->children->length){confess "can't use $para as the top of a nesting"}my@to_nest;NEST: for my$j ($i+1 .. $node->children->length - 1){last unless$self->_is_containable($node->children->[$j ]);push@to_nest,$j}if (@to_nest){my@to_nest_elem=splice @{$node->children},$to_nest[0],scalar(@to_nest);$para->children->push(@to_nest_elem);next PASS}}return$node}1;
POD_ELEMENTAL_TRANSFORMER_NESTER

$fatpacked{"Pod/Elemental/Transformer/Pod5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_TRANSFORMER_POD5';
  package Pod::Elemental::Transformer::Pod5;$Pod::Elemental::Transformer::Pod5::VERSION='0.103001';use Moose;with 'Pod::Elemental::Transformer';use Moose::Autobox 0.10;use namespace::autoclean;use Pod::Elemental::Document;use Pod::Elemental::Element::Pod5::Command;use Pod::Elemental::Element::Pod5::Data;use Pod::Elemental::Element::Pod5::Nonpod;use Pod::Elemental::Element::Pod5::Ordinary;use Pod::Elemental::Element::Pod5::Verbatim;use Pod::Elemental::Element::Pod5::Region;use Pod::Elemental::Selectors -all;sub _gen_class {"Pod::Elemental::Element::Generic::$_[1]"}sub _class {"Pod::Elemental::Element::Pod5::$_[1]"}sub _region_para_parts {my ($self,$para)=@_;my ($colon,$target,$content,$nl)=$para->content =~ m/
      \A
      (:)?
      (\S+)
      (?:\s+(.+))?
      (\s+)\z
    /xsm;confess("=begin cannot be parsed")unless defined$target;$colon ||='';$content ||='';return ($colon,$target,"$content$nl")}sub __extract_region {my ($self,$name,$in_paras)=@_;my%nest=($name=>1);my@region_paras;REGION_PARA: while (my$region_para=shift @$in_paras){if (s_command([qw(begin end) ],$region_para)){my ($r_colon,$r_target)=$self->_region_para_parts($region_para);for ($nest{"$r_colon$r_target" }){$_ += $region_para->command eq 'begin' ? 1 : -1;confess("=end $r_colon$r_target without matching begin")if $_ < 0;last REGION_PARA if!$_ and "$r_colon$r_target" eq $name}}@region_paras->push($region_para)};return \@region_paras}sub _upgrade_nonpod {my ($self,$in_paras)=@_;$in_paras->each(sub {my ($i,$para)=@_;return unless$para->isa($self->_gen_class('Nonpod'));$in_paras->[$i ]=$self->_class('Nonpod')->new({content=>$para->content,})})}sub _collect_regions {my ($self,$in_paras)=@_;my@out_paras;my$s_region=s_command([qw(begin for) ]);my$region_class=$self->_class('Region');PARA: while (my$para=$in_paras->shift){@out_paras->push($para),next PARA unless$s_region->($para);if ($para->command eq 'for'){my ($colon,$target,$content)=$self->_region_para_parts($para);my$region=$region_class->new({children=>[$self->_gen_class('Text')->new({content=>$content }),],format_name=>$target,is_pod=>$colon ? 1 : 0,content=>"\n",});@out_paras->push($region);next PARA}my ($colon,$target,$content)=$self->_region_para_parts($para);my$region_paras=$self->__extract_region("$colon$target",$in_paras);$region_paras->shift while s_blank($region_paras->[0]);$region_paras->pop while @$region_paras && s_blank($region_paras->[-1]);my$region=$region_class->new({children=>$self->_collect_regions($region_paras),format_name=>$target,is_pod=>$colon ? 1 : 0,content=>$content,});@out_paras->push($region)}@$in_paras=@out_paras;return$in_paras}sub _strip_markers {my ($self,$in_paras)=@_;@$in_paras=grep {!s_command([qw(cut pod) ],$_)}@$in_paras;$in_paras->shift while @$in_paras and s_blank($in_paras->[0])}sub _autotype_paras {my ($self,$paras,$is_pod)=@_;$paras->each(sub {my ($i,$elem)=@_;if ($elem->isa($self->_gen_class('Text'))){my$class=$is_pod ? $elem->content =~ /\A\s/ ? $self->_class('Verbatim'): $self->_class('Ordinary'): $self->_class('Data');$paras->[$i ]=$class->new({content=>$elem->content })}if ($elem->isa($self->_class('Region'))){$self->_autotype_paras($elem->children,$elem->is_pod)}if ($elem->isa($self->_gen_class('Command'))){$paras->[$i ]=$self->_class('Command')->new({command=>$elem->command,content=>$elem->content,})}})}sub __text_class {my ($self,$para)=@_;for my$type (qw(Verbatim Data)){my$class=$self->_class($type);return$class if$para->isa($class)}return}sub _collect_runs {my ($self,$paras)=@_;$paras->grep(sub {$_->isa($self->_class('Region'))})->each_value(sub {$self->_collect_runs($_->children)});PASS: for my$start (0 .. $#$paras){last PASS if $#$paras - $start < 2;my$class=$self->__text_class($paras->[$start ]);next PASS unless$class;my@to_collect=($start);NEXT: for my$next ($start+1 .. $#$paras){if ($paras->[$next ]->isa($class)or s_blank($paras->[$next ])){push@to_collect,$next;next NEXT}last NEXT}pop@to_collect while s_blank($paras->[$to_collect[-1 ]]);next PASS unless@to_collect >= 3;my$new_content=$paras ->slice(\@to_collect)->map(sub {$_=$_->content;chomp;$_})->join(qq{\n});splice @$paras,$start,scalar(@to_collect),$class->new({content=>$new_content,});redo PASS}my@out;PASS: for (my$i=0;$i < @$paras;$i++){my$this=$paras->[$i];push@out,$this;while ($paras->[$i+1]and s_blank($paras->[$i+1])){$i++;next unless$this->isa($self->_class('Data'));$this->content($this->content .$paras->[$i]->content)}}@$paras=@out;return \@out}sub transform_node {my ($self,$node)=@_;$self->_strip_markers($node->children);$self->_upgrade_nonpod($node->children);$self->_collect_regions($node->children);$self->_autotype_paras($node->children,1);$self->_collect_runs($node->children);return$node}1;
POD_ELEMENTAL_TRANSFORMER_POD5

$fatpacked{"Pod/Elemental/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ELEMENTAL_TYPES';
  use strict;use warnings;package Pod::Elemental::Types;$Pod::Elemental::Types::VERSION='0.103001';use MooseX::Types -declare=>[qw(FormatName ChompedString) ];use MooseX::Types::Moose qw(Str);subtype FormatName,as Str,where {length $_ and /\A\S+\z/};subtype ChompedString,as Str,where {!/\n\z/};coerce ChompedString,from Str,via {chomp;$_};1;
POD_ELEMENTAL_TYPES

$fatpacked{"Pod/Eventual.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_EVENTUAL';
  use strict;use warnings;package Pod::Eventual;{$Pod::Eventual::VERSION='0.094001'}use Mixin::Linewise::Readers 0.102;use Carp ();sub read_handle {my ($self,$handle,$arg)=@_;$arg ||={};my$in_pod=$arg->{in_pod}? 1 : 0;my$current;LINE: while (my$line=$handle->getline){if ($in_pod and $line =~ /^=cut(?:\s*)(.*?)(\n)\z/){my$content="$1$2";$in_pod=0;$self->handle_event($current)if$current;undef$current;$self->handle_event({type=>'command',command=>'cut',content=>$content,start_line=>$handle->input_line_number,});next LINE}if ($line =~ /\A=[a-z]/i){if ($current and not $in_pod){$self->handle_nonpod($current);undef$current}$in_pod=1}if (not $in_pod){$current ||={type=>'nonpod',start_line=>$handle->input_line_number,content=>'',};$current->{content}.= $line;next LINE}if ($line =~ /^\s*$/){if ($current and $current->{type}ne 'blank'){$self->handle_event($current);$current={type=>'blank',content=>'',start_line=>$handle->input_line_number,}}}elsif ($current and $current->{type}eq 'blank'){$self->handle_blank($current);undef$current}if ($current){$current->{content}.= $line;next LINE}if ($line =~ /^=([a-z]+\S*)(?:\s*)(.*?)(\n)\z/i){my$command=$1;my$content="$2$3";$current={type=>'command',command=>$command,content=>$content,start_line=>$handle->input_line_number,};next LINE}$current={type=>'text',content=>$line,start_line=>$handle->input_line_number,}}if ($current){my$method=$current->{type}eq 'blank' ? 'handle_blank' : $current->{type}eq 'nonpod' ? 'handle_nonpod' : 'handle_event';$self->$method($current)if$current}return}sub handle_event {Carp::confess("handle_event not implemented by $_[0]")}sub handle_nonpod {}sub handle_blank {}1;
POD_EVENTUAL

$fatpacked{"Pod/Eventual/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_EVENTUAL_SIMPLE';
  use strict;use warnings;package Pod::Eventual::Simple;{$Pod::Eventual::Simple::VERSION='0.094001'}use Pod::Eventual;BEGIN {our@ISA='Pod::Eventual'}sub new {my ($class)=@_;bless []=>$class}sub read_handle {my ($self,$handle,$arg)=@_;$self=$self->new unless ref$self;$self->SUPER::read_handle($handle,$arg);return [@$self ]}sub handle_event {my ($self,$event)=@_;push @$self,$event}BEGIN {*handle_blank=\&handle_event;*handle_nonpod=\&handle_event}1;
POD_EVENTUAL_SIMPLE

$fatpacked{"Probe/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROBE_PERL';
  use strict;package Probe::Perl;{$Probe::Perl::VERSION='0.03'}use Config;use File::Spec;sub new {my$class=shift;my$data=shift || {};return bless($data,$class)}sub config {my ($self,$key)=(shift,shift);if (@_){unless (ref$self){die "Can't set config values via $self->config().  Use $self->new() to create a local view"}$self->{$key}=shift}return ref($self)&& exists$self->{$key}? $self->{$key}: $Config{$key}}sub config_revert {my$self=shift;die "Can't use config_revert() as a class method" unless ref($self);delete$self->{$_}foreach @_}sub perl_version {my$self=shift;return $^V ? $self->perl_version_to_float(sprintf("%vd",$^V)): $]}sub perl_version_to_float {my ($self,$version)=@_;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf( '%03d', $1 )/eg;return$version}sub _backticks {my$perl=shift;return unless -e $perl;my$fh;eval {open$fh,'-|',$perl,@_ or die $!};if (!$@){return <$fh> if wantarray;my$tmp=do {local $/=undef;<$fh>};return$tmp}if ($^O eq 'MSWin32'){$perl=qq{"$perl"} if$perl =~ m{^[\w\\]+$}}else {$perl =~ s{([^\w\\])}{\\$1}g}return `$perl @_`}sub perl_is_same {my ($self,$perl)=@_;return _backticks($perl,qw(-MConfig=myconfig -e print -e myconfig))eq Config->myconfig}sub find_perl_interpreter {my$self=shift;return $^X if File::Spec->file_name_is_absolute($^X);my$exe=$self->config('exe_ext');my$thisperl=$^X;if ($self->os_type eq 'VMS'){$thisperl .= $exe unless$thisperl =~ m/$exe(;\d+)?$/i}elsif (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}for my$perl ($self->config('perlpath'),map(File::Spec->catfile($_,$thisperl),File::Spec->path())){return$perl if -f $perl and $self->perl_is_same($perl)}return}sub perl_inc {my$self=shift;local$ENV{PERL5LIB};my$perl=$self->find_perl_interpreter();my@inc=_backticks($perl,qw(-l -e print -e for -e @INC));chomp@inc;return@inc}{my%OSTYPES=qw(aix Unix bsdos Unix dgux Unix dynixptx Unix freebsd Unix linux Unix hpux Unix irix Unix darwin Unix machten Unix next Unix openbsd Unix netbsd Unix dec_osf Unix svr4 Unix svr5 Unix sco_sv Unix unicos Unix unicosmk Unix solaris Unix sunos Unix cygwin Unix os2 Unix dos Windows MSWin32 Windows os390 EBCDIC os400 EBCDIC posix-bc EBCDIC vmesa EBCDIC MacOS MacOS VMS VMS VOS VOS riscos RiscOS amigaos Amiga mpeix MPEiX);sub os_type {my$class=shift;return$OSTYPES{shift || $^O}}}1;
PROBE_PERL

$fatpacked{"Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCOPE_GUARD';
  package Scope::Guard;use strict;use warnings;use Carp qw(confess);use Exporter ();our@ISA=qw(Exporter);our@EXPORT_OK=qw(guard scope_guard);our$VERSION='0.20';sub new {confess "Can't create a Scope::Guard in void context" unless (defined wantarray);my$class=shift;my$handler=shift()|| die 'Scope::Guard::new: no handler supplied';my$ref=ref$handler || '';die "Scope::Guard::new: invalid handler - expected CODE ref, got: '$ref'" unless (UNIVERSAL::isa($handler,'CODE'));bless [0,$handler ],ref$class || $class}sub dismiss {my$self=shift;my$dismiss=@_ ? shift : 1;$self->[0]=$dismiss}sub guard(&) {__PACKAGE__->new(shift)}sub scope_guard($) {__PACKAGE__->new(shift)}sub DESTROY {my$self=shift;my ($dismiss,$handler)=@$self;$handler->()unless ($dismiss)}1;
SCOPE_GUARD

$fatpacked{"String/RewritePrefix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_REWRITEPREFIX';
  use strict;use warnings;package String::RewritePrefix;{$String::RewritePrefix::VERSION='0.007'}use Carp ();use Sub::Exporter 0.972 -setup=>{exports=>[rewrite=>\'_new_rewriter' ],};sub rewrite {my ($self,$arg,@rest)=@_;return$self->_new_rewriter(rewrite=>{prefixes=>$arg })->(@rest)}sub _new_rewriter {my ($self,$name,$arg)=@_;my$rewrites=$arg->{prefixes}|| {};my@rewrites;for my$prefix (sort {length$b <=> length$a}keys %$rewrites){push@rewrites,($prefix,$rewrites->{$prefix})}return sub {my@result;Carp::cluck("string rewriter invoked in void context")unless defined wantarray;Carp::croak("attempt to rewrite multiple strings outside of list context")if @_ > 1 and!wantarray;STRING: for my$str (@_){for (my$i=0;$i < @rewrites;$i += 2){if (index($str,$rewrites[$i])==0){if (ref$rewrites[$i+1]){my$rest=substr$str,length($rewrites[$i]);my$str=$rewrites[$i+1 ]->($rest);push@result,(defined$str ? $str : '').$rest}else {push@result,$rewrites[$i+1].substr$str,length($rewrites[$i])}next STRING}}push@result,$str}return wantarray ? @result : $result[0]}}1;
STRING_REWRITEPREFIX

$fatpacked{"String/Truncate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_TRUNCATE';
  use strict;use warnings;package String::Truncate;$String::Truncate::VERSION='1.100602';use Carp qw(croak);use Sub::Install 0.03 qw(install_sub);my%elider_for=(right=>\&_elide_right,left=>\&_elide_left,middle=>\&_elide_middle,ends=>\&_elide_ends,);sub _elide_right {&_assert_1ML;my ($string,$length,$marker,$at_space)=@_;my$keep=$length - length($marker);if ($at_space){my ($substr)=$string =~ /\A(.{0,$keep})\s/s;$substr=substr($string,0,$keep)unless defined$substr and length$substr;return$substr .$marker}else {return substr($string,0,$keep).$marker}}sub _elide_left {&_assert_1ML;my ($string,$length,$marker,$at_space)=@_;my$keep=$length - length($marker);return$marker .reverse(_elide_right(scalar reverse($string),$keep,q{},$at_space))}sub _elide_middle {&_assert_1ML;my ($string,$length,$marker,$at_space)=@_;my$keep=$length - length($marker);my ($keep_left,$keep_right)=(int($keep / 2))x 2;$keep_left +=1 if ($keep_left + $keep_right)< $keep;return _elide_right($string,$keep_left,q{},$at_space).$marker ._elide_left($string,$keep_right,q{},$at_space)}sub _elide_ends {&_assert_2ML;my ($string,$length,$marker,$at_space)=@_;my$midpoint=int(length($string)/ 2);my$each=int($length / 2);return _elide_left(substr($string,0,$midpoint),$each,$marker,$at_space)._elide_right(substr($string,-$midpoint),$each,$marker,$at_space)}sub _assert_1ML {my ($string,$length,$marker)=@_;croak "elision marker <$marker> is longer than allowed length $length!" if length($marker)> $length}sub _assert_2ML {my ($string,$length,$marker)=@_;croak "two elision markers <$marker> are longer than allowed length $length!" if (length($marker)* 2)> $length}sub elide {my ($string,$length,$arg)=@_;$arg={}unless$arg;my$truncate=$arg->{truncate}|| 'right';croak "invalid value for truncate argument: $truncate" unless my$elider=$elider_for{$truncate };return$string if length($string)<= $length;my$marker=defined$arg->{marker}? $arg->{marker}: '...';my$at_space=defined$arg->{at_space}? $arg->{at_space}: 0;return$elider->($string,$length,$marker,$at_space)}sub trunc {my ($string,$length,$arg)=@_;$arg={}unless$arg;croak "marker may not be passed to trunc()" if exists$arg->{marker};$arg->{marker}=q{};return elide($string,$length,$arg)}use Sub::Exporter::Util ();use Sub::Exporter 0.953 -setup=>{exports=>{Sub::Exporter::Util::merge_col(defaults=>{trunc=>sub {trunc_with_defaults($_[2])},elide=>sub {elide_with_defaults($_[2])},})},collectors=>[qw(defaults) ]};sub _code_with_defaults {my ($code,$skip_defaults)=@_;sub {my$defaults=shift || {};my%defaults=%$defaults;delete$defaults{$_}for @$skip_defaults;my$length=delete$defaults{length};sub {my$string=$_[0];my$length=defined $_[1]? $_[1]: $length;my$arg={%defaults,(defined $_[2]? %{$_[2]}: ())};return$code->($string,$length,$arg)}}}BEGIN {install_sub({code=>_code_with_defaults(\&elide),as=>'elide_with_defaults',})}BEGIN {install_sub({code=>_code_with_defaults(\&trunc,['marker']),as=>'trunc_with_defaults',})}1;
STRING_TRUNCATE

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;use strict;use warnings;package Sub::Exporter;{$Sub::Exporter::VERSION='0.987'}use Carp ();use Data::OptList 0.100 ();use Params::Util 0.14 ();use Sub::Install 0.92 ();sub _group_name {my ($name)=@_;return if (index q{-:},(substr$name,0,1))==-1;return substr$name,1}sub _expand_groups {my ($class,$config,$groups,$collection,$seen,$merge)=@_;$seen ||={};$merge ||={};my@groups=@$groups;for my$i (reverse 0 .. $#groups){if (my$group_name=_group_name($groups[$i][0])){my$seen={%$seen };splice@groups,$i,1,_expand_group($class,$config,$groups[$i],$collection,$seen,$merge)}else {next unless my%merge=%$merge;my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';if (Params::Util::_CODELIKE($groups[$i][1])or Params::Util::_SCALAR0($groups[$i][1])){$groups[$i][0]=$prefix .$groups[$i][0].$suffix}else {my$as =ref$groups[$i][1]{-as}? $groups[$i][1]{-as}: $groups[$i][1]{-as}? $prefix .$groups[$i][1]{-as}.$suffix : $prefix .$groups[$i][0].$suffix;$groups[$i][1]={%{$groups[$i][1]},%merge,-as=>$as }}}}return \@groups}sub _expand_group {my ($class,$config,$group,$collection,$seen,$merge)=@_;$merge ||={};my ($group_name,$group_arg)=@$group;$group_name=_group_name($group_name);Carp::croak qq(group "$group_name" is not exported by the $class module) unless exists$config->{groups}{$group_name};return if$seen->{$group_name}++;if (ref$group_arg){my$prefix=(delete$merge->{-prefix}||'').($group_arg->{-prefix}||'');my$suffix=($group_arg->{-suffix}||'').(delete$merge->{-suffix}||'');$merge={%$merge,%$group_arg,($prefix ? (-prefix=>$prefix): ()),($suffix ? (-suffix=>$suffix): ()),}}my$exports=$config->{groups}{$group_name};if (Params::Util::_CODELIKE($exports)or Params::Util::_SCALAR0($exports)){my$group_arg=$merge ? {%$merge}: {};delete$group_arg->{-prefix};delete$group_arg->{-suffix};my$group=Params::Util::_CODELIKE($exports)? $exports->($class,$group_name,$group_arg,$collection): $class->$$exports($group_name,$group_arg,$collection);Carp::croak qq(group generator "$group_name" did not return a hashref) if ref$group ne 'HASH';my$stuff=[map {[$_=>$group->{$_}]}keys %$group ];return @{_expand_groups($class,$config,$stuff,$collection,$seen,$merge)}}else {$exports =Data::OptList::mkopt($exports,"$group_name exports");return @{_expand_groups($class,$config,$exports,$collection,$seen,$merge)}}}sub _mk_collection_builder {my ($col,$etc)=@_;my ($config,$import_args,$class,$into)=@$etc;my%seen;sub {my ($collection)=@_;my ($name,$value)=@$collection;Carp::croak "collection $name provided multiple times in import" if$seen{$name }++;if (ref(my$hook=$config->{collectors}{$name})){my$arg={name=>$name,config=>$config,import_args=>$import_args,class=>$class,into=>$into,};my$error_msg="collection $name failed validation";if (Params::Util::_SCALAR0($hook)){Carp::croak$error_msg unless$class->$$hook($value,$arg)}else {Carp::croak$error_msg unless$hook->($value,$arg)}}$col->{$name }=$value}}sub _collect_collections {my ($config,$import_args,$class,$into)=@_;my@collections =map {splice @$import_args,$_,1}grep {exists$config->{collectors}{$import_args->[$_][0]}}reverse 0 .. $#$import_args;unshift@collections,[INIT=>{}]if$config->{collectors}{INIT};my$col={};my$builder=_mk_collection_builder($col,\@_);for my$collection (@collections){$builder->($collection)}return$col}sub setup_exporter {my ($config)=@_;Carp::croak 'into and into_level may not both be supplied to exporter' if exists$config->{into}and exists$config->{into_level};my$as=delete$config->{as}|| 'import';my$into =exists$config->{into}? delete$config->{into}: exists$config->{into_level}? caller(delete$config->{into_level}): caller(0);my$import=build_exporter($config);Sub::Install::reinstall_sub({code=>$import,into=>$into,as=>$as,})}sub _key_intersection {my ($x,$y)=@_;my%seen=map {$_=>1}keys %$x;my@names=grep {$seen{$_}}keys %$y}my%valid_config_key;BEGIN {%valid_config_key=map {$_=>1}qw(as collectors installer generator exports groups into into_level),qw(exporter),}sub _assert_collector_names_ok {my ($collectors)=@_;for my$reserved_name (grep {/\A[_A-Z]+\z/}keys %$collectors){Carp::croak "unknown reserved collector name: $reserved_name" if$reserved_name ne 'INIT'}}sub _rewrite_build_config {my ($config)=@_;if (my@keys=grep {not exists$valid_config_key{$_}}keys %$config){Carp::croak "unknown options (@keys) passed to Sub::Exporter"}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};if ($config->{exporter}){Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";$config->{installer}=delete$config->{exporter}}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};for (qw(exports collectors)){$config->{$_}=Data::OptList::mkopt_hash($config->{$_},$_,['CODE','SCALAR' ],)}_assert_collector_names_ok($config->{collectors});if (my@names=_key_intersection(@$config{qw(exports collectors)})){Carp::croak "names (@names) used in both collections and exports"}$config->{groups}=Data::OptList::mkopt_hash($config->{groups},'groups',['HASH','ARRAY','CODE','SCALAR',]);$config->{groups}{default}||=[];$config->{groups}{all}||=[keys %{$config->{exports}}];$config->{generator}||=\&default_generator;$config->{installer}||=\&default_installer}sub build_exporter {my ($config)=@_;_rewrite_build_config($config);my$import=sub {my ($class)=shift;my$special=(ref $_[0])? shift(@_): {};Carp::croak q(into and into_level may not both be supplied to exporter) if exists$special->{into}and exists$special->{into_level};if ($special->{exporter}){Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";$special->{installer}=delete$special->{exporter}}my$into =defined$special->{into}? delete$special->{into}: defined$special->{into_level}? caller(delete$special->{into_level}): defined$config->{into}? $config->{into}: defined$config->{into_level}? caller($config->{into_level}): caller(0);my$generator=delete$special->{generator}|| $config->{generator};my$installer=delete$special->{installer}|| $config->{installer};my$import_args=Data::OptList::mkopt([@_ ]);$import_args=[[-default=>undef ]]unless @$import_args;my$collection=_collect_collections($config,$import_args,$class,$into);my$to_import=_expand_groups($class,$config,$import_args,$collection);_do_import({class=>$class,col=>$collection,config=>$config,into=>$into,generator=>$generator,installer=>$installer,},$to_import,)};return$import}sub _do_import {my ($arg,$to_import)=@_;my@todo;for my$pair (@$to_import){my ($name,$import_arg)=@$pair;my ($generator,$as);if ($import_arg and Params::Util::_CODELIKE($import_arg)){$generator=sub {$import_arg};$as=$name}else {$import_arg={$import_arg ? %$import_arg : ()};Carp::croak qq("$name" is not exported by the $arg->{class} module) unless exists$arg->{config}{exports}{$name};$generator=$arg->{config}{exports}{$name};$as=exists$import_arg->{-as}? (delete$import_arg->{-as}): $name}my$code=$arg->{generator}->({class=>$arg->{class},name=>$name,arg=>$import_arg,col=>$arg->{col},generator=>$generator,});push@todo,$as,$code}$arg->{installer}->({class=>$arg->{class},into=>$arg->{into},col=>$arg->{col},},\@todo,)}sub default_generator {my ($arg)=@_;my ($class,$name,$generator)=@$arg{qw(class name generator)};if (not defined$generator){my$code=$class->can($name)or Carp::croak "can't locate exported subroutine $name via $class";return$code}return$generator->($class,$name,$arg->{arg},$arg->{col})if Params::Util::_CODELIKE($generator);return$class->$$generator($name,$arg->{arg},$arg->{col})}sub default_installer {my ($arg,$to_export)=@_;for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];if (ref$as eq 'SCALAR'){$$as=$code}elsif (ref$as){Carp::croak "invalid reference type for $as: " .ref$as}else {Sub::Install::reinstall_sub({code=>$code,into=>$arg->{into},as=>$as })}}}sub default_exporter {Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";goto&default_installer}setup_exporter({exports=>[qw(setup_exporter build_exporter),_import=>sub {build_exporter($_[2])},],groups=>{all=>[qw(setup_exporter build_export) ],},collectors=>{-setup=>\&_setup },});sub _setup {my ($value,$arg)=@_;if (ref$value eq 'HASH'){push @{$arg->{import_args}},[_import=>{-as=>'import',%$value }];return 1}elsif (ref$value eq 'ARRAY'){push @{$arg->{import_args}},[_import=>{-as=>'import',exports=>$value }];return 1}return}"jn8:32";
SUB_EXPORTER

$fatpacked{"Sub/Exporter/ForMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_FORMETHODS';
  use strict;use warnings;package Sub::Exporter::ForMethods;{$Sub::Exporter::ForMethods::VERSION='0.100051'}use Sub::Name ();use Sub::Exporter 0.978 -setup=>{exports=>[qw(method_installer) ],};sub method_installer {sub {my ($arg,$to_export)=@_;my$into=$arg->{into};for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];next if ref$as;$to_export->[$i + 1 ]=Sub::Name::subname(join(q{::},$into,$as),sub {$code->(@_)},)}Sub::Exporter::default_installer($arg,$to_export)}}1;
SUB_EXPORTER_FORMETHODS

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;use strict;use warnings;our$VERSION='0.001011';use Carp ();use List::Util ();sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (List::Util::first {ref ||!m/ \A [:-]? \w+ \z /xm}@args){Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||=Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined(my$num=List::Util::first {!ref and m/^\d/}@args)){die "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if ($setup eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){Carp::croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};Carp::croak$too_complicated if List::Util::first {ref}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){Carp::croak$too_complicated if List::Util::first {/ \A - (?! all \b ) /x || ref}@{$tagset}}@defaults=@{$tags{default}|| []}}else {Carp::croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||=[@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;Carp::croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;use warnings;package Sub::Exporter::Util;{$Sub::Exporter::Util::VERSION='0.987'}use Data::OptList ();use Params::Util ();sub curry_method {my$override_name=shift;sub {my ($class,$name)=@_;$name=$override_name if defined$override_name;sub {$class->$name(@_)}}}BEGIN {*curry_class=\&curry_method}sub curry_chain {my (@opt_list)=@_;my$pairs=Data::OptList::mkopt(\@opt_list,'args','ARRAY');sub {my ($class)=@_;sub {my$next=$class;for my$i (0 .. $#$pairs){my$pair=$pairs->[$i ];unless (Params::Util::_INVOCANT($next)){my$str=defined$next ? "'$next'" : 'undef';Carp::croak("can't call $pair->[0] on non-invocant $str")}my ($method,$args)=@$pair;if ($i==$#$pairs){return$next->$method($args ? @$args : ())}else {$next=$next->$method($args ? @$args : ())}}}}}sub merge_col {my (%groups)=@_;my%merged;while (my ($default_name,$group)=each%groups){while (my ($export_name,$gen)=each %$group){$merged{$export_name}=sub {my ($class,$name,$arg,$col)=@_;my$merged_arg=exists$col->{$default_name}? {%{$col->{$default_name}},%$arg}: $arg;if (Params::Util::_CODELIKE($gen)){$gen->($class,$name,$merged_arg,$col)}else {$class->$$gen($name,$merged_arg,$col)}}}}return%merged}sub __mixin_class_for {my ($class,$mix_into)=@_;require Package::Generator;my$mixin_class=Package::Generator->new_package({base=>"$class\:\:__mixin__",});no strict 'refs';if (ref$mix_into){unshift @{"$mixin_class" ."::ISA"},ref$mix_into}else {unshift @{"$mix_into" ."::ISA"},$mixin_class}return$mixin_class}sub mixin_installer {sub {my ($arg,$to_export)=@_;my$mixin_class=__mixin_class_for($arg->{class},$arg->{into});bless$arg->{into}=>$mixin_class if ref$arg->{into};Sub::Exporter::default_installer({%$arg,into=>$mixin_class},$to_export,)}}sub mixin_exporter {Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";return mixin_installer}sub like {sub {my ($value,$arg)=@_;Carp::croak "no regex supplied to regex group generator" unless$value;my@values=eval {$value->isa('Regexp')}? ($value,undef): @$value;while (my ($re,$opt)=splice@values,0,2){Carp::croak "given pattern for regex group generater is not a Regexp" unless eval {$re->isa('Regexp')};my@exports=keys %{$arg->{config}->{exports}};my@matching=grep {$_ =~ $re}@exports;my%merge=$opt ? %$opt : ();my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';for my$name (@matching){my$as=$prefix .$name .$suffix;push @{$arg->{import_args}},[$name=>{%merge,-as=>$as }]}}1}}use Sub::Exporter -setup=>{exports=>[qw(like name_map merge_col curry_method curry_class curry_chain mixin_installer mixin_exporter) ]};1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;use warnings;package Sub::Install;$Sub::Install::VERSION='0.928';use Carp;use Scalar::Util ();sub _name_of_code {my ($code)=@_;require B;my$name=B::svref_2object($code)->GV->NAME;return$name unless$name =~ /\A__ANON__/;return}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' || Scalar::Util::blessed($_[0])&& (overload::Method($_[0],'&{}')? $_[0]: undef)}sub _build_public_installer {my ($installer)=@_;sub {my ($arg)=@_;my ($calling_pkg)=caller(0);for (qw(into from)){$arg->{$_}=$calling_pkg unless$arg->{$_}}Carp::croak "named argument 'code' is not optional" unless$arg->{code};if (_CODELIKE($arg->{code})){$arg->{as}||=_name_of_code($arg->{code})}else {Carp::croak "couldn't find subroutine named $arg->{code} in package $arg->{from}" unless my$code=$arg->{from}->can($arg->{code});$arg->{as}=$arg->{code}unless$arg->{as};$arg->{code}=$code}Carp::croak "couldn't determine name under which to install subroutine" unless$arg->{as};$installer->(@$arg{qw(into as code) })}}my$_misc_warn_re;my$_redef_warn_re;BEGIN {$_misc_warn_re=qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;$_redef_warn_re=qr/Subroutine\ .+?\ redefined/x}my$eow_re;BEGIN {$eow_re=qr/ at .+? line \d+\.\Z/};sub _do_with_warn {my ($arg)=@_;my$code=delete$arg->{code};my$wants_code=sub {my$code=shift;sub {my$warn=$SIG{__WARN__}? $SIG{__WARN__}: sub {warn @_};local$SIG{__WARN__}=sub {my ($error)=@_;for (@{$arg->{suppress}}){return if$error =~ $_}for (@{$arg->{croak}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){Carp::croak$base_error}}for (@{$arg->{carp}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){return$warn->(Carp::shortmess$base_error)}}($arg->{default}|| $warn)->($error)};$code->(@_)}};return$wants_code->($code)if$code;return$wants_code}sub _installer {sub {my ($pkg,$name,$code)=@_;no strict 'refs';*{"$pkg\::$name"}=$code;return$code}}BEGIN {*_ignore_warnings=_do_with_warn({carp=>[$_misc_warn_re,$_redef_warn_re ]});*install_sub=_build_public_installer(_ignore_warnings(_installer));*_carp_warnings=_do_with_warn({carp=>[$_misc_warn_re ],suppress=>[$_redef_warn_re ],});*reinstall_sub=_build_public_installer(_carp_warnings(_installer));*_install_fatal=_do_with_warn({code=>_installer,croak=>[$_redef_warn_re ],})}sub install_installers {my ($into)=@_;for my$method (qw(install_sub reinstall_sub)){my$code=sub {my ($package,$subs)=@_;my ($caller)=caller(0);my$return;for (my ($name,$sub)=%$subs){$return=Sub::Install->can($method)->({code=>$sub,from=>$caller,into=>$package,as=>$name })}return$return};install_sub({code=>$code,into=>$into,as=>$method })}}sub exporter {my ($arg)=@_;my%is_exported=map {$_=>undef}@{$arg->{exports}};sub {my$class=shift;my$target=caller;for (@_){Carp::croak "'$_' is not exported by $class" if!exists$is_exported{$_};install_sub({code=>$_,from=>$class,into=>$target })}}}BEGIN {*import=exporter({exports=>[qw(install_sub reinstall_sub) ]})}1;
SUB_INSTALL

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.24';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;for (my$up=0;$up <= $height + $adjust;$up++ ){my@caller=CORE::caller($up + 1);if(defined$caller[0]&& $caller[0]eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Syntax/Feature/Junction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_FEATURE_JUNCTION';
  package Syntax::Feature::Junction;use strict;use warnings;our$VERSION='0.003008';require Syntax::Keyword::Junction;sub install {my ($class,%args)=@_;my$target=$args{into};my$options=$args{options}|| {};Syntax::Keyword::Junction->import({into=>$target },%$options);return 1}1;
SYNTAX_FEATURE_JUNCTION

$fatpacked{"Syntax/Keyword/Junction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION';
  package Syntax::Keyword::Junction;use strict;use warnings;our$VERSION='0.003008';require Syntax::Keyword::Junction::All;require Syntax::Keyword::Junction::Any;require Syntax::Keyword::Junction::None;require Syntax::Keyword::Junction::One;use Sub::Exporter::Progressive -setup=>{exports=>[qw(all any none one)],groups=>{default=>[qw(all any none one)],ALL=>[qw(all any none one)],},};sub all {Syntax::Keyword::Junction::All->new(@_)}sub any {Syntax::Keyword::Junction::Any->new(@_)}sub none {Syntax::Keyword::Junction::None->new(@_)}sub one {Syntax::Keyword::Junction::One->new(@_)}1;
SYNTAX_KEYWORD_JUNCTION

$fatpacked{"Syntax/Keyword/Junction/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION_ALL';
  package Syntax::Keyword::Junction::All;use strict;use warnings;our$VERSION='0.003008';use parent 'Syntax::Keyword::Junction::Base';BEGIN {if ($] >= 5.010001){eval q|
  sub match {
      my ( $self, $other, $is_rhs ) = @_;
      no if $] > 5.017010, warnings => 'experimental::smartmatch';
  
      if ($is_rhs) {
          for (@$self) {
              return unless $other ~~ $_;
          }
  
          return 1;
      }
  
      for (@$self) {
          return unless $_ ~~ $other;
      }
  
      return 1;
  }
  |}}sub num_eq {return regex_eq(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return unless $_==$test}return 1}sub num_ne {return regex_ne(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return unless $_!=$test}return 1}sub num_ge {my ($self,$test,$switch)=@_;return num_le($self,$test)if$switch;for (@$self){return unless $_ >= $test}return 1}sub num_gt {my ($self,$test,$switch)=@_;return num_lt($self,$test)if$switch;for (@$self){return unless $_ > $test}return 1}sub num_le {my ($self,$test,$switch)=@_;return num_ge($self,$test)if$switch;for (@$self){return unless $_ <= $test}return 1}sub num_lt {my ($self,$test,$switch)=@_;return num_gt($self,$test)if$switch;for (@$self){return unless $_ < $test}return 1}sub str_eq {my ($self,$test)=@_;for (@$self){return unless $_ eq $test}return 1}sub str_ne {my ($self,$test)=@_;for (@$self){return unless $_ ne $test}return 1}sub str_ge {my ($self,$test,$switch)=@_;return str_le($self,$test)if$switch;for (@$self){return unless $_ ge $test}return 1}sub str_gt {my ($self,$test,$switch)=@_;return str_lt($self,$test)if$switch;for (@$self){return unless $_ gt $test}return 1}sub str_le {my ($self,$test,$switch)=@_;return str_ge($self,$test)if$switch;for (@$self){return unless $_ le $test}return 1}sub str_lt {my ($self,$test,$switch)=@_;return str_gt($self,$test)if$switch;for (@$self){return unless $_ lt $test}return 1}sub regex_eq {my ($self,$test,$switch)=@_;for (@$self){return unless $_ =~ $test}return 1}sub regex_ne {my ($self,$test,$switch)=@_;for (@$self){return unless $_ !~ $test}return 1}sub bool {my ($self)=@_;for (@$self){return unless $_}return 1}1;
SYNTAX_KEYWORD_JUNCTION_ALL

$fatpacked{"Syntax/Keyword/Junction/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION_ANY';
  package Syntax::Keyword::Junction::Any;use strict;use warnings;our$VERSION='0.003008';use parent 'Syntax::Keyword::Junction::Base';BEGIN {if ($] >= 5.010001){eval q|
  sub match {
      no if $] > 5.017010, warnings => 'experimental::smartmatch';
      my ( $self, $other, $is_rhs ) = @_;
  
      if ($is_rhs) {
          for (@$self) {
              return 1 if $other ~~ $_;
          }
  
          return;
      }
  
      for (@$self) {
          return 1 if $_ ~~ $other;
      }
  
      return;
  }
  |}}sub num_eq {return regex_eq(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return 1 if $_==$test}return}sub num_ne {return regex_ne(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return 1 if $_!=$test}return}sub num_ge {my ($self,$test,$switch)=@_;return num_le($self,$test)if$switch;for (@$self){return 1 if $_ >= $test}return}sub num_gt {my ($self,$test,$switch)=@_;return num_lt($self,$test)if$switch;for (@$self){return 1 if $_ > $test}return}sub num_le {my ($self,$test,$switch)=@_;return num_ge($self,$test)if$switch;for (@$self){return 1 if $_ <= $test}return}sub num_lt {my ($self,$test,$switch)=@_;return num_gt($self,$test)if$switch;for (@$self){return 1 if $_ < $test}return}sub str_eq {my ($self,$test)=@_;for (@$self){return 1 if $_ eq $test}return}sub str_ne {my ($self,$test)=@_;for (@$self){return 1 if $_ ne $test}return}sub str_ge {my ($self,$test,$switch)=@_;return str_le($self,$test)if$switch;for (@$self){return 1 if $_ ge $test}return}sub str_gt {my ($self,$test,$switch)=@_;return str_lt($self,$test)if$switch;for (@$self){return 1 if $_ gt $test}return}sub str_le {my ($self,$test,$switch)=@_;return str_ge($self,$test)if$switch;for (@$self){return 1 if $_ le $test}return}sub str_lt {my ($self,$test,$switch)=@_;return str_gt($self,$test)if$switch;for (@$self){return 1 if $_ lt $test}return}sub regex_eq {my ($self,$test,$switch)=@_;for (@$self){return 1 if $_ =~ $test}return}sub regex_ne {my ($self,$test,$switch)=@_;for (@$self){return 1 if $_ !~ $test}return}sub bool {my ($self)=@_;for (@$self){return 1 if $_}return}1;
SYNTAX_KEYWORD_JUNCTION_ANY

$fatpacked{"Syntax/Keyword/Junction/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION_BASE';
  package Syntax::Keyword::Junction::Base;use strict;use warnings;our$VERSION='0.003008';use overload('=='=>"num_eq",'!='=>"num_ne",'>='=>"num_ge",'>'=>"num_gt",'<='=>"num_le",'<'=>"num_lt",'eq'=>"str_eq",'ne'=>"str_ne",'ge'=>"str_ge",'gt'=>"str_gt",'le'=>"str_le",'lt'=>"str_lt",'bool'=>"bool",'""'=>sub {shift},$] >= 5.010001 ? ('~~'=>'match'): (),);sub new {bless \@_,shift}sub values {my$self=shift;return wantarray ? @$self : [@$self ]}sub map {my ($self,$code)=@_;my$class=ref$self;$class->new(map {$code->($_)}$self->values)}1;
SYNTAX_KEYWORD_JUNCTION_BASE

$fatpacked{"Syntax/Keyword/Junction/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION_NONE';
  package Syntax::Keyword::Junction::None;use strict;use warnings;our$VERSION='0.003008';use parent 'Syntax::Keyword::Junction::Base';BEGIN {if ($] >= 5.010001){eval q|
  sub match {
      no if $] > 5.017010, warnings => 'experimental::smartmatch';
      my ( $self, $other, $is_rhs ) = @_;
  
      if ($is_rhs) {
          for (@$self) {
              return if $other ~~ $_;
          }
  
          return 1;
      }
  
      for (@$self) {
          return if $_ ~~ $other;
      }
  
      return 1;
  }
  |}}sub num_eq {return regex_eq(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return if $_==$test}return 1}sub num_ne {return regex_ne(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;for (@$self){return if $_!=$test}return 1}sub num_ge {my ($self,$test,$switch)=@_;return num_le($self,$test)if$switch;for (@$self){return if $_ >= $test}return 1}sub num_gt {my ($self,$test,$switch)=@_;return num_lt($self,$test)if$switch;for (@$self){return if $_ > $test}return 1}sub num_le {my ($self,$test,$switch)=@_;return num_ge($self,$test)if$switch;for (@$self){return if $_ <= $test}return 1}sub num_lt {my ($self,$test,$switch)=@_;return num_gt($self,$test)if$switch;for (@$self){return if $_ < $test}return 1}sub str_eq {my ($self,$test)=@_;for (@$self){return if $_ eq $test}return 1}sub str_ne {my ($self,$test)=@_;for (@$self){return if $_ ne $test}return 1}sub str_ge {my ($self,$test,$switch)=@_;return str_le($self,$test)if$switch;for (@$self){return if $_ ge $test}return 1}sub str_gt {my ($self,$test,$switch)=@_;return str_lt($self,$test)if$switch;for (@$self){return if $_ gt $test}return 1}sub str_le {my ($self,$test,$switch)=@_;return str_ge($self,$test)if$switch;for (@$self){return if $_ le $test}return 1}sub str_lt {my ($self,$test,$switch)=@_;return str_gt($self,$test)if$switch;for (@$self){return if $_ lt $test}return 1}sub regex_eq {my ($self,$test,$switch)=@_;for (@$self){return if $_ =~ $test}return 1}sub regex_ne {my ($self,$test,$switch)=@_;for (@$self){return if $_ !~ $test}return 1}sub bool {my ($self)=@_;for (@$self){return if $_}return 1}1;
SYNTAX_KEYWORD_JUNCTION_NONE

$fatpacked{"Syntax/Keyword/Junction/One.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_JUNCTION_ONE';
  package Syntax::Keyword::Junction::One;use strict;use warnings;our$VERSION='0.003008';use parent 'Syntax::Keyword::Junction::Base';BEGIN {if ($] >= 5.010001){eval q|
  sub match {
      no if $] > 5.017010, warnings => 'experimental::smartmatch';
      my ( $self, $other, $is_rhs ) = @_;
  
      my $count = 0;
  
      if ($is_rhs) {
  
          for (@$self) {
              if ($other ~~ $_) {
                return if $count;
                $count = 1;
              }
          }
  
          return($count == 1);
      }
  
      for (@$self) {
          if ($_ ~~ $other) {
              return if $count;
              $count = 1;
          }
      }
  
      return($count == 1);
  }
  |}}sub num_eq {return regex_eq(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;my$count=0;for (@$self){if ($_==$test){return if$count;$count=1}}return 1 if$count}sub num_ne {return regex_ne(@_)if ref($_[1])eq 'Regexp';my ($self,$test)=@_;my$count=0;for (@$self){if ($_!=$test){return if$count;$count=1}}return 1 if$count}sub num_ge {my ($self,$test,$switch)=@_;return num_le($self,$test)if$switch;my$count=0;for (@$self){if ($_ >= $test){return if$count;$count=1}}return 1 if$count}sub num_gt {my ($self,$test,$switch)=@_;return num_lt($self,$test)if$switch;my$count=0;for (@$self){if ($_ > $test){return if$count;$count=1}}return 1 if$count}sub num_le {my ($self,$test,$switch)=@_;return num_ge($self,$test)if$switch;my$count=0;for (@$self){if ($_ <= $test){return if$count;$count=1}}return 1 if$count}sub num_lt {my ($self,$test,$switch)=@_;return num_gt($self,$test)if$switch;my$count=0;for (@$self){if ($_ < $test){return if$count;$count=1}}return 1 if$count}sub str_eq {my ($self,$test)=@_;my$count=0;for (@$self){if ($_ eq $test){return if$count;$count=1}}return 1 if$count}sub str_ne {my ($self,$test)=@_;my$count=0;for (@$self){if ($_ ne $test){return if$count;$count=1}}return 1 if$count}sub str_ge {my ($self,$test,$switch)=@_;return str_le($self,$test)if$switch;my$count=0;for (@$self){if ($_ ge $test){return if$count;$count=1}}return 1 if$count}sub str_gt {my ($self,$test,$switch)=@_;return str_lt($self,$test)if$switch;my$count=0;for (@$self){if ($_ gt $test){return if$count;$count=1}}return 1 if$count}sub str_le {my ($self,$test,$switch)=@_;return str_ge($self,$test)if$switch;my$count=0;for (@$self){if ($_ le $test){return if$count;$count=1}}return 1 if$count}sub str_lt {my ($self,$test,$switch)=@_;return str_gt($self,$test)if$switch;my$count=0;for (@$self){if ($_ lt $test){return if$count;$count=1}}return 1 if$count}sub regex_eq {my ($self,$test,$switch)=@_;my$count=0;for (@$self){if ($_ =~ $test){return if$count;$count=1}}return 1 if$count}sub regex_ne {my ($self,$test,$switch)=@_;my$count=0;for (@$self){if ($_ !~ $test){return if$count;$count=1}}return 1 if$count}sub bool {my ($self)=@_;my$count=0;for (@$self){if ($_){return if$count;$count=1}}return 1 if$count}1;
SYNTAX_KEYWORD_JUNCTION_ONE

$fatpacked{"TAP/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_BASE';
  package TAP::Base;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.33';use constant GOT_TIME_HIRES=>do {eval 'use Time::HiRes qw(time);';$@ ? 0 : 1};sub _initialize {my ($self,$arg_for,$ok_callback)=@_;my%ok_map=map {$_=>1}@$ok_callback;$self->{ok_callbacks}=\%ok_map;if (my$cb=delete$arg_for->{callbacks}){while (my ($event,$callback)=each %$cb){$self->callback($event,$callback)}}return$self}sub callback {my ($self,$event,$callback)=@_;my%ok_map=%{$self->{ok_callbacks}};$self->_croak('No callbacks may be installed')unless%ok_map;$self->_croak("Callback $event is not supported. Valid callbacks are " .join(', ',sort keys%ok_map))unless exists$ok_map{$event};push @{$self->{code_for}{$event}},$callback;return}sub _has_callbacks {my$self=shift;return keys %{$self->{code_for}}!=0}sub _callback_for {my ($self,$event)=@_;return$self->{code_for}{$event}}sub _make_callback {my$self=shift;my$event=shift;my$cb=$self->_callback_for($event);return unless defined$cb;return map {$_->(@_)}@$cb}sub get_time {return time()}sub time_is_hires {return GOT_TIME_HIRES}1;
TAP_BASE

$fatpacked{"TAP/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_BASE';
  package TAP::Formatter::Base;use strict;use warnings;use base 'TAP::Base';use POSIX qw(strftime);my$MAX_ERRORS=5;my%VALIDATION_FOR;BEGIN {%VALIDATION_FOR=(directives=>sub {shift;shift},verbosity=>sub {shift;shift},normalize=>sub {shift;shift},timer=>sub {shift;shift},failures=>sub {shift;shift},comments=>sub {shift;shift},errors=>sub {shift;shift},color=>sub {shift;shift},jobs=>sub {shift;shift},show_count=>sub {shift;shift},stdout=>sub {my ($self,$ref)=@_;$self->_croak("option 'stdout' needs a filehandle")unless$self->_is_filehandle($ref);return$ref},);sub _is_filehandle {my ($self,$ref)=@_;return 0 if!defined$ref;return 1 if ref$ref eq 'GLOB';return 1 if!ref$ref && ref \$ref eq 'GLOB';return 1 if eval {$ref->can('print')};return 0}my@getter_setters=qw(_longest _printed_summary_header _colorizer);__PACKAGE__->mk_methods(@getter_setters,keys%VALIDATION_FOR)}our$VERSION='3.33';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||={};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;$self->verbosity(0);for my$name (keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};$self->$name($self->$validate($property))}}if (my@props=keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}$self->stdout(\*STDOUT)unless$self->stdout;if ($self->color){require TAP::Formatter::Color;$self->_colorizer(TAP::Formatter::Color->new)}return$self}sub verbose {shift->verbosity >= 1}sub quiet {shift->verbosity <= -1}sub really_quiet {shift->verbosity <= -2}sub silent {shift->verbosity <= -3}sub prepare {my ($self,@tests)=@_;my$longest=0;for my$test (@tests){$longest=length$test if length$test > $longest}$self->_longest($longest)}sub _format_now {strftime "[%H:%M:%S]",localtime}sub _format_name {my ($self,$test)=@_;my$name=$test;my$periods='.' x ($self->_longest + 2 - length$test);$periods=" $periods ";if ($self->timer){my$stamp=$self->_format_now();return "$stamp $name$periods"}else {return "$name$periods"}}sub open_test {die "Unimplemented."}sub _output_success {my ($self,$msg)=@_;$self->_output($msg)}sub summary {my ($self,$aggregate,$interrupted)=@_;return if$self->silent;my@t=$aggregate->descriptions;my$tests=\@t;my$runtime=$aggregate->elapsed_timestr;my$total=$aggregate->total;my$passed=$aggregate->passed;if ($self->timer){$self->_output($self->_format_now(),"\n")}$self->_failure_output("Test run interrupted!\n")if$interrupted;if ($aggregate->all_passed){$self->_output_success("All tests successful.\n")}if ($total!=$passed or $aggregate->has_problems){$self->_output("\nTest Summary Report");$self->_output("\n-------------------\n");for my$test (@$tests){$self->_printed_summary_header(0);my ($parser)=$aggregate->parsers($test);$self->_output_summary_failure('failed',['  Failed test:  ','  Failed tests:  ' ],$test,$parser);$self->_output_summary_failure('todo_passed',"  TODO passed:   ",$test,$parser);if (my$exit=$parser->exit){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero exit status: $exit\n")}elsif (my$wait=$parser->wait){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero wait status: $wait\n")}if (my@errors=$parser->parse_errors){my$explain;if (@errors > $MAX_ERRORS &&!$self->errors){$explain ="Displayed the first $MAX_ERRORS of " .scalar(@errors)." TAP syntax errors.\n" ."Re-run prove with the -p option to see them all.\n";splice@errors,$MAX_ERRORS}$self->_summary_test_header($test,$parser);$self->_failure_output(sprintf "  Parse errors: %s\n",shift@errors);for my$error (@errors){my$spaces=' ' x 16;$self->_failure_output("$spaces$error\n")}$self->_failure_output($explain)if$explain}}}my$files=@$tests;$self->_output("Files=$files, Tests=$total, $runtime\n");my$status=$aggregate->get_status;$self->_output("Result: $status\n")}sub _output_summary_failure {my ($self,$method,$name,$test,$parser)=@_;my$output=$method eq 'failed' ? '_failure_output' : '_output';if (my@r=$parser->$method()){$self->_summary_test_header($test,$parser);my ($singular,$plural)='ARRAY' eq ref$name ? @$name : ($name,$name);$self->$output(@r==1 ? $singular : $plural);my@results=$self->_balanced_range(40,@r);$self->$output(sprintf "%s\n"=>shift@results);my$spaces=' ' x 16;while (@results){$self->$output(sprintf "$spaces%s\n"=>shift@results)}}}sub _summary_test_header {my ($self,$test,$parser)=@_;return if$self->_printed_summary_header;my$spaces=' ' x ($self->_longest - length$test);$spaces=' ' unless$spaces;my$output=$self->_get_output_method($parser);my$wait=$parser->wait;defined$wait or $wait='(none)';$self->$output(sprintf "$test$spaces(Wstat: %s Tests: %d Failed: %d)\n",$wait,$parser->tests_run,scalar$parser->failed);$self->_printed_summary_header(1)}sub _output {my$self=shift;print {$self->stdout}@_}sub _failure_output {my$self=shift;$self->_output(@_)}sub _balanced_range {my ($self,$limit,@range)=@_;@range=$self->_range(@range);my$line="";my@lines;my$curr=0;while (@range){if ($curr < $limit){my$range=(shift@range).", ";$line .= $range;$curr += length$range}elsif (@range){$line =~ s/, $//;push@lines=>$line;$line='';$curr=0}}if ($line){$line =~ s/, $//;push@lines=>$line}return@lines}sub _range {my ($self,@numbers)=@_;@numbers=sort {$a <=> $b}@numbers;my ($min,@range);for my$i (0 .. $#numbers){my$num=$numbers[$i];my$next=$numbers[$i + 1 ];if (defined$next && $next==$num + 1){if (!defined$min){$min=$num}}elsif (defined$min){push@range=>"$min-$num";undef$min}else {push@range=>$num}}return@range}sub _get_output_method {my ($self,$parser)=@_;return$parser->has_problems ? '_failure_output' : '_output'}1;
TAP_FORMATTER_BASE

$fatpacked{"TAP/Formatter/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_COLOR';
  package TAP::Formatter::Color;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use base 'TAP::Object';my$NO_COLOR;BEGIN {$NO_COLOR=0;if (IS_WIN32){eval 'use Win32::Console';if ($@){$NO_COLOR=$@}else {my$console=Win32::Console->new(STD_OUTPUT_HANDLE());my$fg=eval '$FG_LIGHTGRAY';my$bg=eval '$BG_BLACK';*set_color=sub {my ($self,$output,$color)=@_;my$var;if ($color eq 'reset'){$fg=eval '$FG_LIGHTGRAY';$bg=eval '$BG_BLACK'}elsif ($color =~ /^on_(.+)$/){$bg=eval '$BG_' .uc($1)}else {$fg=eval '$FG_' .uc($color)}$self->set_color('reset')unless defined$bg && defined$fg;$console->Attr($bg | $fg)}}}else {eval 'use Term::ANSIColor';if ($@){$NO_COLOR=$@}else {*set_color=sub {my ($self,$output,$color)=@_;$output->(color($color))}}}if ($NO_COLOR){*set_color=sub {}}}our$VERSION='3.33';sub _initialize {my$self=shift;if ($NO_COLOR){(my$error=$NO_COLOR)=~ s/ in \@INC .*//s;warn "Note: Cannot run tests in color: $error\n";return}return$self}sub can_color {return!$NO_COLOR}1;
TAP_FORMATTER_COLOR

$fatpacked{"TAP/Formatter/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE';
  package TAP::Formatter::Console;use strict;use warnings;use base 'TAP::Formatter::Base';use POSIX qw(strftime);our$VERSION='3.33';sub open_test {my ($self,$test,$parser)=@_;my$class =$self->jobs > 1 ? 'TAP::Formatter::Console::ParallelSession' : 'TAP::Formatter::Console::Session';eval "require $class";$self->_croak($@)if $@;my$session=$class->new({name=>$test,formatter=>$self,parser=>$parser,show_count=>$self->show_count,});$session->header;return$session}sub _set_colors {my ($self,@colors)=@_;if (my$colorizer=$self->_colorizer){my$output_func=$self->{_output_func}||=sub {$self->_output(@_)};$colorizer->set_color($output_func,$_)for@colors}}sub _failure_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_FAIL'}|| 'red'}sub _success_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_SUCCESS'}|| 'green'}sub _output_success {my ($self,$msg)=@_;$self->_set_colors($self->_success_color());$self->_output($msg);$self->_set_colors('reset')}sub _failure_output {my$self=shift;$self->_set_colors($self->_failure_color());my$out=join '',@_;my$has_newline=chomp$out;$self->_output($out);$self->_set_colors('reset');$self->_output($/)if$has_newline}1;
TAP_FORMATTER_CONSOLE

$fatpacked{"TAP/Formatter/Console/ParallelSession.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_PARALLELSESSION';
  package TAP::Formatter::Console::ParallelSession;use strict;use warnings;use File::Spec;use File::Path;use Carp;use base 'TAP::Formatter::Console::Session';use constant WIDTH=>72;my%shared;sub _initialize {my ($self,$arg_for)=@_;$self->SUPER::_initialize($arg_for);my$formatter=$self->formatter;my$context=$shared{$formatter}||=$self->_create_shared_context;push @{$context->{active}},$self;return$self}sub _create_shared_context {my$self=shift;return {active=>[],tests=>0,fails=>0,}}our$VERSION='3.33';sub header {}sub _clear_ruler {my$self=shift;$self->formatter->_output("\r" .(' ' x WIDTH)."\r")}my$now=0;my$start;my$trailer='... )===';my$chop_length=WIDTH - length$trailer;sub _output_ruler {my ($self,$refresh)=@_;my$new_now=time;return if$new_now==$now and!$refresh;$now=$new_now;$start ||=$now;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};my$ruler=sprintf '===( %7d;%d  ',$context->{tests},$now - $start;for my$active (@{$context->{active}}){my$parser=$active->parser;my$tests=$parser->tests_run;my$planned=$parser->tests_planned || '?';$ruler .= sprintf '%' .length($planned)."d/$planned  ",$tests}chop$ruler;$ruler .= ')===';if (length$ruler > WIDTH){$ruler =~ s/(.{$chop_length}).*/$1$trailer/o}else {$ruler .= '=' x (WIDTH - length($ruler))}$formatter->_output("\r$ruler")}sub result {my ($self,$result)=@_;my$formatter=$self->formatter;if ($result->is_test){my$context=$shared{$formatter};$context->{tests}++;my$active=$context->{active};if (@$active==1){return$self->SUPER::result($result)}$self->_output_ruler($self->parser->tests_run==1)}elsif ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}}sub clear_for_close {my$self=shift;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};if (@{$context->{active}}==1){$self->SUPER::clear_for_close}else {$self->_clear_ruler}}sub close_test {my$self=shift;my$name=$self->name;my$parser=$self->parser;my$formatter=$self->formatter;my$context=$shared{$formatter};$self->SUPER::close_test;my$active=$context->{active};my@pos=grep {$active->[$_]->name eq $name}0 .. $#$active;die "Can't find myself" unless@pos;splice @$active,$pos[0],1;if (@$active > 1){$self->_output_ruler(1)}elsif (@$active==1){$active->[0]->SUPER::header}else {delete$shared{$formatter}}}1;
TAP_FORMATTER_CONSOLE_PARALLELSESSION

$fatpacked{"TAP/Formatter/Console/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_SESSION';
  package TAP::Formatter::Console::Session;use strict;use warnings;use base 'TAP::Formatter::Session';my@ACCESSOR;BEGIN {my@CLOSURE_BINDING=qw(header result clear_for_close close_test);for my$method (@CLOSURE_BINDING){no strict 'refs';*$method=sub {my$self=shift;return ($self->{_closures}||=$self->_closures)->{$method}->(@_)}}}our$VERSION='3.33';sub _get_output_result {my$self=shift;my@color_map=({test=>sub {$_->is_test &&!$_->is_ok},colors=>['red'],},{test=>sub {$_->is_test && $_->has_skip},colors=>['white','on_blue' ],},{test=>sub {$_->is_test && $_->has_todo},colors=>['yellow'],},);my$formatter=$self->formatter;my$parser=$self->parser;return$formatter->_colorizer ? sub {my$result=shift;for my$col (@color_map){local $_=$result;if ($col->{test}->()){$formatter->_set_colors(@{$col->{colors}});last}}$formatter->_output($self->_format_for_output($result));$formatter->_set_colors('reset')}: sub {$formatter->_output($self->_format_for_output(shift))}}sub _closures {my$self=shift;my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);my$show_count=$self->show_count;my$really_quiet=$formatter->really_quiet;my$quiet=$formatter->quiet;my$verbose=$formatter->verbose;my$directives=$formatter->directives;my$failures=$formatter->failures;my$comments=$formatter->comments;my$output_result=$self->_get_output_result;my$output='_output';my$plan='';my$newline_printed=0;my$last_status_printed=0;return {header=>sub {$formatter->_output($pretty)unless$really_quiet},result=>sub {my$result=shift;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}return if$really_quiet;my$is_test=$result->is_test;if (!$plan){my$planned=$parser->tests_planned || '?';$plan="/$planned "}$output=$formatter->_get_output_method($parser);if ($show_count and $is_test){my$number=$result->number;my$now=CORE::time;if ($last_status_printed!=$now){$formatter->$output("\r$pretty$number$plan");$last_status_printed=$now}}if (!$quiet && ($verbose || ($is_test && $failures &&!$result->is_ok)|| ($comments && $result->is_comment)|| ($directives && $result->has_directive))){unless ($newline_printed){$formatter->_output("\n");$newline_printed=1}$output_result->($result);$formatter->_output("\n")}},clear_for_close=>sub {my$spaces =' ' x length('.' .$pretty .$plan .$parser->tests_run);$formatter->$output("\r$spaces")},close_test=>sub {if ($show_count &&!$really_quiet){$self->clear_for_close;$formatter->$output("\r$pretty")}$self->parser(undef);$self->{_closures}={};return if$really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output("skipped: $skip_all\n")}elsif ($parser->has_problems){$self->_output_test_failure($parser)}else {my$time_report='';if ($formatter->timer){my$start_time=$parser->start_time;my$end_time=$parser->end_time;if (defined$start_time and defined$end_time){my$elapsed=$end_time - $start_time;$time_report =$self->time_is_hires ? sprintf(' %8d ms',$elapsed * 1000): sprintf(' %8s s',$elapsed || '<1')}}$formatter->_output($self->_make_ok_line($time_report))}},}}1;
TAP_FORMATTER_CONSOLE_SESSION

$fatpacked{"TAP/Formatter/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE';
  package TAP::Formatter::File;use strict;use warnings;use TAP::Formatter::File::Session;use POSIX qw(strftime);use base 'TAP::Formatter::Base';our$VERSION='3.33';sub open_test {my ($self,$test,$parser)=@_;my$session=TAP::Formatter::File::Session->new({name=>$test,formatter=>$self,parser=>$parser,});$session->header;return$session}sub _should_show_count {return 0}1;
TAP_FORMATTER_FILE

$fatpacked{"TAP/Formatter/File/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE_SESSION';
  package TAP::Formatter::File::Session;use strict;use warnings;use base 'TAP::Formatter::Session';our$VERSION='3.33';sub result {my$self=shift;my$result=shift;my$parser=$self->parser;my$formatter=$self->formatter;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n");return}if (!$formatter->quiet && ($formatter->verbose || ($result->is_test && $formatter->failures &&!$result->is_ok)|| ($formatter->comments && $result->is_comment)|| ($result->has_directive && $formatter->directives))){$self->{results}.= $self->_format_for_output($result)."\n"}}sub close_test {my$self=shift;$self->parser(undef);my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);return if$formatter->really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output($pretty ."skipped: $skip_all\n")}elsif ($parser->has_problems){$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "\n"));$self->_output_test_failure($parser)}else {my$time_report='';if ($formatter->timer){my$start_time=$parser->start_time;my$end_time=$parser->end_time;if (defined$start_time and defined$end_time){my$elapsed=$end_time - $start_time;$time_report =$self->time_is_hires ? sprintf(' %8d ms',$elapsed * 1000): sprintf(' %8s s',$elapsed || '<1')}}$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "").$self->_make_ok_line($time_report))}}1;
TAP_FORMATTER_FILE_SESSION

$fatpacked{"TAP/Formatter/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_SESSION';
  package TAP::Formatter::Session;use strict;use warnings;use base 'TAP::Base';my@ACCESSOR;BEGIN {@ACCESSOR=qw(name formatter parser show_count);for my$method (@ACCESSOR){no strict 'refs';*$method=sub {shift->{$method}}}}our$VERSION='3.33';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||={};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;for my$name (@ACCESSOR){$self->{$name}=delete$arg_for{$name}}if (!defined$self->show_count){$self->{show_count}=1}if ($self->show_count){$self->{show_count}=$self->_should_show_count}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}return$self}sub header {}sub result {}sub close_test {}sub clear_for_close {}sub _should_show_count {my$self=shift;return !$self->formatter->verbose && -t $self->formatter->stdout &&!$ENV{HARNESS_NOTTY}}sub _format_for_output {my ($self,$result)=@_;return$self->formatter->normalize ? $result->as_string : $result->raw}sub _output_test_failure {my ($self,$parser)=@_;my$formatter=$self->formatter;return if$formatter->really_quiet;my$tests_run=$parser->tests_run;my$tests_planned=$parser->tests_planned;my$total =defined$tests_planned ? $tests_planned : $tests_run;my$passed=$parser->passed;my$failed=$parser->failed + $total - $tests_run;my$exit=$parser->exit;if (my$exit=$parser->exit){my$wstat=$parser->wait;my$status=sprintf("%d (wstat %d, 0x%x)",$exit,$wstat,$wstat);$formatter->_failure_output("Dubious, test returned $status\n")}if ($failed==0){$formatter->_failure_output($total ? "All $total subtests passed " : 'No subtests run ')}else {$formatter->_failure_output("Failed $failed/$total subtests ");if (!$total){$formatter->_failure_output("\nNo tests run!")}}if (my$skipped=$parser->skipped){$passed -= $skipped;my$test='subtest' .($skipped!=1 ? 's' : '');$formatter->_output("\n\t(less $skipped skipped $test: $passed okay)")}if (my$failed=$parser->todo_passed){my$test=$failed > 1 ? 'tests' : 'test';$formatter->_output("\n\t($failed TODO $test unexpectedly succeeded)")}$formatter->_output("\n")}sub _make_ok_line {my ($self,$suffix)=@_;return "ok$suffix\n"}1;
TAP_FORMATTER_SESSION

$fatpacked{"TAP/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS';
  package TAP::Harness;use strict;use warnings;use Carp;use File::Spec;use File::Path;use IO::Handle;use base 'TAP::Base';our$VERSION='3.33';$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}my%VALIDATION_FOR;my@FORMATTER_ARGS;sub _error {my$self=shift;return$self->{error}unless @_;$self->{error}=shift}BEGIN {@FORMATTER_ARGS=qw(directives verbosity timer failures comments errors stdout color show_count normalize);%VALIDATION_FOR=(lib=>sub {my ($self,$libs)=@_;$libs=[$libs]unless 'ARRAY' eq ref$libs;return [map {"-I$_"}@$libs ]},switches=>sub {shift;shift},exec=>sub {shift;shift},merge=>sub {shift;shift},aggregator_class=>sub {shift;shift},formatter_class=>sub {shift;shift},multiplexer_class=>sub {shift;shift},parser_class=>sub {shift;shift},scheduler_class=>sub {shift;shift},formatter=>sub {shift;shift},jobs=>sub {shift;shift},test_args=>sub {shift;shift},ignore_exit=>sub {shift;shift},rules=>sub {shift;shift},rulesfile=>sub {shift;shift},sources=>sub {shift;shift},version=>sub {shift;shift},trap=>sub {shift;shift},);for my$method (sort keys%VALIDATION_FOR){no strict 'refs';if ($method eq 'lib' || $method eq 'switches'){*{$method}=sub {my$self=shift;unless (@_){$self->{$method}||=[];return wantarray ? @{$self->{$method}}: $self->{$method}}$self->_croak("Too many arguments to method '$method'")if @_ > 1;my$args=shift;$args=[$args]unless ref$args;$self->{$method}=$args;return$self}}else {*{$method}=sub {my$self=shift;return$self->{$method}unless @_;$self->{$method}=shift}}}for my$method (@FORMATTER_ARGS){no strict 'refs';*{$method}=sub {my$self=shift;return$self->formatter->$method(@_)}}}{my@legal_callback=qw(parser_args made_parser before_runtests after_runtests after_test);my%default_class=(aggregator_class=>'TAP::Parser::Aggregator',formatter_class=>'TAP::Formatter::Console',multiplexer_class=>'TAP::Parser::Multiplexer',parser_class=>'TAP::Parser',scheduler_class=>'TAP::Parser::Scheduler',);sub _initialize {my ($self,$arg_for)=@_;$arg_for ||={};$self->SUPER::_initialize($arg_for,\@legal_callback);my%arg_for=%$arg_for;for my$name (sort keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};my$value=$self->$validate($property);if ($self->_error){$self->_croak}$self->$name($value)}}$self->jobs(1)unless defined$self->jobs;if (!defined$self->rules){$self->_maybe_load_rulesfile}local$default_class{formatter_class}='TAP::Formatter::File' unless -t ($arg_for{stdout}|| \*STDOUT)&&!$ENV{HARNESS_NOTTY};while (my ($attr,$class)=each%default_class){$self->$attr($self->$attr()|| $class)}unless ($self->formatter){my%formatter_args=(jobs=>$self->jobs);for my$name (@FORMATTER_ARGS){if (defined(my$property=delete$arg_for{$name})){$formatter_args{$name}=$property}}$self->formatter($self->_construct($self->formatter_class,\%formatter_args))}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to TAP::Harness::new (@props)")}return$self}sub _maybe_load_rulesfile {my ($self)=@_;my ($rulesfile)=defined$self->rulesfile ? $self->rulesfile : defined($ENV{HARNESS_RULESFILE})? $ENV{HARNESS_RULESFILE}: grep {-r}qw(./testrules.yml t/testrules.yml);if (defined$rulesfile && -r $rulesfile){if (!eval {require CPAN::Meta::YAML;1}){warn "CPAN::Meta::YAML required to process $rulesfile" ;return}my$layer=$] lt "5.008" ? "" : ":encoding(UTF-8)";open my$fh,"<$layer",$rulesfile or die "Couldn't open $rulesfile: $!";my$yaml_text=do {local $/;<$fh>};my$yaml=CPAN::Meta::YAML->read_string($yaml_text)or die CPAN::Meta::YAML->errstr;$self->rules($yaml->[0])}return}}sub runtests {my ($self,@tests)=@_;my$aggregate=$self->_construct($self->aggregator_class);$self->_make_callback('before_runtests',$aggregate);$aggregate->start;my$finish=sub {my$interrupted=shift;$aggregate->stop;$self->summary($aggregate,$interrupted);$self->_make_callback('after_runtests',$aggregate)};my$run=sub {$self->aggregate_tests($aggregate,@tests);$finish->()};if ($self->trap){local$SIG{INT}=sub {print "\n";$finish->(1);exit};$run->()}else {$run->()}return$aggregate}sub summary {my ($self,@args)=@_;$self->formatter->summary(@args)}sub _after_test {my ($self,$aggregate,$job,$parser)=@_;$self->_make_callback('after_test',$job->as_array_ref,$parser);$aggregate->add($job->description,$parser)}sub _bailout {my ($self,$result)=@_;my$explanation=$result->explanation;die "FAILED--Further testing stopped" .($explanation ? ": $explanation\n" : ".\n")}sub _aggregate_parallel {my ($self,$aggregate,$scheduler)=@_;my$jobs=$self->jobs;my$mux=$self->_construct($self->multiplexer_class);RESULT: {FILL: while ($mux->parsers < $jobs){my$job=$scheduler->get_job;last FILL if!defined$job || $job->is_spinner;my ($parser,$session)=$self->make_parser($job);$mux->add($parser,[$session,$job ])}if (my ($parser,$stash,$result)=$mux->next){my ($session,$job)=@$stash;if (defined$result){$session->result($result);$self->_bailout($result)if$result->is_bailout}else {$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}redo RESULT}}return}sub _aggregate_single {my ($self,$aggregate,$scheduler)=@_;JOB: while (my$job=$scheduler->get_job){next JOB if$job->is_spinner;my ($parser,$session)=$self->make_parser($job);while (defined(my$result=$parser->next)){$session->result($result);if ($result->is_bailout){1 while$parser->next;$self->_bailout($result)}}$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}return}sub aggregate_tests {my ($self,$aggregate,@tests)=@_;my$jobs=$self->jobs;my$scheduler=$self->make_scheduler(@tests);local$ENV{HARNESS_IS_VERBOSE}=1 if$self->formatter->verbosity > 0;$self->formatter->prepare(map {$_->description}$scheduler->get_all);if ($self->jobs > 1){$self->_aggregate_parallel($aggregate,$scheduler)}else {$self->_aggregate_single($aggregate,$scheduler)}return}sub _add_descriptions {my$self=shift;return map {@$_==1 ? [$_->[0],$_->[0]]: $_}map {'ARRAY' eq ref $_ ? $_ : [$_]}@_}sub make_scheduler {my ($self,@tests)=@_;return$self->_construct($self->scheduler_class,tests=>[$self->_add_descriptions(@tests)],rules=>$self->rules)}sub _get_parser_args {my ($self,$job)=@_;my$test_prog=$job->filename;my%args=();$args{sources}=$self->sources if$self->sources;my@switches;@switches=$self->lib if$self->lib;push@switches=>$self->switches if$self->switches;$args{switches}=\@switches;$args{spool}=$self->_open_spool($test_prog);$args{merge}=$self->merge;$args{ignore_exit}=$self->ignore_exit;$args{version}=$self->version if$self->version;if (my$exec=$self->exec){$args{exec}=ref$exec eq 'CODE' ? $exec->($self,$test_prog): [@$exec,$test_prog ];if (not defined$args{exec}){$args{source}=$test_prog}elsif ((ref($args{exec})|| "")ne "ARRAY"){$args{source}=delete$args{exec}}}else {$args{source}=$test_prog}if (defined(my$test_args=$self->test_args)){if (ref($test_args)eq 'HASH'){if (exists($test_args->{$job->description })){$test_args=$test_args->{$job->description }}else {$self->_croak("TAP::Harness Can't find test_args for " .$job->description)}}$args{test_args}=$test_args}return \%args}sub make_parser {my ($self,$job)=@_;my$args=$self->_get_parser_args($job);$self->_make_callback('parser_args',$args,$job->as_array_ref);my$parser=$self->_construct($self->parser_class,$args);$self->_make_callback('made_parser',$parser,$job->as_array_ref);my$session=$self->formatter->open_test($job->description,$parser);return ($parser,$session)}sub finish_parser {my ($self,$parser,$session)=@_;$session->close_test;$self->_close_spool($parser);return$parser}sub _open_spool {my$self=shift;my$test=shift;if (my$spool_dir=$ENV{PERL_TEST_HARNESS_DUMP_TAP}){my$spool=File::Spec->catfile($spool_dir,$test);my ($vol,$dir,undef)=File::Spec->splitpath($spool);my$path=File::Spec->catpath($vol,$dir,'');eval {mkpath($path)};$self->_croak($@)if $@;my$spool_handle=IO::Handle->new;open($spool_handle,">$spool")or $self->_croak(" Can't write $spool ( $! ) ");return$spool_handle}return}sub _close_spool {my$self=shift;my ($parser)=@_;if (my$spool_handle=$parser->delete_spool){close($spool_handle)or $self->_croak(" Error closing TAP spool file( $! ) \n ")}return}sub _croak {my ($self,$message)=@_;unless ($message){$message=$self->_error}$self->SUPER::_croak($message);return}1;
TAP_HARNESS

$fatpacked{"TAP/Harness/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS_ENV';
  package TAP::Harness::Env;use strict;use warnings;use constant IS_VMS=>($^O eq 'VMS');use TAP::Object;use Text::ParseWords qw/shellwords/;our$VERSION='3.33';sub _filtered_inc_vms {my@inc=grep {!ref}@INC;@inc=grep {!/perl_root/i}@inc;my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}sub create {my$package=shift;my%input=%{shift || {}};my@libs=@{delete$input{libs}|| []};my@raw_switches=@{delete$input{switches}|| []};my@opt =(@raw_switches,shellwords($ENV{HARNESS_PERL_SWITCHES}|| ''));my@switches;while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@libs,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@libs,_filtered_inc_vms()if IS_VMS;my$verbose =$ENV{HARNESS_VERBOSE}? $ENV{HARNESS_VERBOSE}!~ /\d/ ? 1 : $ENV{HARNESS_VERBOSE}: 0;my%args=(lib=>\@libs,timer=>$ENV{HARNESS_TIMER}|| 0,switches=>\@switches,color=>$ENV{HARNESS_COLOR}|| 0,verbosity=>$verbose,ignore_exit=>$ENV{HARNESS_IGNORE_EXIT}|| 0,);my$class=delete$input{harness_class}|| $ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args{jobs}=$1 || 9}elsif ($opt eq 'c'){$args{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class='TAP::Harness::Archive';$args{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Object->_construct($class,{%args,%input })}1;
TAP_HARNESS_ENV

$fatpacked{"TAP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_OBJECT';
  package TAP::Object;use strict;use warnings;our$VERSION='3.33';sub new {my$class=shift;my$self=bless {},$class;return$self->_initialize(@_)}sub _initialize {return $_[0]}sub _croak {my$proto=shift;require Carp;Carp::croak(@_);return}sub _confess {my$proto=shift;require Carp;Carp::confess(@_);return}sub _construct {my ($self,$class,@args)=@_;$self->_croak("Bad module name $class")unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;unless ($class->can('new')){local $@;eval "require $class";$self->_croak("Can't load $class: $@")if $@}return$class->new(@args)}sub mk_methods {my ($class,@methods)=@_;for my$method_name (@methods){my$method="${class}::$method_name";no strict 'refs';*$method=sub {my$self=shift;$self->{$method_name}=shift if @_;return$self->{$method_name}}}}1;
TAP_OBJECT

$fatpacked{"TAP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER';
  package TAP::Parser;use strict;use warnings;use TAP::Parser::Grammar ();use TAP::Parser::Result ();use TAP::Parser::ResultFactory ();use TAP::Parser::Source ();use TAP::Parser::Iterator ();use TAP::Parser::IteratorFactory ();use TAP::Parser::SourceHandler::Executable ();use TAP::Parser::SourceHandler::Perl ();use TAP::Parser::SourceHandler::File ();use TAP::Parser::SourceHandler::RawTAP ();use TAP::Parser::SourceHandler::Handle ();use Carp qw(confess);use base 'TAP::Base';our$VERSION='3.33';my$DEFAULT_TAP_VERSION=12;my$MAX_TAP_VERSION=13;$ENV{TAP_VERSION}=$MAX_TAP_VERSION;END {delete$ENV{TAP_VERSION}}BEGIN {__PACKAGE__->mk_methods(qw(_iterator _spool exec exit is_good_plan plan tests_planned tests_run wait version in_todo start_time end_time skip_all grammar_class result_factory_class iterator_factory_class));sub _stream {my$self=shift;$self->_iterator(@_)}}sub _default_grammar_class {'TAP::Parser::Grammar'}sub _default_result_factory_class {'TAP::Parser::ResultFactory'}sub _default_iterator_factory_class {'TAP::Parser::IteratorFactory'}sub next {my$self=shift;return ($self->{_iter}||=$self->_iter)->()}sub run {my$self=shift;while (defined(my$result=$self->next)){}}sub make_iterator_factory {shift->iterator_factory_class->new(@_)}sub make_grammar {shift->grammar_class->new(@_)}sub make_result {shift->result_factory_class->make_result(@_)}{my%initialize=(version=>$DEFAULT_TAP_VERSION,plan=>'',tests_run=>0,skipped=>[],todo=>[],passed=>[],failed=>[],actual_failed=>[],actual_passed=>[],todo_passed=>[],parse_errors=>[],);my@legal_callback=qw(test version plan comment bailout unknown yaml ALL ELSE EOF);my@class_overrides=qw(grammar_class result_factory_class iterator_factory_class);sub _initialize {my ($self,$arg_for)=@_;my%args=%{$arg_for || {}};$self->SUPER::_initialize(\%args,\@legal_callback);for my$key (@class_overrides){my$default_method="_default_$key";my$val=delete$args{$key}|| $self->$default_method();$self->$key($val)}my$iterator=delete$args{iterator};$iterator ||=delete$args{stream};my$tap=delete$args{tap};my$version=delete$args{version};my$raw_source=delete$args{source};my$sources=delete$args{sources};my$exec=delete$args{exec};my$merge=delete$args{merge};my$spool=delete$args{spool};my$switches=delete$args{switches};my$ignore_exit=delete$args{ignore_exit};my$test_args=delete$args{test_args}|| [];if (1 < grep {defined}$iterator,$tap,$raw_source,$exec){$self->_croak("You may only choose one of 'exec', 'tap', 'source' or 'iterator'")}if (my@excess=sort keys%args){$self->_croak("Unknown options: @excess")}my$type='';my$source=TAP::Parser::Source->new;if ($tap){$type='raw TAP';$source->raw(\$tap)}elsif ($exec){$type='exec ' .$exec->[0];$source->raw({exec=>$exec })}elsif ($raw_source){$type='source ' .ref($raw_source)|| $raw_source;$source->raw(ref($raw_source)? $raw_source : \$raw_source)}elsif ($iterator){$type='iterator ' .ref($iterator)}if ($source->raw){my$src_factory=$self->make_iterator_factory($sources);$source->merge($merge)->switches($switches)->test_args($test_args);$iterator=$src_factory->make_iterator($source)}unless ($iterator){$self->_croak("PANIC: could not determine iterator for input $type")}while (my ($k,$v)=each%initialize){$self->{$k}='ARRAY' eq ref$v ? []: $v}$self->version($version)if$version;$self->_iterator($iterator);$self->_spool($spool);$self->ignore_exit($ignore_exit);return$self}}sub passed {return @{$_[0]->{passed}}if ref $_[0]->{passed};return wantarray ? 1 .. $_[0]->{passed}: $_[0]->{passed}}sub failed {@{shift->{failed}}}sub actual_passed {return @{$_[0]->{actual_passed}}if ref $_[0]->{actual_passed};return wantarray ? 1 .. $_[0]->{actual_passed}: $_[0]->{actual_passed}}*actual_ok=\&actual_passed;sub actual_failed {@{shift->{actual_failed}}}sub todo {@{shift->{todo}}}sub todo_passed {@{shift->{todo_passed}}}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}sub skipped {@{shift->{skipped}}}sub pragma {my ($self,$pragma)=splice @_,0,2;return$self->{pragma}->{$pragma}unless @_;if (my$state=shift){$self->{pragma}->{$pragma}=1}else {delete$self->{pragma}->{$pragma}}return}sub pragmas {sort keys %{shift->{pragma}|| {}}}sub good_plan {warn 'good_plan() is deprecated.  Please use "is_good_plan()"';goto&is_good_plan}sub has_problems {my$self=shift;return $self->failed || $self->parse_errors || (!$self->ignore_exit && ($self->wait || $self->exit))}sub ignore_exit {shift->pragma('ignore_exit',@_)}sub parse_errors {@{shift->{parse_errors}}}sub _add_error {my ($self,$error)=@_;push @{$self->{parse_errors}}=>$error;return$self}sub _make_state_table {my$self=shift;my%states;my%planned_todo=();my%state_globals=(comment=>{},bailout=>{},yaml=>{},version=>{act=>sub {$self->_add_error('If TAP version is present it must be the first line of output')},},unknown=>{act=>sub {my$unk=shift;if ($self->pragma('strict')){$self->_add_error('Unknown TAP token: "' .$unk->raw .'"')}},},pragma=>{act=>sub {my ($pragma)=@_;for my$pr ($pragma->pragmas){if ($pr =~ /^ ([-+])(\w+) $/x){$self->pragma($2,$1 eq '+')}}},},);my%state_defaults=(plan=>{act=>sub {my ($plan)=@_;$self->tests_planned($plan->tests_planned);$self->plan($plan->plan);if ($plan->has_skip){$self->skip_all($plan->explanation || '(no reason given)')}$planned_todo{$_}++ for @{$plan->todo_list}},},test=>{act=>sub {my ($test)=@_;my ($number,$tests_run)=($test->number,++$self->{tests_run});if (defined$number && delete$planned_todo{$number}){$test->set_directive('TODO')}my$has_todo=$test->has_todo;$self->in_todo($has_todo);if (defined(my$tests_planned=$self->tests_planned)){if ($tests_run > $tests_planned){$test->is_unplanned(1)}}if (defined$number){if ($number!=$tests_run){my$count=$tests_run;$self->_add_error("Tests out of sequence.  Found " ."($number) but expected ($count)")}}else {$test->_number($number=$tests_run)}push @{$self->{todo}}=>$number if$has_todo;push @{$self->{todo_passed}}=>$number if$test->todo_passed;push @{$self->{skipped}}=>$number if$test->has_skip;push @{$self->{$test->is_ok ? 'passed' : 'failed' }}=>$number;push @{$self->{$test->is_actual_ok ? 'actual_passed' : 'actual_failed' }}=>$number},},yaml=>{act=>sub {},},);%states=(INIT=>{version=>{act=>sub {my ($version)=@_;my$ver_num=$version->version;if ($ver_num <= $DEFAULT_TAP_VERSION){my$ver_min=$DEFAULT_TAP_VERSION + 1;$self->_add_error("Explicit TAP version must be at least " ."$ver_min. Got version $ver_num");$ver_num=$DEFAULT_TAP_VERSION}if ($ver_num > $MAX_TAP_VERSION){$self->_add_error("TAP specified version $ver_num but " ."we don't know about versions later " ."than $MAX_TAP_VERSION");$ver_num=$MAX_TAP_VERSION}$self->version($ver_num);$self->_grammar->set_version($ver_num)},goto=>'PLAN' },plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLAN=>{plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLANNED=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {my ($version)=@_;$self->_add_error('More than one plan found in TAP output')},},},PLANNED_AFTER_TEST=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {},continue=>'PLANNED' },yaml=>{goto=>'PLANNED' },},GOT_PLAN=>{test=>{act=>sub {my ($plan)=@_;my$line=$self->plan;$self->_add_error("Plan ($line) must be at the beginning " ."or end of the TAP output");$self->is_good_plan(0)},continue=>'PLANNED' },plan=>{continue=>'PLANNED' },},UNPLANNED=>{test=>{goto=>'UNPLANNED_AFTER_TEST' },plan=>{goto=>'GOT_PLAN' },},UNPLANNED_AFTER_TEST=>{test=>{act=>sub {},continue=>'UNPLANNED' },plan=>{act=>sub {},continue=>'UNPLANNED' },yaml=>{goto=>'UNPLANNED' },},);for my$name (keys%states){my$st={%state_globals,%{$states{$name}}};for my$next (sort keys %{$st}){if (my$default=$state_defaults{$next}){for my$def (sort keys %{$default}){$st->{$next}->{$def}||=$default->{$def}}}}$states{$name}=$st}return \%states}sub get_select_handles {shift->_iterator->get_select_handles}sub _grammar {my$self=shift;return$self->{_grammar}=shift if @_;return$self->{_grammar}||=$self->make_grammar({iterator=>$self->_iterator,parser=>$self,version=>$self->version })}sub _iter {my$self=shift;my$iterator=$self->_iterator;my$grammar=$self->_grammar;my$spool=$self->_spool;my$state='INIT';my$state_table=$self->_make_state_table;$self->start_time($self->get_time);my$next_state=sub {my$token=shift;my$type=$token->type;TRANS: {my$state_spec=$state_table->{$state}or die "Illegal state: $state";if (my$next=$state_spec->{$type}){if (my$act=$next->{act}){$act->($token)}if (my$cont=$next->{continue}){$state=$cont;redo TRANS}elsif (my$goto=$next->{goto}){$state=$goto}}else {confess("Unhandled token type: $type\n")}}return$token};my$end_handler=sub {$self->exit($iterator->exit);$self->wait($iterator->wait);$self->_finish;return};if ($self->_has_callbacks){return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);if (my$code=$self->_callback_for($result->type)){$_->($result)for @{$code}}else {$self->_make_callback('ELSE',$result)}$self->_make_callback('ALL',$result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->();$self->_make_callback('EOF',$self)unless defined$result}return$result}}else {return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->()}return$result}}}sub _finish {my$self=shift;$self->end_time($self->get_time);$self->_iterator(undef);$self->_grammar(undef);$self->{_iter}=sub {return}if $] >= 5.006;if (!$self->plan){$self->_add_error('No plan found in TAP output')}else {$self->is_good_plan(1)unless defined$self->is_good_plan}if ($self->tests_run!=($self->tests_planned || 0)){$self->is_good_plan(0);if (defined(my$planned=$self->tests_planned)){my$ran=$self->tests_run;$self->_add_error("Bad plan.  You planned $planned tests but ran $ran.")}}if ($self->tests_run!=($self->passed + $self->failed)){my$actual=$self->tests_run;my$passed=$self->passed;my$failed=$self->failed;$self->_croak("Panic: planned test count ($actual) did not equal " ."sum of passed ($passed) and failed ($failed) tests!")}$self->is_good_plan(0)unless defined$self->is_good_plan;unless ($self->parse_errors){if ($self->tests_run==@{$self->{passed}}){$self->{passed}=$self->tests_run}if ($self->tests_run==@{$self->{actual_passed}}){$self->{actual_passed}=$self->tests_run}}return$self}sub delete_spool {my$self=shift;return delete$self->{_spool}}1;
TAP_PARSER

$fatpacked{"TAP/Parser/Aggregator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_AGGREGATOR';
  package TAP::Parser::Aggregator;use strict;use warnings;use Benchmark;use base 'TAP::Object';our$VERSION='3.33';my%SUMMARY_METHOD_FOR;BEGIN {%SUMMARY_METHOD_FOR=map {$_=>$_}qw(failed parse_errors passed skipped todo todo_passed total wait exit);$SUMMARY_METHOD_FOR{total}='tests_run';$SUMMARY_METHOD_FOR{planned}='tests_planned';for my$method (keys%SUMMARY_METHOD_FOR){next if 'total' eq $method;no strict 'refs';*$method=sub {my$self=shift;return wantarray ? @{$self->{"descriptions_for_$method"}}: $self->{$method}}}}sub _initialize {my ($self)=@_;$self->{parser_for}={};$self->{parse_order}=[];for my$summary (keys%SUMMARY_METHOD_FOR){$self->{$summary}=0;next if 'total' eq $summary;$self->{"descriptions_for_$summary"}=[]}return$self}sub add {my ($self,$description,$parser)=@_;if (exists$self->{parser_for}{$description}){$self->_croak("You already have a parser for ($description)." ." Perhaps you have run the same test twice.")}push @{$self->{parse_order}}=>$description;$self->{parser_for}{$description}=$parser;while (my ($summary,$method)=each%SUMMARY_METHOD_FOR){next if ($method eq 'exit' || $method eq 'wait')&& $parser->ignore_exit;if (my$count=$parser->$method()){$self->{$summary}+= $count;push @{$self->{"descriptions_for_$summary"}}=>$description}}return$self}sub parsers {my$self=shift;return$self->_get_parsers(@_)if @_;my$descriptions=$self->{parse_order};my@parsers=@{$self->{parser_for}}{@$descriptions};return@parsers}sub _get_parsers {my ($self,@descriptions)=@_;my@parsers;for my$description (@descriptions){$self->_croak("A parser for ($description) could not be found")unless exists$self->{parser_for}{$description};push@parsers=>$self->{parser_for}{$description}}return wantarray ? @parsers : \@parsers}sub descriptions {@{shift->{parse_order}|| []}}sub start {my$self=shift;$self->{start_time}=Benchmark->new}sub stop {my$self=shift;$self->{end_time}=Benchmark->new}sub elapsed {my$self=shift;require Carp;Carp::croak q{Can't call elapsed without first calling start and then stop} unless defined$self->{start_time}&& defined$self->{end_time};return timediff($self->{end_time},$self->{start_time})}sub elapsed_timestr {my$self=shift;my$elapsed=$self->elapsed;return timestr($elapsed)}sub all_passed {my$self=shift;return $self->total && $self->total==$self->passed &&!$self->has_errors}sub get_status {my$self=shift;my$total=$self->total;my$passed=$self->passed;return ($self->has_errors || $total!=$passed)? 'FAIL' : $total ? 'PASS' : 'NOTESTS'}sub total {shift->{total}}sub has_problems {my$self=shift;return$self->todo_passed || $self->has_errors}sub has_errors {my$self=shift;return $self->failed || $self->parse_errors || $self->exit || $self->wait}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}1;
TAP_PARSER_AGGREGATOR

$fatpacked{"TAP/Parser/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_GRAMMAR';
  package TAP::Parser::Grammar;use strict;use warnings;use TAP::Parser::ResultFactory ();use TAP::Parser::YAMLish::Reader ();use base 'TAP::Object';our$VERSION='3.33';sub _initialize {my ($self,$args)=@_;$self->{iterator}=$args->{iterator};$self->{iterator}||=$args->{stream};$self->{parser}=$args->{parser};$self->set_version($args->{version}|| 12);return$self}my%language_for;{my$ok=qr/(?:not )?ok\b/;my$num=qr/\d+/;my%v12=(version=>{syntax=>qr/^TAP\s+version\s+(\d+)\s*\z/i,handler=>sub {my ($self,$line)=@_;my$version=$1;return$self->_make_version_token($line,$version,)},},plan=>{syntax=>qr/^1\.\.(\d+)\s*(.*)\z/,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$tail)=($1,$2);my$explanation=undef;my$skip='';if ($tail =~ /^todo((?:\s+\d+)+)/){my@todo=split /\s+/,_trim($1);return$self->_make_plan_token($line,$tests_planned,'TODO','',\@todo)}elsif (0==$tests_planned){$skip='SKIP';($explanation)=$tail =~ /^#\s*SKIP\S*\s+(.*)/i}elsif ($tail !~ /^\s*$/){return$self->_make_unknown_token($line)}$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},simple_test=>{syntax=>qr/^($ok) \ ($num) (?:\ ([^#]+))? \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);return$self->_make_test_token($line,$ok,$num,$desc)},},test=>{syntax=>qr/^($ok) \s* ($num)? \s* (.*) \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);my ($dir,$explanation)=('','');if ($desc =~ m/^ ( [^\\\#]* (?: \\. [^\\\#]* )* )
                         \# \s* (SKIP|TODO) \b \s* (.*) $/ix){($desc,$dir,$explanation)=($1,$2,$3)}return$self->_make_test_token($line,$ok,$num,$desc,$dir,$explanation)},},comment=>{syntax=>qr/^#(.*)/,handler=>sub {my ($self,$line)=@_;my$comment=$1;return$self->_make_comment_token($line,$comment)},},bailout=>{syntax=>qr/^\s*Bail out!\s*(.*)/,handler=>sub {my ($self,$line)=@_;my$explanation=$1;return$self->_make_bailout_token($line,$explanation)},},);my%v13=(%v12,plan=>{syntax=>qr/^1\.\.(\d+)(?:\s*#\s*SKIP\b(.*))?\z/i,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$explanation)=($1,$2);my$skip =(0==$tests_planned || defined$explanation)? 'SKIP' : '';$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},yaml=>{syntax=>qr/^ (\s+) (---.*) $/x,handler=>sub {my ($self,$line)=@_;my ($pad,$marker)=($1,$2);return$self->_make_yaml_token($pad,$marker)},},pragma=>{syntax=>qr/^ pragma \s+ ( [-+] \w+ \s* (?: , \s* [-+] \w+ \s* )* ) $/x,handler=>sub {my ($self,$line)=@_;my$pragmas=$1;return$self->_make_pragma_token($line,$pragmas)},},);%language_for=('12'=>{tokens=>\%v12,},'13'=>{tokens=>\%v13,setup=>sub {shift->{iterator}->handle_unicode},},)}sub set_version {my$self=shift;my$version=shift;if (my$language=$language_for{$version}){$self->{version}=$version;$self->{tokens}=$language->{tokens};if (my$setup=$language->{setup}){$self->$setup()}$self->_order_tokens}else {require Carp;Carp::croak("Unsupported syntax version: $version")}}sub _order_tokens {my$self=shift;my%copy=%{$self->{tokens}};my@ordered_tokens=grep {defined}map {delete$copy{$_}}qw(simple_test test comment plan);push@ordered_tokens,values%copy;$self->{ordered_tokens}=\@ordered_tokens}sub tokenize {my$self=shift;my$line=$self->{iterator}->next;unless (defined$line){delete$self->{parser};return}my$token;for my$token_data (@{$self->{ordered_tokens}}){if ($line =~ $token_data->{syntax}){my$handler=$token_data->{handler};$token=$self->$handler($line);last}}$token=$self->_make_unknown_token($line)unless$token;return$self->{parser}->make_result($token)}sub token_types {my$self=shift;return keys %{$self->{tokens}}}sub syntax_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{syntax}}sub handler_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{handler}}sub _make_version_token {my ($self,$line,$version)=@_;return {type=>'version',raw=>$line,version=>$version,}}sub _make_plan_token {my ($self,$line,$tests_planned,$directive,$explanation,$todo)=@_;if ($directive eq 'SKIP' && 0!=$tests_planned && $self->{version}< 13){warn "Specified SKIP directive in plan but more than 0 tests ($line)\n"}return {type=>'plan',raw=>$line,tests_planned=>$tests_planned,directive=>$directive,explanation=>_trim($explanation),todo_list=>$todo,}}sub _make_test_token {my ($self,$line,$ok,$num,$desc,$dir,$explanation)=@_;return {ok=>$ok,test_num=>(defined$num ? 0 + $num : undef),description=>_trim($desc),directive=>(defined$dir ? uc$dir : ''),explanation=>_trim($explanation),raw=>$line,type=>'test',}}sub _make_unknown_token {my ($self,$line)=@_;return {raw=>$line,type=>'unknown',}}sub _make_comment_token {my ($self,$line,$comment)=@_;return {type=>'comment',raw=>$line,comment=>_trim($comment)}}sub _make_bailout_token {my ($self,$line,$explanation)=@_;return {type=>'bailout',raw=>$line,bailout=>_trim($explanation)}}sub _make_yaml_token {my ($self,$pad,$marker)=@_;my$yaml=TAP::Parser::YAMLish::Reader->new;my$iterator=$self->{iterator};my$leader=length($pad);my$strip=qr{ ^ (\s{$leader}) (.*) $ }x;my@extra=($marker);my$reader=sub {return shift@extra if@extra;my$line=$iterator->next;return $2 if$line =~ $strip;return};my$data=$yaml->read($reader);chomp(my$raw=$yaml->get_raw);$raw =~ s/^/$pad/mg;return {type=>'yaml',raw=>$raw,data=>$data }}sub _make_pragma_token {my ($self,$line,$pragmas)=@_;return {type=>'pragma',raw=>$line,pragmas=>[split /\s*,\s*/,_trim($pragmas)],}}sub _trim {my$data=shift;return '' unless defined$data;$data =~ s/^\s+//;$data =~ s/\s+$//;return$data}1;
TAP_PARSER_GRAMMAR

$fatpacked{"TAP/Parser/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR';
  package TAP::Parser::Iterator;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.33';sub next {my$self=shift;my$line=$self->next_raw;if (defined($line)and $line =~ /^\s*not\s*$/){$line .= ($self->next_raw || '')}return$line}sub next_raw {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub handle_unicode {}sub get_select_handles {return}sub wait {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub exit {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}1;
TAP_PARSER_ITERATOR

$fatpacked{"TAP/Parser/Iterator/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_ARRAY';
  package TAP::Parser::Iterator::Array;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.33';sub _initialize {my ($self,$thing)=@_;chomp @$thing;$self->{idx}=0;$self->{array}=$thing;$self->{exit}=undef;return$self}sub wait {shift->exit}sub exit {my$self=shift;return 0 if$self->{idx}>= @{$self->{array}};return}sub next_raw {my$self=shift;return$self->{array}->[$self->{idx}++ ]}1;
TAP_PARSER_ITERATOR_ARRAY

$fatpacked{"TAP/Parser/Iterator/Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_PROCESS';
  package TAP::Parser::Iterator::Process;use strict;use warnings;use Config;use IO::Handle;use base 'TAP::Parser::Iterator';my$IS_WIN32=($^O =~ /^(MS)?Win32$/);our$VERSION='3.33';{no warnings 'uninitialized';local$SIG{__DIE__}=undef;eval {require POSIX;&POSIX::WEXITSTATUS(0)};if ($@){*_wait2exit=sub {$_[1]>> 8}}else {*_wait2exit=sub {POSIX::WEXITSTATUS($_[1])}}}sub _use_open3 {my$self=shift;return unless$Config{d_fork}|| $IS_WIN32;for my$module (qw(IPC::Open3 IO::Select)){eval "use $module";return if $@}return 1}{my$got_unicode;sub _get_unicode {return$got_unicode if defined$got_unicode;eval 'use Encode qw(decode_utf8);';$got_unicode=$@ ? 0 : 1}}sub _initialize {my ($self,$args)=@_;my@command=@{delete$args->{command}|| []}or die "Must supply a command to execute";$self->{command}=[@command];my$chunk_size=delete$args->{_chunk_size}|| 65536;my$merge=delete$args->{merge};my ($pid,$err,$sel);if (my$setup=delete$args->{setup}){$setup->(@command)}my$out=IO::Handle->new;if ($self->_use_open3){my$xclose=\&IPC::Open3::xclose;no warnings;local*IPC::Open3::xclose=sub {my$fh=shift;no strict 'refs';return if (fileno($fh)==fileno(STDIN));$xclose->($fh)};if ($IS_WIN32){$err=$merge ? '' : '>&STDERR';eval {$pid=open3('<&STDIN',$out,$merge ? '' : $err,@command)};die "Could not execute (@command): $@" if $@;if ($] >= 5.006){binmode($out,":crlf")}}else {$err=$merge ? '' : IO::Handle->new;eval {$pid=open3('<&STDIN',$out,$err,@command)};die "Could not execute (@command): $@" if $@;$sel=$merge ? undef : IO::Select->new($out,$err)}}else {$err='';my$command =join(' ',map {$_ =~ /\s/ ? qq{"$_"} : $_}@command);open($out,"$command|")or die "Could not execute ($command): $!"}$self->{out}=$out;$self->{err}=$err;$self->{sel}=$sel;$self->{pid}=$pid;$self->{exit}=undef;$self->{chunk_size}=$chunk_size;if (my$teardown=delete$args->{teardown}){$self->{teardown}=sub {$teardown->(@command)}}return$self}sub handle_unicode {my$self=shift;if ($self->{sel}){if (_get_unicode()){my$next=$self->{_next}||=$self->_next;$self->{_next}=sub {my$line=$next->();return decode_utf8($line)if defined$line;return}}}else {if ($] >= 5.008){eval 'binmode($self->{out}, ":utf8")'}}}sub wait {shift->{wait}}sub exit {shift->{exit}}sub _next {my$self=shift;if (my$out=$self->{out}){if (my$sel=$self->{sel}){my$err=$self->{err};my@buf=();my$partial='';my$chunk_size=$self->{chunk_size};return sub {return shift@buf if@buf;READ: while (my@ready=$sel->can_read){for my$fh (@ready){my$got=sysread$fh,my ($chunk),$chunk_size;if ($got==0){$sel->remove($fh)}elsif ($fh==$err){print STDERR$chunk}else {$chunk=$partial .$chunk;$partial='';unless (substr($chunk,-1,1)eq "\n"){my$nl=rindex$chunk,"\n";if ($nl==-1){$partial=$chunk;redo READ}else {$partial=substr($chunk,$nl + 1);$chunk=substr($chunk,0,$nl)}}push@buf,split /\n/,$chunk;return shift@buf if@buf}}}if (length$partial){my$last=$partial;$partial='';return$last}$self->_finish;return}}else {return sub {if (defined(my$line=<$out>)){chomp$line;return$line}$self->_finish;return}}}else {return sub {$self->_finish;return}}}sub next_raw {my$self=shift;return ($self->{_next}||=$self->_next)->()}sub _finish {my$self=shift;my$status=$?;$self->{_next}=sub {return}if $] >= 5.006;if (defined$self->{pid}){if ($self->{pid}==waitpid($self->{pid},0)){$status=$?}}(delete$self->{out})->close if$self->{out};if ($self->{sel}){(delete$self->{err})->close;delete$self->{sel}}else {$status=$?}$status=0 if$IS_WIN32 && $status==-1;$self->{wait}=$status;$self->{exit}=$self->_wait2exit($status);if (my$teardown=$self->{teardown}){$teardown->()}return$self}sub get_select_handles {my$self=shift;return grep $_,($self->{out},$self->{err})}1;
TAP_PARSER_ITERATOR_PROCESS

$fatpacked{"TAP/Parser/Iterator/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_STREAM';
  package TAP::Parser::Iterator::Stream;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.33';sub _initialize {my ($self,$thing)=@_;$self->{fh}=$thing;return$self}sub wait {shift->exit}sub exit {shift->{fh}? (): 0}sub next_raw {my$self=shift;my$fh=$self->{fh};if (defined(my$line=<$fh>)){chomp$line;return$line}else {$self->_finish;return}}sub _finish {my$self=shift;close delete$self->{fh}}1;
TAP_PARSER_ITERATOR_STREAM

$fatpacked{"TAP/Parser/IteratorFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATORFACTORY';
  package TAP::Parser::IteratorFactory;use strict;use warnings;use Carp qw(confess);use File::Basename qw(fileparse);use base 'TAP::Object';use constant handlers=>[];our$VERSION='3.33';sub _initialize {my ($self,$config)=@_;$self->config($config || {})->load_handlers;return$self}sub register_handler {my ($class,$dclass)=@_;confess("$dclass must implement can_handle & make_iterator methods!")unless UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');my$handlers=$class->handlers;push @{$handlers},$dclass unless grep {$_ eq $dclass}@{$handlers};return$class}sub config {my$self=shift;return$self->{config}unless @_;unless ('HASH' eq ref $_[0]){$self->_croak('Argument to &config must be a hash reference')}$self->{config}=shift;return$self}sub _last_handler {my$self=shift;return$self->{last_handler}unless @_;$self->{last_handler}=shift;return$self}sub _testing {my$self=shift;return$self->{testing}unless @_;$self->{testing}=shift;return$self}sub load_handlers {my ($self)=@_;for my$handler (keys %{$self->config}){my$sclass=$self->_load_handler($handler)}return$self}sub _load_handler {my ($self,$handler)=@_;my@errors;for my$dclass ("TAP::Parser::SourceHandler::$handler",$handler){return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');eval "use $dclass";if (my$e=$@){push@errors,$e;next}return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');push@errors,"handler '$dclass' does not implement can_handle & make_iterator"}$self->_croak("Cannot load handler '$handler': " .join("\n",@errors))}sub make_iterator {my ($self,$source)=@_;$self->_croak('no raw source defined!')unless defined$source->raw;$source->config($self->config)->assemble_meta;return$source->raw if ($source->meta->{is_object}&& UNIVERSAL::isa($source->raw,'TAP::Parser::SourceHandler'));my$sd_class=$self->detect_source($source);$self->_last_handler($sd_class);return if$self->_testing;my$iterator=$sd_class->make_iterator($source);return$iterator}sub detect_source {my ($self,$source)=@_;confess('no raw source ref defined!')unless defined$source->raw;my%handlers;for my$dclass (@{$self->handlers}){my$confidence=$dclass->can_handle($source);$handlers{$dclass}=$confidence if$confidence}if (!%handlers){my$raw_source_short=substr(${$source->raw},0,50);confess("Cannot detect source of '$raw_source_short'!");return}my@handlers=(map {$_}sort {$handlers{$a}cmp $handlers{$b}}keys%handlers);if ($ENV{TAP_HARNESS_SOURCE_FACTORY_VOTES}){warn("votes: ",join(', ',map {"$_: $handlers{$_}"}@handlers),"\n")}return pop@handlers}1;
TAP_PARSER_ITERATORFACTORY

$fatpacked{"TAP/Parser/Multiplexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_MULTIPLEXER';
  package TAP::Parser::Multiplexer;use strict;use warnings;use IO::Select;use base 'TAP::Object';use constant IS_WIN32=>$^O =~ /^(MS)?Win32$/;use constant IS_VMS=>$^O eq 'VMS';use constant SELECT_OK=>!(IS_VMS || IS_WIN32);our$VERSION='3.33';sub _initialize {my$self=shift;$self->{select}=IO::Select->new;$self->{avid}=[];$self->{count}=0;return$self}sub add {my ($self,$parser,$stash)=@_;if (SELECT_OK && (my@handles=$parser->get_select_handles)){my$sel=$self->{select};my@filenos=map {fileno $_}@handles;for my$h (@handles){$sel->add([$h,$parser,$stash,@filenos ])}$self->{count}++}else {push @{$self->{avid}},[$parser,$stash ]}}sub parsers {my$self=shift;return$self->{count}+ scalar @{$self->{avid}}}sub _iter {my$self=shift;my$sel=$self->{select};my$avid=$self->{avid};my@ready=();return sub {if (@$avid){my ($parser,$stash)=@{$avid->[0]};my$result=$parser->next;shift @$avid unless defined$result;return ($parser,$stash,$result)}unless (@ready){return unless$sel->count;@ready=$sel->can_read}my ($h,$parser,$stash,@handles)=@{shift@ready};my$result=$parser->next;unless (defined$result){$sel->remove(@handles);$self->{count}--;@ready=()}return ($parser,$stash,$result)}}sub next {my$self=shift;return ($self->{_iter}||=$self->_iter)->()}1;
TAP_PARSER_MULTIPLEXER

$fatpacked{"TAP/Parser/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT';
  package TAP::Parser::Result;use strict;use warnings;use base 'TAP::Object';BEGIN {my@attrs=qw(plan pragma test comment bailout version unknown yaml);no strict 'refs';for my$token (@attrs){my$method="is_$token";*$method=sub {return$token eq shift->type}}}our$VERSION='3.33';sub _initialize {my ($self,$token)=@_;if ($token){@{$self}{keys %$token }=values %$token}return$self}sub raw {shift->{raw}}sub type {shift->{type}}sub as_string {shift->{raw}}sub is_ok {1}sub passed {warn 'passed() is deprecated.  Please use "is_ok()"';shift->is_ok}sub has_directive {my$self=shift;return ($self->has_todo || $self->has_skip)}sub has_todo {'TODO' eq (shift->{directive}|| '')}sub has_skip {'SKIP' eq (shift->{directive}|| '')}sub set_directive {my ($self,$dir)=@_;$self->{directive}=$dir}1;
TAP_PARSER_RESULT

$fatpacked{"TAP/Parser/Result/Bailout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_BAILOUT';
  package TAP::Parser::Result::Bailout;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub explanation {shift->{bailout}}sub as_string {shift->{bailout}}1;
TAP_PARSER_RESULT_BAILOUT

$fatpacked{"TAP/Parser/Result/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_COMMENT';
  package TAP::Parser::Result::Comment;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub comment {shift->{comment}}sub as_string {shift->{raw}}1;
TAP_PARSER_RESULT_COMMENT

$fatpacked{"TAP/Parser/Result/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PLAN';
  package TAP::Parser::Result::Plan;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub plan {'1..' .shift->{tests_planned}}sub tests_planned {shift->{tests_planned}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub todo_list {shift->{todo_list}}1;
TAP_PARSER_RESULT_PLAN

$fatpacked{"TAP/Parser/Result/Pragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PRAGMA';
  package TAP::Parser::Result::Pragma;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub pragmas {my@pragmas=@{shift->{pragmas}};return wantarray ? @pragmas : \@pragmas}1;
TAP_PARSER_RESULT_PRAGMA

$fatpacked{"TAP/Parser/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_TEST';
  package TAP::Parser::Result::Test;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub ok {shift->{ok}}sub number {shift->{test_num}}sub _number {my ($self,$number)=@_;$self->{test_num}=$number}sub description {shift->{description}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub is_ok {my$self=shift;return if$self->is_unplanned;return$self->has_todo ? 1 : $self->ok !~ /not/}sub is_actual_ok {my$self=shift;return$self->{ok}!~ /not/}sub actual_passed {warn 'actual_passed() is deprecated.  Please use "is_actual_ok()"';goto&is_actual_ok}sub todo_passed {my$self=shift;return$self->has_todo && $self->is_actual_ok}sub todo_failed {warn 'todo_failed() is deprecated.  Please use "todo_passed()"';goto&todo_passed}sub as_string {my$self=shift;my$string=$self->ok ." " .$self->number;if (my$description=$self->description){$string .= " $description"}if (my$directive=$self->directive){my$explanation=$self->explanation;$string .= " # $directive $explanation"}return$string}sub is_unplanned {my$self=shift;return ($self->{unplanned}|| '')unless @_;$self->{unplanned}=!!shift;return$self}1;
TAP_PARSER_RESULT_TEST

$fatpacked{"TAP/Parser/Result/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_UNKNOWN';
  package TAP::Parser::Result::Unknown;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';1;
TAP_PARSER_RESULT_UNKNOWN

$fatpacked{"TAP/Parser/Result/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_VERSION';
  package TAP::Parser::Result::Version;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub version {shift->{version}}1;
TAP_PARSER_RESULT_VERSION

$fatpacked{"TAP/Parser/Result/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_YAML';
  package TAP::Parser::Result::YAML;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.33';sub data {shift->{data}}1;
TAP_PARSER_RESULT_YAML

$fatpacked{"TAP/Parser/ResultFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULTFACTORY';
  package TAP::Parser::ResultFactory;use strict;use warnings;use TAP::Parser::Result::Bailout ();use TAP::Parser::Result::Comment ();use TAP::Parser::Result::Plan ();use TAP::Parser::Result::Pragma ();use TAP::Parser::Result::Test ();use TAP::Parser::Result::Unknown ();use TAP::Parser::Result::Version ();use TAP::Parser::Result::YAML ();use base 'TAP::Object';our$VERSION='3.33';sub make_result {my ($proto,$token)=@_;my$type=$token->{type};return$proto->class_for($type)->new($token)}our%CLASS_FOR=(plan=>'TAP::Parser::Result::Plan',pragma=>'TAP::Parser::Result::Pragma',test=>'TAP::Parser::Result::Test',comment=>'TAP::Parser::Result::Comment',bailout=>'TAP::Parser::Result::Bailout',version=>'TAP::Parser::Result::Version',unknown=>'TAP::Parser::Result::Unknown',yaml=>'TAP::Parser::Result::YAML',);sub class_for {my ($class,$type)=@_;return$CLASS_FOR{$type}if exists$CLASS_FOR{$type};require Carp;Carp::croak("Could not determine class for result type '$type'")}sub register_type {my ($class,$type,$rclass)=@_;$CLASS_FOR{$type}=$rclass;return$class}1;
TAP_PARSER_RESULTFACTORY

$fatpacked{"TAP/Parser/Scheduler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER';
  package TAP::Parser::Scheduler;use strict;use warnings;use Carp;use TAP::Parser::Scheduler::Job;use TAP::Parser::Scheduler::Spinner;our$VERSION='3.33';sub new {my$class=shift;croak "Need a number of key, value pairs" if @_ % 2;my%args=@_;my$tests=delete$args{tests}|| croak "Need a 'tests' argument";my$rules=delete$args{rules}|| {par=>'**'};croak "Unknown arg(s): ",join ', ',sort keys%args if keys%args;my$self=bless {},$class;$self->_set_rules($rules,$tests);return$self}sub _set_rules {my ($self,$rules,$tests)=@_;my@tests=map {TAP::Parser::Scheduler::Job->new(@$_)}map {'ARRAY' eq ref $_ ? $_ : [$_,$_ ]}@$tests;my$schedule=$self->_rule_clause($rules,\@tests);$schedule=[[$schedule,@tests ]]if@tests;$self->{schedule}=$schedule}sub _rule_clause {my ($self,$rule,$tests)=@_;croak 'Rule clause must be a hash' unless 'HASH' eq ref$rule;my@type=keys %$rule;croak 'Rule clause must have exactly one key' unless@type==1;my%handlers=(par=>sub {[map {[$_]}@_ ]},seq=>sub {[[@_]]},);my$handler=$handlers{$type[0]}|| croak 'Unknown scheduler type: ',$type[0];my$val=$rule->{$type[0]};return$handler->(map {'HASH' eq ref $_ ? $self->_rule_clause($_,$tests): $self->_expand($_,$tests)}'ARRAY' eq ref$val ? @$val : $val)}sub _glob_to_regexp {my ($self,$glob)=@_;my$nesting;my$pattern;while (1){if ($glob =~ /\G\*\*/gc){$pattern .= '.*?'}elsif ($glob =~ /\G\*/gc){$pattern .= '[^/]*'}elsif ($glob =~ /\G\?/gc){$pattern .= '[^/]'}elsif ($glob =~ /\G\{/gc){$pattern .= '(?:';++$nesting}elsif ($nesting and $glob =~ /\G,/gc){$pattern .= '|'}elsif ($nesting and $glob =~ /\G\}/gc){$pattern .= ')';--$nesting}elsif ($glob =~ /\G(\\.)/gc){$pattern .= $1}elsif ($glob =~ /\G([\},])/gc){$pattern .= '\\' .$1}else {$glob =~ /\G([^{?*\\\},]*)/gc;$pattern .= quotemeta $1}return$pattern if pos$glob==length$glob}}sub _expand {my ($self,$name,$tests)=@_;my$pattern=$self->_glob_to_regexp($name);$pattern=qr/^ $pattern $/x;my@match=();for (my$ti=0;$ti < @$tests;$ti++ ){if ($tests->[$ti]->filename =~ $pattern){push@match,splice @$tests,$ti,1;$ti--}}return@match}sub get_all {my$self=shift;my@all=$self->_gather($self->{schedule});$self->{count}=@all;@all}sub _gather {my ($self,$rule)=@_;return unless defined$rule;return$rule unless 'ARRAY' eq ref$rule;return map {defined()? $self->_gather($_): ()}map {@$_}@$rule}sub get_job {my$self=shift;$self->{count}||=$self->get_all;my@jobs=$self->_find_next_job($self->{schedule});if (@jobs){--$self->{count};return$jobs[0]}return TAP::Parser::Scheduler::Spinner->new if$self->{count};return}sub _not_empty {my$ar=shift;return 1 unless 'ARRAY' eq ref$ar;for (@$ar){return 1 if _not_empty($_)}return}sub _is_empty {!_not_empty(@_)}sub _find_next_job {my ($self,$rule)=@_;my@queue=();my$index=0;while ($index < @$rule){my$seq=$rule->[$index];shift @$seq while @$seq && _is_empty($seq->[0]);if (@$seq){if (defined$seq->[0]){if ('ARRAY' eq ref$seq->[0]){push@queue,$seq}else {my$job=splice @$seq,0,1,undef;$job->on_finish(sub {shift @$seq});return$job}}++$index}else {splice @$rule,$index,1}}for my$seq (@queue){if (my@jobs=$self->_find_next_job($seq->[0])){return@jobs}}return}sub as_string {my$self=shift;return$self->_as_string($self->{schedule})}sub _as_string {my ($self,$rule,$depth)=(shift,shift,shift || 0);my$pad=' ' x 2;my$indent=$pad x $depth;if (!defined$rule){return "$indent(undef)\n"}elsif ('ARRAY' eq ref$rule){return unless @$rule;my$type=('par','seq')[$depth % 2 ];return join('',"$indent$type:\n",map {$self->_as_string($_,$depth + 1)}@$rule)}else {return "$indent'" .$rule->filename ."'\n"}}1;
TAP_PARSER_SCHEDULER

$fatpacked{"TAP/Parser/Scheduler/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_JOB';
  package TAP::Parser::Scheduler::Job;use strict;use warnings;use Carp;our$VERSION='3.33';sub new {my ($class,$name,$desc,@ctx)=@_;return bless {filename=>$name,description=>$desc,@ctx ? (context=>\@ctx): (),},$class}sub on_finish {my ($self,$cb)=@_;$self->{on_finish}=$cb}sub finish {my$self=shift;if (my$cb=$self->{on_finish}){$cb->($self)}}sub filename {shift->{filename}}sub description {shift->{description}}sub context {@{shift->{context}|| []}}sub as_array_ref {my$self=shift;return [$self->filename,$self->description,$self->{context}||=[]]}sub is_spinner {0}1;
TAP_PARSER_SCHEDULER_JOB

$fatpacked{"TAP/Parser/Scheduler/Spinner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_SPINNER';
  package TAP::Parser::Scheduler::Spinner;use strict;use warnings;use Carp;our$VERSION='3.33';sub new {bless {},shift}sub is_spinner {1}1;
TAP_PARSER_SCHEDULER_SPINNER

$fatpacked{"TAP/Parser/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCE';
  package TAP::Parser::Source;use strict;use warnings;use File::Basename qw(fileparse);use base 'TAP::Object';use constant BLK_SIZE=>512;our$VERSION='3.33';sub _initialize {my ($self)=@_;$self->meta({});$self->config({});return$self}sub raw {my$self=shift;return$self->{raw}unless @_;$self->{raw}=shift;return$self}sub meta {my$self=shift;return$self->{meta}unless @_;$self->{meta}=shift;return$self}sub has_meta {return scalar %{shift->meta}? 1 : 0}sub config {my$self=shift;return$self->{config}unless @_;$self->{config}=shift;return$self}sub merge {my$self=shift;return$self->{merge}unless @_;$self->{merge}=shift;return$self}sub switches {my$self=shift;return$self->{switches}unless @_;$self->{switches}=shift;return$self}sub test_args {my$self=shift;return$self->{test_args}unless @_;$self->{test_args}=shift;return$self}sub assemble_meta {my ($self)=@_;return$self->meta if$self->has_meta;my$meta=$self->meta;my$raw=$self->raw;$meta->{is_object}=UNIVERSAL::isa($raw,'UNIVERSAL')? 1 : 0;if ($meta->{is_object}){$meta->{class}=ref($raw)}else {my$ref=lc(ref($raw));$meta->{"is_$ref"}=1}if ($meta->{is_scalar}){my$source=$$raw;$meta->{length}=length($$raw);$meta->{has_newlines}=$$raw =~ /\n/ ? 1 : 0;if (!$meta->{has_newlines}and $meta->{length}< 1024){my$file={};$file->{exists}=-e $source ? 1 : 0;if ($file->{exists}){$meta->{file}=$file;$file->{stat}=[stat(_)];$file->{empty}=-z _ ? 1 : 0;$file->{size}=-s _;$file->{text}=-T _ ? 1 : 0;$file->{binary}=-B _ ? 1 : 0;$file->{read}=-r _ ? 1 : 0;$file->{write}=-w _ ? 1 : 0;$file->{execute}=-x _ ? 1 : 0;$file->{setuid}=-u _ ? 1 : 0;$file->{setgid}=-g _ ? 1 : 0;$file->{sticky}=-k _ ? 1 : 0;$meta->{is_file}=$file->{is_file}=-f _ ? 1 : 0;$meta->{is_dir}=$file->{is_dir}=-d _ ? 1 : 0;$meta->{is_symlink}=$file->{is_symlink}=-l $source ? 1 : 0;if ($file->{is_symlink}){$file->{lstat}=[lstat(_)]}($file->{basename},$file->{dir},$file->{ext})=map {defined $_ ? $_ : ''}fileparse($source,qr/\.[^.]*/);$file->{lc_ext}=lc($file->{ext});$file->{basename}.= $file->{ext}if$file->{ext};if (!$file->{is_dir}&& $file->{read}){eval {$file->{shebang}=$self->shebang($$raw)};if (my$e=$@){warn$e}}}}}elsif ($meta->{is_array}){$meta->{size}=$#$raw + 1}elsif ($meta->{is_hash}){}return$meta}{my%shebang_for;sub _read_shebang {my ($class,$file)=@_;open my$fh,'<',$file or die "Can't read $file: $!\n";my$got=read$fh,my ($buf),BLK_SIZE;defined$got or die "I/O error: $!\n";return $1 if$buf =~ /(.*)/;return}sub shebang {my ($class,$file)=@_;$shebang_for{$file}=$class->_read_shebang($file)unless exists$shebang_for{$file};return$shebang_for{$file}}}sub config_for {my ($self,$class)=@_;my ($abbrv_class)=($class =~ /(?:\:\:)?(\w+)$/);my$config=$self->config->{$abbrv_class}|| $self->config->{$class};return$config}1;
TAP_PARSER_SOURCE

$fatpacked{"TAP/Parser/SourceHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER';
  package TAP::Parser::SourceHandler;use strict;use warnings;use TAP::Parser::Iterator ();use base 'TAP::Object';our$VERSION='3.33';sub can_handle {my ($class,$args)=@_;$class->_croak("Abstract method 'can_handle' not implemented for $class!");return}sub make_iterator {my ($class,$args)=@_;$class->_croak("Abstract method 'make_iterator' not implemented for $class!");return}1;
TAP_PARSER_SOURCEHANDLER

$fatpacked{"TAP/Parser/SourceHandler/Executable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_EXECUTABLE';
  package TAP::Parser::SourceHandler::Executable;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.33';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;if ($meta->{is_file}){my$file=$meta->{file};return 0.85 if$file->{execute}&& $file->{binary};return 0.8 if$file->{lc_ext}eq '.bat';return 0.25 if$file->{execute}}elsif ($meta->{is_hash}){return 0.9 if$src->raw->{exec}}return 0}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my@command;if ($meta->{is_hash}){@command=@{$source->raw->{exec}|| []}}elsif ($meta->{is_scalar}){@command=${$source->raw}}elsif ($meta->{is_array}){@command=@{$source->raw}}$class->_croak('No command found in $source->raw!')unless@command;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR);push@command,@{$source->test_args || []};return$class->iterator_class->new({command=>\@command,merge=>$source->merge })}use constant iterator_class=>'TAP::Parser::Iterator::Process';sub _autoflush {my ($class,$flushed)=@_;my$old_fh=select$flushed;$|=1;select$old_fh}1;
TAP_PARSER_SOURCEHANDLER_EXECUTABLE

$fatpacked{"TAP/Parser/SourceHandler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_FILE';
  package TAP::Parser::SourceHandler::File;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.33';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;my$config=$src->config_for($class);return 0 unless$meta->{is_file};my$file=$meta->{file};return 0.9 if$file->{lc_ext}eq '.tap';if (my$exts=$config->{extensions}){return 0.9 if grep {lc($_)eq $file->{lc_ext}}@$exts}return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a scalar ref')unless$source->meta->{is_scalar};my$file=${$source->raw};my$fh;open($fh,'<',$file)or $class->_croak("error opening TAP source file '$file': $!");return$class->iterator_class->new($fh)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_FILE

$fatpacked{"TAP/Parser/SourceHandler/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_HANDLE';
  package TAP::Parser::SourceHandler::Handle;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.33';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0.9 if$meta->{is_object}&& UNIVERSAL::isa($src->raw,'IO::Handle');return 0.8 if$meta->{is_glob};return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a glob ref or an IO::Handle')unless$source->meta->{is_glob}|| UNIVERSAL::isa($source->raw,'IO::Handle');return$class->iterator_class->new($source->raw)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_HANDLE

$fatpacked{"TAP/Parser/SourceHandler/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_PERL';
  package TAP::Parser::SourceHandler::Perl;use strict;use warnings;use Config;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use Text::ParseWords qw(shellwords);use base 'TAP::Parser::SourceHandler::Executable';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.33';sub can_handle {my ($class,$source)=@_;my$meta=$source->meta;return 0 unless$meta->{is_file};my$file=$meta->{file};if (my$shebang=$file->{shebang}){return 0.9 if$shebang =~ /^#!.*\bperl/;return 0.3}return 0.8 if$file->{lc_ext}eq '.t';return 0.9 if$file->{lc_ext}eq '.pl';return 0.75 if$file->{dir}=~ /^t\b/;return 0.25}sub _autoflush_stdhandles {my ($class)=@_;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR)}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my$perl_script=${$source->raw};$class->_croak("Cannot find ($perl_script)")unless$meta->{is_file};$class->_autoflush_stdhandles;my ($libs,$switches)=$class->_mangle_switches($class->_filter_libs($class->_switches($source)));$class->_run($source,$libs,$switches)}sub _has_taint_switch {my($class,$switches)=@_;my$has_taint=grep {$_ eq "-T" || $_ eq "-t"}@{$switches};return$has_taint ? 1 : 0}sub _mangle_switches {my ($class,$libs,$switches)=@_;if ($class->_has_taint_switch($switches)){my@perl5lib=defined$ENV{PERL5LIB}? split /$Config{path_sep}/,$ENV{PERL5LIB}: ();return ($libs,[@{$switches},$class->_libs2switches([@$libs,@perl5lib]),defined$ENV{PERL5OPT}? shellwords($ENV{PERL5OPT}): ()],)}return ($libs,$switches)}sub _filter_libs {my ($class,@switches)=@_;my$path_sep=$Config{path_sep};my$path_re=qr{$path_sep};my@libs;my@filtered_switches;for (@switches){if (!/$path_re/ && m/ ^ ['"]? -I ['"]? (.*?) ['"]? $ /x){push@libs,$1}else {push@filtered_switches,$_}}return \@libs,\@filtered_switches}sub _iterator_hooks {my ($class,$source,$libs,$switches)=@_;my$setup=sub {if (@{$libs}and!$class->_has_taint_switch($switches)){$ENV{PERL5LIB}=join($Config{path_sep},grep {defined}@{$libs},$ENV{PERL5LIB})}};my$previous=$ENV{PERL5LIB};my$teardown=sub {if (defined$previous){$ENV{PERL5LIB}=$previous}else {delete$ENV{PERL5LIB}}};return ($setup,$teardown)}sub _run {my ($class,$source,$libs,$switches)=@_;my@command=$class->_get_command_for_switches($source,$switches)or $class->_croak("No command found!");my ($setup,$teardown)=$class->_iterator_hooks($source,$libs,$switches);return$class->_create_iterator($source,\@command,$setup,$teardown)}sub _create_iterator {my ($class,$source,$command,$setup,$teardown)=@_;return TAP::Parser::Iterator::Process->new({command=>$command,merge=>$source->merge,setup=>$setup,teardown=>$teardown,})}sub _get_command_for_switches {my ($class,$source,$switches)=@_;my$file=${$source->raw};my@args=@{$source->test_args || []};my$command=$class->get_perl;my@command=($command,@{$switches},$file,@args);return@command}sub _libs2switches {my$class=shift;return map {"-I$_"}grep {$_}@{$_[0]}}sub get_taint {my ($class,$shebang)=@_;return unless defined$shebang && $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/;return $1}sub _switches {my ($class,$source)=@_;my$file=${$source->raw};my@switches=@{$source->switches || []};my$shebang=$source->meta->{file}->{shebang};return unless defined$shebang;my$taint=$class->get_taint($shebang);push@switches,"-$taint" if defined$taint;if (IS_VMS){for (@switches){$_=qq["$_"]}}return@switches}sub get_perl {my$class=shift;return$ENV{HARNESS_PERL}if defined$ENV{HARNESS_PERL};return qq["$^X"] if IS_WIN32 && ($^X =~ /[^\w\.\/\\]/);return $^X}1;
TAP_PARSER_SOURCEHANDLER_PERL

$fatpacked{"TAP/Parser/SourceHandler/RawTAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_RAWTAP';
  package TAP::Parser::SourceHandler::RawTAP;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Array ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.33';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0 if$meta->{file};if ($meta->{is_scalar}){return 0 unless$meta->{has_newlines};return 0.9 if ${$src->raw}=~ /\d\.\.\d/;return 0.7 if ${$src->raw}=~ /ok/;return 0.3}elsif ($meta->{is_array}){return 0.5}return 0}sub make_iterator {my ($class,$src)=@_;my$meta=$src->meta;my$tap_array;if ($meta->{is_scalar}){$tap_array=[split "\n"=>${$src->raw}]}elsif ($meta->{is_array}){$tap_array=$src->raw}$class->_croak('No raw TAP found in $source->raw')unless scalar$tap_array;return TAP::Parser::Iterator::Array->new($tap_array)}1;
TAP_PARSER_SOURCEHANDLER_RAWTAP

$fatpacked{"TAP/Parser/YAMLish/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_READER';
  package TAP::Parser::YAMLish::Reader;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.33';my%UNESCAPES=(z=>"\x00",a=>"\x07",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my$QQ_STRING=qr{ " (?:\\. | [^"])* " }x;my$HASH_LINE=qr{ ^ ($QQ_STRING|\S+) \s* : \s* (?: (.+?) \s* )? $ }x;my$IS_HASH_KEY=qr{ ^ [\w\'\"] }x;my$IS_END_YAML=qr{ ^ \.\.\. \s* $ }x;my$IS_QQ_STRING=qr{ ^ $QQ_STRING $ }x;sub read {my$self=shift;my$obj=shift;die "Must have a code reference to read input from" unless ref$obj eq 'CODE';$self->{reader}=$obj;$self->{capture}=[];$self->_next;return unless$self->{next};my$doc=$self->_read;my$dots=$self->_peek;die "Missing '...' at end of YAMLish" unless defined$dots and $dots =~ $IS_END_YAML;delete$self->{reader};delete$self->{next};return$doc}sub get_raw {join("\n",grep defined,@{shift->{capture}|| []})."\n"}sub _peek {my$self=shift;return$self->{next}unless wantarray;my$line=$self->{next};$line =~ /^ (\s*) (.*) $ /x;return ($2,length $1)}sub _next {my$self=shift;die "_next called with no reader" unless$self->{reader};my$line=$self->{reader}->();$self->{next}=$line;push @{$self->{capture}},$line}sub _read {my$self=shift;my$line=$self->_peek;if ($line =~ /^ --- (?: \s* (.+?) \s* )? $/x){$self->_next;return$self->_read_scalar($1)if defined $1;my ($next,$indent)=$self->_peek;if ($next =~ /^ - /x){return$self->_read_array($indent)}elsif ($next =~ $IS_HASH_KEY){return$self->_read_hash($next,$indent)}elsif ($next =~ $IS_END_YAML){die "Premature end of YAMLish"}else {die "Unsupported YAMLish syntax: '$next'"}}else {die "YAMLish document header not found"}}sub _read_qq {my$self=shift;my$str=shift;unless ($str =~ s/^ " (.*?) " $/$1/x){die "Internal: not a quoted string"}$str =~ s/\\"/"/gx;$str =~ s/ \\ ( [tartan\\favez] | x([0-9a-fA-F]{2}) ) 
                   / (length($1) > 1) ? pack("H2", $2) : $UNESCAPES{$1} /gex;return$str}sub _read_scalar {my$self=shift;my$string=shift;return undef if$string eq '~';return {}if$string eq '{}';return []if$string eq '[]';if ($string eq '>' || $string eq '|'){my ($line,$indent)=$self->_peek;die "Multi-line scalar content missing" unless defined$line;my@multiline=($line);while (1){$self->_next;my ($next,$ind)=$self->_peek;last if$ind < $indent;my$pad=$string eq '|' ? (' ' x ($ind - $indent)): '';push@multiline,$pad .$next}return join(($string eq '>' ? ' ' : "\n"),@multiline)."\n"}if ($string =~ /^ ' (.*) ' $/x){(my$rv=$1)=~ s/''/'/g;return$rv}if ($string =~ $IS_QQ_STRING){return$self->_read_qq($string)}if ($string =~ /^['"]/){die __PACKAGE__ ." does not support multi-line quoted scalars"}return$string}sub _read_nested {my$self=shift;my ($line,$indent)=$self->_peek;if ($line =~ /^ -/x){return$self->_read_array($indent)}elsif ($line =~ $IS_HASH_KEY){return$self->_read_hash($line,$indent)}else {die "Unsupported YAMLish syntax: '$line'"}}sub _read_array {my ($self,$limit)=@_;my$ar=[];while (1){my ($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML;if ($indent > $limit){die "Array line over-indented"}if ($line =~ /^ (- \s+) \S+ \s* : (?: \s+ | $ ) /x){$indent += length $1;$line =~ s/-\s+//;push @$ar,$self->_read_hash($line,$indent)}elsif ($line =~ /^ - \s* (.+?) \s* $/x){die "Unexpected start of YAMLish" if$line =~ /^---/;$self->_next;push @$ar,$self->_read_scalar($1)}elsif ($line =~ /^ - \s* $/x){$self->_next;push @$ar,$self->_read_nested}elsif ($line =~ $IS_HASH_KEY){$self->_next;push @$ar,$self->_read_hash($line,$indent,)}else {die "Unsupported YAMLish syntax: '$line'"}}return$ar}sub _read_hash {my ($self,$line,$limit)=@_;my$indent;my$hash={};while (1){die "Badly formed hash line: '$line'" unless$line =~ $HASH_LINE;my ($key,$value)=($self->_read_scalar($1),$2);$self->_next;if (defined$value){$hash->{$key}=$self->_read_scalar($value)}else {$hash->{$key}=$self->_read_nested}($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML}return$hash}1;
TAP_PARSER_YAMLISH_READER

$fatpacked{"TAP/Parser/YAMLish/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_WRITER';
  package TAP::Parser::YAMLish::Writer;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.33';my$ESCAPE_CHAR=qr{ [ \x00-\x1f \" ] }x;my$ESCAPE_KEY=qr{ (?: ^\W ) | $ESCAPE_CHAR }x;my@UNPRINTABLE=qw(z x01 x02 x03 x04 x05 x06 a x08 t n v f r x0e x0f x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1a e x1c x1d x1e x1f);sub write {my$self=shift;die "Need something to write" unless @_;my$obj=shift;my$out=shift || \*STDOUT;die "Need a reference to something I can write to" unless ref$out;$self->{writer}=$self->_make_writer($out);$self->_write_obj('---',$obj);$self->_put('...');delete$self->{writer}}sub _make_writer {my$self=shift;my$out=shift;my$ref=ref$out;if ('CODE' eq $ref){return$out}elsif ('ARRAY' eq $ref){return sub {push @$out,shift}}elsif ('SCALAR' eq $ref){return sub {$$out .= shift()."\n"}}elsif ('GLOB' eq $ref || 'IO::Handle' eq $ref){return sub {print$out shift(),"\n"}}die "Can't write to $out"}sub _put {my$self=shift;$self->{writer}->(join '',@_)}sub _enc_scalar {my$self=shift;my$val=shift;my$rule=shift;return '~' unless defined$val;if ($val =~ /$rule/){$val =~ s/\\/\\\\/g;$val =~ s/"/\\"/g;$val =~ s/ ( [\x00-\x1f] ) / '\\' . $UNPRINTABLE[ ord($1) ] /gex;return qq{"$val"}}if (length($val)==0 or $val =~ /\s/){$val =~ s/'/''/;return "'$val'"}return$val}sub _write_obj {my$self=shift;my$prefix=shift;my$obj=shift;my$indent=shift || 0;if (my$ref=ref$obj){my$pad='  ' x $indent;if ('HASH' eq $ref){if (keys %$obj){$self->_put($prefix);for my$key (sort keys %$obj){my$value=$obj->{$key};$self->_write_obj($pad .$self->_enc_scalar($key,$ESCAPE_KEY).':',$value,$indent + 1)}}else {$self->_put($prefix,' {}')}}elsif ('ARRAY' eq $ref){if (@$obj){$self->_put($prefix);for my$value (@$obj){$self->_write_obj($pad .'-',$value,$indent + 1)}}else {$self->_put($prefix,' []')}}else {die "Don't know how to encode $ref"}}else {$self->_put($prefix,' ',$self->_enc_scalar($obj,$ESCAPE_CHAR))}}1;
TAP_PARSER_YAMLISH_WRITER

$fatpacked{"Task/Weaken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TASK_WEAKEN';
  package Task::Weaken;use 5.005;use strict;use vars qw{$VERSION};BEGIN {$VERSION='1.04'}1;
TASK_WEAKEN

$fatpacked{"Test/Deep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP';
  use strict;use warnings;package Test::Deep;use Carp qw(confess);use Test::Deep::Cache;use Test::Deep::Stack;use Test::Deep::RegexpVersion;require overload;use Scalar::Util;my$Test;unless (defined$Test::Deep::NoTest::NoTest){require Test::Builder;$Test=Test::Builder->new}our ($Stack,%Compared,$CompareCache,%WrapCache,$Shallow);our$VERSION='0.113';$VERSION=eval$VERSION;require Exporter;our@ISA=qw(Exporter);our$Snobby=1;our$Expects=0;our$DNE=\"";our$DNE_ADDR=Scalar::Util::refaddr($DNE);my@constructors=(All=>"",Any=>"",Array=>"",ArrayEach=>"array_each",ArrayElementsOnly=>"",ArrayLength=>"",ArrayLengthOnly=>"",Blessed=>"",Boolean=>"bool",Code=>"",Hash=>"",HashEach=>"hash_each",HashKeys=>"",HashKeysOnly=>"",Ignore=>"",Isa=>"Isa",ListMethods=>"",Methods=>"",Number=>"num",Obj=>"obj_isa",RefType=>"",Regexp=>"re",RegexpMatches=>"",RegexpOnly=>"",RegexpRef=>"",RegexpRefOnly=>"",ScalarRef=>"scalref",ScalarRefOnly=>"",Shallow=>"",String=>"str",);my@CONSTRUCTORS_FROM_CLASSES;while (my ($pkg,$name)=splice@constructors,0,2){$name=lc($pkg)unless$name;my$full_pkg="Test::Deep::$pkg";my$file="$full_pkg.pm";$file =~ s#::#/#g;my$sub=sub {require$file;return$full_pkg->new(@_)};{no strict 'refs';*{$name}=$sub}push@CONSTRUCTORS_FROM_CLASSES,$name}{our@EXPORT_OK=qw(descend render_stack class_base cmp_details deep_diag);our%EXPORT_TAGS;$EXPORT_TAGS{v0}=[qw(Isa blessed obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore isa listmethods methods noclass num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];$EXPORT_TAGS{v1}=[qw(obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore listmethods methods noclass num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];our@EXPORT=@{$EXPORT_TAGS{v0 }};$EXPORT_TAGS{all}=[@EXPORT,@EXPORT_OK ]}sub isa {if (@_==1){goto&Isa}else {goto&UNIVERSAL::isa}}sub cmp_deeply {my ($d1,$d2,$name)=@_;my ($ok,$stack)=cmp_details($d1,$d2);if (not $Test->ok($ok,$name)){my$diag=deep_diag($stack);$Test->diag($diag)}return$ok}sub cmp_details {my ($d1,$d2)=@_;local$Stack=Test::Deep::Stack->new;local$CompareCache=Test::Deep::Cache->new;local%WrapCache;my$ok=descend($d1,$d2);return ($ok,$Stack)}sub eq_deeply {my ($d1,$d2)=@_;my ($ok)=cmp_details($d1,$d2);return$ok}sub eq_deeply_cache {my ($d1,$d2,$name)=@_;local$Stack=Test::Deep::Stack->new;$CompareCache->local;my$ok=descend($d1,$d2);$CompareCache->finish($ok);return$ok}sub deep_diag {my$stack=shift;local$Stack=$stack;my$where=render_stack('$data',$stack);confess "No stack to diagnose" unless$stack;my$last=$stack->getLast;my$diag;my$message;my$got;my$expected;my$exp=$last->{exp};if (Scalar::Util::blessed($exp)){if ($exp->can("diagnostics")){$diag=$exp->diagnostics($where,$last);$diag =~ s/\n+$/\n/}else {if ($exp->can("diag_message")){$message=$exp->diag_message($where)}}}if (not defined$diag){$got=$exp->renderGot($last->{got})unless defined$got;$expected=$exp->renderExp unless defined$expected;$message="Compared $where" unless defined$message;$diag=<<EOM}return$diag}sub render_val {my$val=shift;my$rendered;if (defined$val){$rendered=ref($val)? (Scalar::Util::refaddr($val)eq $DNE_ADDR ? "Does not exist" : overload::StrVal($val)): qq('$val')}else {$rendered="undef"}return$rendered}sub descend {my ($d1,$d2)=@_;if (!ref$d1 and!ref$d2){if (defined$d1){return 1 if defined$d2 and $d1 eq $d2}else {return 1 if!defined$d2}}if (!$Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){my$where=$Stack->render('$data');confess "Found a special comparison in $where\nYou can only use specials in the expects structure"}if (ref$d1 and ref$d2){if ($Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){return 0 unless Test::Deep::blessed(Scalar::Util::blessed($d2))->descend($d1);if ($d1->can("compare")){return$d1->compare($d2)}}my$s1=Scalar::Util::refaddr($d1);my$s2=Scalar::Util::refaddr($d2);if ($s1 eq $s2){return 1}if ($CompareCache->cmp($d1,$d2)){return 1}else {$CompareCache->add($d1,$d2)}}$d2=wrap($d2);$Stack->push({exp=>$d2,got=>$d1});if (ref($d1)and (Scalar::Util::refaddr($d1)==$DNE_ADDR)){return 0}if ($d2->descend($d1)){$Stack->pop;return 1}else {return 0}}sub wrap {my$data=shift;return$data if Scalar::Util::blessed($data)and $data->isa("Test::Deep::Cmp");my ($class,$base)=class_base($data);my$cmp;if($base eq ''){$cmp=shallow($data)}else {my$addr=Scalar::Util::refaddr($data);return$WrapCache{$addr}if$WrapCache{$addr};if($base eq 'ARRAY'){$cmp=array($data)}elsif($base eq 'HASH'){$cmp=hash($data)}elsif($base eq 'SCALAR' or $base eq 'REF'){$cmp=scalref($data)}elsif(($base eq 'Regexp')or ($base eq 'REGEXP')){$cmp=regexpref($data)}else {$cmp=shallow($data)}$WrapCache{$addr}=$cmp}return$cmp}sub class_base {my$val=shift;if (ref$val){my$blessed=Scalar::Util::blessed($val);$blessed=defined($blessed)? $blessed : "";my$reftype=Scalar::Util::reftype($val);if ($Test::Deep::RegexpVersion::OldStyle){if ($blessed eq "Regexp" and $reftype eq "SCALAR"){$reftype="Regexp"}}return ($blessed,$reftype)}else {return ("","")}}sub render_stack {my ($var,$stack)=@_;return$stack->render($var)}sub cmp_methods {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,methods(@{shift()}),shift)}sub requireclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(1,$val)}*useclass=\&requireclass;sub noclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(0,$val)}sub set {require Test::Deep::Set;return Test::Deep::Set->new(1,"",@_)}sub supersetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sup",@_)}sub subsetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sub",@_)}sub cmp_set {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,set(@{shift()}),shift)}sub bag {require Test::Deep::Set;return Test::Deep::Set->new(0,"",@_)}sub superbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sup",@_)}sub subbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sub",@_)}sub cmp_bag {local$Test::Builder::Level=$Test::Builder::Level + 1;my$ref=ref($_[1])|| "";confess "Argument 2 to cmp_bag is not an ARRAY ref (".render_val($_[1]).")" unless$ref eq "ARRAY";return cmp_deeply(shift,bag(@{shift()}),shift)}sub superhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SuperHash->new($val)}sub subhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SubHash->new($val)}sub builder {if (@_){$Test=shift}return$Test}1;
  $message
     got : $got
  expect : $expected
  EOM
TEST_DEEP

$fatpacked{"Test/Deep/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ALL';
  use strict;use warnings;package Test::Deep::All;use Test::Deep::Cmp;use overload '&'=>\&add,fallback=>1,;sub init {my$self=shift;my@list=map {Test::Deep::wrap($_)}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;my$data=$self->data;my$index=1;for my$cmp (@{$self->{val}}){$data->{index}=$index;$index++;next if Test::Deep::descend($got,$cmp);return 0}return 1}sub render_stack {my$self=shift;my$var=shift;my$data=shift;my$max=@{$self->{val}};return "(Part $data->{index} of $max in $var)"}sub add {my$self=shift;my$expect=shift;push(@{$self->{val}},Test::Deep::wrap($expect));return$self}1;
TEST_DEEP_ALL

$fatpacked{"Test/Deep/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ANY';
  use strict;use warnings;package Test::Deep::Any;use Test::Deep::Cmp;use overload '&'=>\&add,fallback=>1,;sub init {my$self=shift;my@list=map {Test::Deep::wrap($_)}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 1 if Test::Deep::eq_deeply_cache($got,$cmp)}return 0}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$expect=$self->{val};my$got=$self->renderGot($last->{got});my$things=join(", ",map {$_->renderExp}@$expect);my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}sub add {my$self=shift;my$expect=shift;push(@{$self->{val}},Test::Deep::wrap($expect));return$self}1;
  Comparing $where with Any
  got      : $got
  expected : Any of ( $things )
  EOM
TEST_DEEP_ANY

$fatpacked{"Test/Deep/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAY';
  use strict;use warnings;package Test::Deep::Array;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless Test::Deep::descend($got,Test::Deep::arraylength(scalar @$exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,Test::Deep::arrayelementsonly($exp))}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAY

$fatpacked{"Test/Deep/ArrayEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYEACH';
  use strict;use warnings;package Test::Deep::ArrayEach;use Test::Deep::Cmp;use Scalar::Util ();sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return unless Scalar::Util::reftype($got)eq 'ARRAY';my$exp=[($self->{val})x @$got ];return Test::Deep::descend($got,$exp)}sub renderExp {my$self=shift;my$exp=shift;return '[ ' .$self->SUPER::renderExp($self->{val}).', ... ]'}1;
TEST_DEEP_ARRAYEACH

$fatpacked{"Test/Deep/ArrayElementsOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYELEMENTSONLY';
  use strict;use warnings;package Test::Deep::ArrayElementsOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;for my$i (0..$#{$exp}){$data->{index}=$i;my$got_elem=$got->[$i];my$exp_elem=$exp->[$i];return 0 unless Test::Deep::descend($got_elem,$exp_elem)}return 1}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= "[$data->{index}]";return$var}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAYELEMENTSONLY

$fatpacked{"Test/Deep/ArrayLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTH';
  use strict;use warnings;package Test::Deep::ArrayLength;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"ARRAY");return Test::Deep::descend($got,Test::Deep::arraylengthonly($exp))}1;
TEST_DEEP_ARRAYLENGTH

$fatpacked{"Test/Deep/ArrayLengthOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTHONLY';
  use strict;use warnings;package Test::Deep::ArrayLengthOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$len=$self->{val};return @$got==$len}sub render_stack {my$self=shift;my ($var,$data)=@_;return "array length of $var"}sub renderVal {my$self=shift;my$val=shift;return "array with $val element(s)"}sub renderGot {my$self=shift;my$got=shift;return$self->renderVal(@$got + 0)}sub renderExp {my$self=shift;return$self->renderVal($self->{val})}1;
TEST_DEEP_ARRAYLENGTHONLY

$fatpacked{"Test/Deep/Blessed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BLESSED';
  use strict;use warnings;package Test::Deep::Blessed;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$blessed=blessed($got);return Test::Deep::descend($blessed,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "blessed($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(blessed($got))}1;
TEST_DEEP_BLESSED

$fatpacked{"Test/Deep/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BOOLEAN';
  use strict;use warnings;package Test::Deep::Boolean;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift()? 1 : 0}sub descend {my$self=shift;my$got=shift;return!($got xor $self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a boolean"}sub renderExp {my$self=shift;$self->renderGot($self->{val})}sub renderGot {my$self=shift;my$val=shift;return ($val ? "true" : "false")." (".Test::Deep::render_val($val).")"}1;
TEST_DEEP_BOOLEAN

$fatpacked{"Test/Deep/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE';
  use strict;use warnings;package Test::Deep::Cache;use Test::Deep::Cache::Simple;sub new {my$pkg=shift;my$self=bless {},$pkg;$self->{expects}=[Test::Deep::Cache::Simple->new];$self->{normal}=[Test::Deep::Cache::Simple->new];$self->local;return$self}sub add {my$self=shift;my$type=$self->type;$self->{$type}->[-1]->add(@_)}sub cmp {my$self=shift;my$type=$self->type;for my$cache (@{$self->{$type}}){return 1 if$cache->cmp(@_)}return 0}sub local {my$self=shift;for my$type (qw(expects normal)){push(@{$self->{$type}},Test::Deep::Cache::Simple->new)}}sub finish {my$self=shift;my$keep=shift;for my$type (qw(expects normal)){my$caches=$self->{$type};my$last=pop @$caches;$caches->[-1]->absorb($last)if$keep}}sub type {return$Test::Deep::Expects ? "expects" : "normal"}1;
TEST_DEEP_CACHE

$fatpacked{"Test/Deep/Cache/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE_SIMPLE';
  use strict;use warnings;package Test::Deep::Cache::Simple;use Carp qw(confess);use Scalar::Util qw(refaddr);BEGIN {if (grep /^weaken$/,@Scalar::Util::EXPORT_FAIL){*weaken=sub {}}else {Scalar::Util->import('weaken')}}sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub add {my$self=shift;my ($d1,$d2)=@_;{local$SIG{__DIE__};eval{weaken($d1)};eval{weaken($d2)}}$self->{fn_get_key(@_)}=[$d1,$d2]}sub cmp {my$self=shift;my$key=fn_get_key(@_);my$pair=$self->{$key};if (ref($pair->[0])and ref($pair->[1])){return 1}else {delete$self->{$key};return 0}}sub absorb {my$self=shift;my$other=shift;@{$self}{keys %$other}=values %$other}sub fn_get_key {return join(",",sort (map {refaddr($_)}@_))}1;
TEST_DEEP_CACHE_SIMPLE

$fatpacked{"Test/Deep/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CLASS';
  use strict;use warnings;package Test::Deep::Class;use Test::Deep::Cmp;sub init {my$self=shift;my$snobby=shift;my$val=shift;$self->{snobby}=$snobby;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;local$Test::Deep::Snobby=$self->{snobby};Test::Deep::wrap($self->{val})->descend($got)}1;
TEST_DEEP_CLASS

$fatpacked{"Test/Deep/Cmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CMP';
  use strict;use warnings;package Test::Deep::Cmp;use overload '&'=>\&make_all,'|'=>\&make_any,'""'=>\&string,fallback=>1,;use Scalar::Util;sub import {my$pkg=shift;my$callpkg=caller();if ($callpkg =~ /^Test::Deep::/){no strict 'refs';push @{$callpkg."::ISA"},$pkg}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {}sub make_all {my ($e1,$e2)=@_;if (Scalar::Util::blessed($e1)and $e1->isa("Test::Deep::All")){$e1->add($e2);return$e1}elsif(Scalar::Util::blessed($e2)and $e2->isa("Test::Deep::All")){$e2->add($e1);return$e2}else {return Test::Deep::all($e1,$e2)}}sub make_any {my ($e1,$e2)=@_;if (Scalar::Util::blessed($e1)and $e1->isa("Test::Deep::Any")){$e1->add($e2);return$e1}elsif(Scalar::Util::blessed($e2)and $e2->isa("Test::Deep::Any")){$e2->add($e1);return$e2}else {return Test::Deep::any($e1,$e2)}}sub cmp {my ($a1,$a2,$rev)=@_;($a1,$a2)=($a2,$a1)if$rev;return (overload::StrVal($a1)cmp overload::StrVal($a2))}sub string {my$self=shift;return overload::StrVal($self)}sub render_stack {my$self=shift;my$var=shift;return$var}sub renderExp {my$self=shift;return$self->renderGot($self->{val})}sub renderGot {my$self=shift;return Test::Deep::render_val(@_)}sub reset_arrow {return 1}sub data {my$self=shift;return$Test::Deep::Stack->getLast}1;
TEST_DEEP_CMP

$fatpacked{"Test/Deep/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CODE';
  use strict;use warnings;package Test::Deep::Code;use Test::Deep::Cmp;sub init {my$self=shift;my$code=shift || die "No coderef supplied";$self->{code}=$code}sub descend {my$self=shift;my$got=shift;my ($ok,$diag)=&{$self->{code}}($got);$self->data->{diag}=$diag;return$ok}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$error=$last->{diag};my$data=Test::Deep::render_val($last->{got});my$diag=<<EOM;if (defined($error)){$diag .= <<EOM}else {$diag .= <<EOM}return$diag}1;
  Ran coderef at $where on
  
  $data
  EOM
  and it said
  $error
  EOM
  it failed but it didn't say why.
  EOM
TEST_DEEP_CODE

$fatpacked{"Test/Deep/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASH';
  use strict;use warnings;package Test::Deep::Hash;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;return 0 unless Test::Deep::descend($got,$self->hash_keys($exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,$self->hash_elements($exp))}sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::HashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::HashKeys->new(keys %$exp)}sub reset_arrow {return 0}package Test::Deep::SuperHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SuperHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeys->new(keys %$exp)}package Test::Deep::SubHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SubHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeys->new(keys %$exp)}1;
TEST_DEEP_HASH

$fatpacked{"Test/Deep/HashEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHEACH';
  use strict;use warnings;package Test::Deep::HashEach;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my%exp;@exp{keys %$got}=($self->{val})x (keys %$got);return Test::Deep::descend($got,\%exp)}1;
TEST_DEEP_HASHEACH

$fatpacked{"Test/Deep/HashElements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHELEMENTS';
  use strict;use warnings;package Test::Deep::HashElements;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;my$master=$self->getMaster($got,$exp);for my$key (keys %$master){$data->{index}=$key;my$got_elem=exists$got->{$key}? $got->{$key}: $Test::Deep::DNE;my$exp_elem=exists$exp->{$key}? $exp->{$key}: $Test::Deep::DNE;next if Test::Deep::descend($got_elem,$exp_elem);return 0}return 1}sub getMaster {my$self=shift;my ($got,$exp)=@_;return keys %$got > keys %$exp ? $got : $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= '{"'.quotemeta($data->{index}).'"}';return$var}sub reset_arrow {return 0}package Test::Deep::SuperHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$exp}package Test::Deep::SubHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$got}1;
TEST_DEEP_HASHELEMENTS

$fatpacked{"Test/Deep/HashKeys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYS';
  use strict;use warnings;package Test::Deep::HashKeys;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"HASH");return Test::Deep::descend($got,$self->hashkeysonly($exp))}sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::HashKeysOnly->new(keys %$exp)}package Test::Deep::SuperHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeysOnly->new(keys %$exp)}package Test::Deep::SubHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeysOnly->new(keys %$exp)}1;
TEST_DEEP_HASHKEYS

$fatpacked{"Test/Deep/HashKeysOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYSONLY';
  use strict;use warnings;package Test::Deep::HashKeysOnly;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$hash=shift;my$data=$self->data;my$exp=$self->{val};my%got;@got{keys %$hash}=();my@missing;my@extra;while (my ($key,$value)=each %$exp){if (exists$got{$key}){delete$got{$key}}else {push(@missing,$key)}}my@diags;if (@missing and (not $self->ignoreMissing)){push(@diags,"Missing: ".nice_list(\@missing))}if (%got and (not $self->ignoreExtra)){push(@diags,"Extra: ".nice_list([keys%got]))}if (@diags){$data->{diag}=join("\n",@diags);return 0}return 1}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub nice_list {my$list=shift;return join(", ",(map {"'$_'"}sort @$list),)}sub ignoreMissing {return 0}sub ignoreExtra {return 0}package Test::Deep::SuperHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 0}sub ignoreExtra {return 1}package Test::Deep::SubHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 1}sub ignoreExtra {return 0}1;
  Comparing hash keys of $where
  $error
  EOM
TEST_DEEP_HASHKEYSONLY

$fatpacked{"Test/Deep/Ignore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_IGNORE';
  use strict;use warnings;package Test::Deep::Ignore;use Test::Deep::Cmp;my$Singleton=__PACKAGE__->SUPER::new;sub new {return$Singleton}sub descend {return 1}1;
TEST_DEEP_IGNORE

$fatpacked{"Test/Deep/Isa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ISA';
  use strict;use warnings;package Test::Deep::Isa;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)? $got->isa($self->{val}): ref($got)eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into or ref of type '$self->{val}'"}1;
TEST_DEEP_ISA

$fatpacked{"Test/Deep/ListMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_LISTMETHODS';
  use strict;use warnings;package Test::Deep::ListMethods;use base 'Test::Deep::Methods';sub call_method {my$self=shift;return [$self->SUPER::call_method(@_)]}sub render_stack {my$self=shift;my$var=$self->SUPER::render_stack(@_);return "[$var]"}1;
TEST_DEEP_LISTMETHODS

$fatpacked{"Test/Deep/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_MM';
  use strict;use warnings;package Test::Deep::MM;sub import {my$self=shift;my ($pkg)=caller();my$mpkg=$pkg."::Methods";for my$attr (@_){if ($attr =~ /^[a-z]/){no strict 'refs';*{$mpkg."::$attr"}=\&{$attr}}else {my$get_name=$mpkg."::get$attr";my$set_name=$mpkg."::set$attr";my$get_sub=sub {return $_[0]->{$attr}};my$set_sub=sub {return $_[0]->{$attr}=$_[1]};{no strict 'refs';*$get_name=$get_sub;*$set_name=$set_sub;push(@{$pkg."::ISA"},$mpkg)}}}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {my$self=shift;while (@_){my$name=shift || confess("No name");my$method="set$name";$self->$method(shift)}}1;
TEST_DEEP_MM

$fatpacked{"Test/Deep/Methods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_METHODS';
  use strict;use warnings;package Test::Deep::Methods;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my@methods;while (@_){my$name=shift;my$value=shift;push(@methods,[ref($name)? $name : [$name ],$value ])}$self->{methods}=\@methods}sub descend {my$self=shift;my$got=shift;my$data=$self->data;for my$method (@{$self->{methods}}){$data->{method}=$method;my ($call,$exp_res)=@$method;my ($name,@args)=@$call;my$got_res;if (!eval {$got_res=$self->call_method($got,$call);1}){die $@ unless $@ =~ /\ACan't locate object method "\Q$name"/;$got_res=$Test::Deep::DNE}next if Test::Deep::descend($got_res,$exp_res);return 0}return 1}sub call_method {my$self=shift;my ($got,$call)=@_;my ($name,@args)=@$call;return$got->$name(@args)}sub render_stack {my$self=shift;my ($var,$data)=@_;my$method=$data->{method};my ($call,$expect)=@$method;my ($name,@args)=@$call;my$args=@args ? "(".join(", ",@args).")" : "";$var .= "->$name$args";return$var}1;
TEST_DEEP_METHODS

$fatpacked{"Test/Deep/NoTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NOTEST';
  use strict;use warnings;package Test::Deep::NoTest;our$NoTest;{local$NoTest=1;require Test::Deep}sub import {my$import=Test::Deep->can("import");my$pkg=shift;unshift(@_,"Test::Deep");goto &$import}1;
TEST_DEEP_NOTEST

$fatpacked{"Test/Deep/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NUMBER';
  use strict;use warnings;package Test::Deep::Number;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;$self->{val}=shift(@_)+ 0;$self->{tolerance}=shift}sub descend {my$self=shift;my$got=shift;$self->data->{got_string}=$got;{no warnings 'numeric';$got += 0}$self->data->{got}=$got;if (defined(my$tolerance=$self->{tolerance})){return abs($got - $self->{val})<= $tolerance}else {return$got==$self->{val}}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a number"}sub renderGot {my$self=shift;my$val=shift;my$got_string=$self->data->{got_string};if ("$val" ne "$got_string"){$got_string=$self->SUPER::renderGot($got_string);return "$val ($got_string)"}else {return$val}}sub renderExp {my$self=shift;my$exp=$self->{val};if (defined(my$tolerance=$self->{tolerance})){return "$exp +/- $tolerance"}else {return$exp}}1;
TEST_DEEP_NUMBER

$fatpacked{"Test/Deep/Obj.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_OBJ';
  use strict;use warnings;package Test::Deep::Obj;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)&& $got->isa($self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into '$self->{val}' or subclass of '$self->{val}'"}1;
TEST_DEEP_OBJ

$fatpacked{"Test/Deep/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REF';
  use strict;use warnings;package Test::Deep::Ref;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub test_class {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::Snobby){return Test::Deep::descend($got,Test::Deep::blessed(blessed($exp)))}else {return 1}}sub test_reftype {my$self=shift;my$got=shift;my$reftype=shift;return Test::Deep::descend($got,Test::Deep::reftype($reftype))}1;
TEST_DEEP_REF

$fatpacked{"Test/Deep/RefType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REFTYPE';
  use strict;use warnings;package Test::Deep::RefType;use Test::Deep::Cmp;use Scalar::Util qw(reftype);sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$reftype=reftype($got);return Test::Deep::descend($reftype,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "reftype($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(reftype($got))}1;
TEST_DEEP_REFTYPE

$fatpacked{"Test/Deep/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXP';
  use strict;use warnings;package Test::Deep::Regexp;use Test::Deep::Cmp;use Test::Deep::RegexpMatches;sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val;if (my$matches=shift){$self->{matches}=Test::Deep::regexpmatches($matches,$val);$self->{flags}=shift || ""}}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};if (my$match_exp=$self->{matches}){my$flags=$self->{flags};my@match_got;if ($flags eq "g"){@match_got=$got =~ /$re/g}else {@match_got=$got =~ /$re/}if (@match_got){return Test::Deep::descend(\@match_got,$match_exp)}else {return 0}}else {return ($got =~ $re)? 1 : 0}}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub render_stack1 {my$self=shift;my$stack=shift;return "($stack =~ $self->{regex})"}sub renderExp {my$self=shift;return "$self->{val}"}1;
TEST_DEEP_REGEXP

$fatpacked{"Test/Deep/RegexpMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPMATCHES';
  use strict;use warnings;package Test::Deep::RegexpMatches;use Test::Deep::Array;use base 'Test::Deep::Array';use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=Test::Deep::array($val)unless blessed($val)and $val->isa("Test::Deep::Cmp");$self->{val}=$val;$self->{regex}=shift}sub descend {my$self=shift;my$got=shift;return Test::Deep::descend($got,$self->{val})}sub render_stack {my$self=shift;my$stack=shift;$stack="[$stack =~ $self->{regex}]";return$stack}sub reset_arrow {return 1}1;
TEST_DEEP_REGEXPMATCHES

$fatpacked{"Test/Deep/RegexpOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPONLY';
  use strict;use warnings;package Test::Deep::Regexp;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};return$got =~ $self->{val}? 1 : 0}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub renderExp {my$self=shift;return "$self->{val}"}1;
TEST_DEEP_REGEXPONLY

$fatpacked{"Test/Deep/RegexpRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREF';
  use strict;use warnings;package Test::Deep::RegexpRef;use Test::Deep::Ref;use Test::Deep::RegexpVersion;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::RegexpVersion::OldStyle){return 0 unless$self->test_class($got,"Regexp");return 0 unless$self->test_reftype($got,"SCALAR")}else {return 0 unless$self->test_reftype($got,"REGEXP")}return Test::Deep::descend($got,Test::Deep::regexprefonly($exp))}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREF

$fatpacked{"Test/Deep/RegexpRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREFONLY';
  use strict;use warnings;package Test::Deep::RegexpRefOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return$got eq $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;return "m/$var/"}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREFONLY

$fatpacked{"Test/Deep/RegexpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPVERSION';
  use strict;use warnings;package Test::Deep::RegexpVersion;our$OldStyle=($] < 5.011);1;
TEST_DEEP_REGEXPVERSION

$fatpacked{"Test/Deep/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREF';
  use strict;use warnings;package Test::Deep::ScalarRef;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_class($got);return 0 unless$self->test_reftype($got,Scalar::Util::reftype($exp));return Test::Deep::descend($got,Test::Deep::scalarrefonly($exp))}1;
TEST_DEEP_SCALARREF

$fatpacked{"Test/Deep/ScalarRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREFONLY';
  use strict;use warnings;package Test::Deep::ScalarRefOnly;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return Test::Deep::descend($$got,$$exp)}sub render_stack {my$self=shift;my ($var,$data)=@_;return "\${$var}"}1;
TEST_DEEP_SCALARREFONLY

$fatpacked{"Test/Deep/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SET';
  use strict;use warnings;package Test::Deep::Set;use Test::Deep::Cmp;sub init {my$self=shift;$self->{IgnoreDupes}=shift;$self->{SubSup}=shift;$self->{val}=[];$self->add(@_)}sub descend {my$self=shift;my$d1=shift;my$d2=$self->{val};my$IgnoreDupes=$self->{IgnoreDupes};my$data=$self->data;my$SubSup=$self->{SubSup};my$type=$IgnoreDupes ? "Set" : "Bag";my$diag;if (ref$d1 ne 'ARRAY'){my$got=Test::Deep::render_val($d1);$diag=<<EOM}if (not $diag){my@got=@$d1;my@missing;for my$expect (@$d2){my$found=0;for (my$i=$#got;$i >= 0;$i--){if (Test::Deep::eq_deeply_cache($got[$i],$expect)){$found=1;splice(@got,$i,1);last unless$IgnoreDupes}}push(@missing,$expect)unless$found}my@diags;if (@missing and $SubSup ne "sub"){push(@diags,"Missing: ".nice_list(\@missing))}if (@got and $SubSup ne "sup"){my$got=__PACKAGE__->new($IgnoreDupes,"",@got);push(@diags,"Extra: ".nice_list($got->{val}))}$diag=join("\n",@diags)}if ($diag){$data->{diag}=$diag;return 0}else {return 1}}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";$type="Sub$type" if$self->{SubSup}eq "sub";$type="Super$type" if$self->{SubSup}eq "sup";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub add {my$self=shift;my@array=@_;my$IgnoreDupes=$self->{IgnoreDupes};my$already=$self->{val};local$Test::Deep::Expects=1;for my$new_elem (@array){my$want_push=1;my$push_this=$new_elem;for my$old_elem (@$already){if (Test::Deep::eq_deeply($new_elem,$old_elem)){$push_this=$old_elem;$want_push=!$IgnoreDupes;last}}push(@$already,$push_this)if$want_push}@$already=sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@$already}sub nice_list {my$list=shift;my@scalars=grep!ref $_,@$list;my$refs=grep ref $_,@$list;my@ref_string="$refs reference" if$refs;$ref_string[0].= "s" if$refs > 1;return join(", ",(map {Test::Deep::render_val($_)}sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@scalars),@ref_string)}sub compare {my$self=shift;my$other=shift;return 0 if$self->{IgnoreDupes}!=$other->{IgnoreDupes};return Test::Deep::descend($self->{val},$other->{val})}1;
  got    : $got
  expect : An array to use as a $type
  EOM
  Comparing $where as a $type
  $error
  EOM
TEST_DEEP_SET

$fatpacked{"Test/Deep/Shallow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SHALLOW';
  use strict;use warnings;package Test::Deep::Shallow;use Test::Deep::Cmp;use Scalar::Util qw(refaddr);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$ok;if (!defined$got and!defined$exp){$ok=1}elsif (defined$got xor defined$exp){$ok=0}elsif (ref$got and ref$exp){$ok=refaddr($got)==refaddr($exp)}elsif (ref$got xor ref$exp){$ok=0}else {$ok=$got eq $exp}return$ok}1;
TEST_DEEP_SHALLOW

$fatpacked{"Test/Deep/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STACK';
  use strict;use warnings;package Test::Deep::Stack;use Carp qw(confess);use Scalar::Util;use Test::Deep::MM qw(new init Stack Arrow);sub init {my$self=shift;$self->SUPER::init(@_);$self->setStack([])unless$self->getStack}sub push {my$self=shift;push(@{$self->getStack},@_)}sub pop {my$self=shift;return pop @{$self->getStack}}sub render {my$self=shift;my$var=shift;my$stack=$self->getStack;$self->setArrow(0);for my$data (@$stack){my$exp=$data->{exp};if (Scalar::Util::blessed($exp)and $exp->isa("Test::Deep::Cmp")){$var=$exp->render_stack($var,$data);$self->setArrow(0)if$exp->reset_arrow}else {confess "Don't know how to render '$exp'"}}return$var}sub getLast {my$self=shift;return$self->getStack->[-1]}sub incArrow {my$self=shift;my$a=$self->getArrow;$self->setArrow($a + 1);return$a}sub length {my$self=shift;return @{$self->getStack}+ 0}1;
TEST_DEEP_STACK

$fatpacked{"Test/Deep/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STRING';
  use strict;use warnings;package Test::Deep::String;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift()."";$self->data->{got}=$got;return$got eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a string"}1;
TEST_DEEP_STRING

$fatpacked{"Test/Differences.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DIFFERENCES';
  package Test::Differences;our$VERSION="0.62";$VERSION=eval$VERSION;use Exporter;@ISA=qw(Exporter);@EXPORT=qw(eq_or_diff eq_or_diff_text eq_or_diff_data unified_diff context_diff oldstyle_diff table_diff);use strict;use Carp;use Text::Diff;sub _isnt_ARRAY_of_scalars {return 1 if ref ne "ARRAY";return scalar grep ref,@$_}sub _isnt_HASH_of_scalars {return 1 if ref ne "HASH";return scalar grep ref,values %$_}use constant ARRAY_of_scalars=>"ARRAY of scalars";use constant ARRAY_of_ARRAYs_of_scalars=>"ARRAY of ARRAYs of scalars";use constant ARRAY_of_HASHes_of_scalars=>"ARRAY of HASHes of scalars";use constant HASH_of_scalars=>"HASH of scalars";{my$diff_style='Table';my%allowed_style=map {$_=>1}qw/Unified Context OldStyle Table/;sub _diff_style {return$diff_style unless @_;my$requested_style=shift;unless ($allowed_style{$requested_style}){Carp::croak("Uknown style ($requested_style) requested for diff")}$diff_style=$requested_style}}sub unified_diff {_diff_style('Unified')}sub context_diff {_diff_style('Context')}sub oldstyle_diff {_diff_style('OldStyle')}sub table_diff {_diff_style('Table')}sub _grok_type {local $_=shift if @_;return "SCALAR" unless ref;if (ref eq "ARRAY"){return undef unless @$_;return ARRAY_of_scalars unless _isnt_ARRAY_of_scalars;return ARRAY_of_ARRAYs_of_scalars unless grep _isnt_ARRAY_of_scalars,@$_;return ARRAY_of_HASHes_of_scalars unless grep _isnt_HASH_of_scalars,@$_;return 0}elsif (ref eq 'HASH'){return HASH_of_scalars unless _isnt_HASH_of_scalars($_);return 0}}sub _flatten {my$type=shift;local $_=shift if @_;return [split /^/m,_quote_str($_)]unless ref;croak "Can't flatten $_" unless$type;my (@recs,%hash_copy);if (ref $_ eq 'ARRAY'){@recs=@$_}elsif (ref $_ eq 'HASH'){%hash_copy=%$_}else {die "unsupported ref type"}if ($type eq ARRAY_of_scalars){@recs=map {_quote_str($_)}@recs}elsif ($type eq ARRAY_of_ARRAYs_of_scalars){$_=[@$_]for@recs}elsif ($type eq ARRAY_of_HASHes_of_scalars){my%headings;for my$rec (@recs){$headings{$_}=1 for keys %$rec}my@headings=sort keys%headings;for my$rec (@recs){$rec=[map$rec->{$_},@headings ],}unshift@recs,\@headings;$type=ARRAY_of_ARRAYs_of_scalars}elsif ($type eq HASH_of_scalars){my@headings=sort keys%hash_copy;@recs=(\@headings,[map$hash_copy{$_},@headings ]);$type=ARRAY_of_ARRAYs_of_scalars}if ($type eq ARRAY_of_ARRAYs_of_scalars){for my$rec (@recs){for (@$rec){$_=_quote_str($_)}$rec=join ",",@$rec}}return \@recs}sub _quote_str {my$str=shift;return 'undef' unless defined$str;return$str if$str =~ /^[0-9]+$/;$str =~ s{([\\\'])}{\\$1}g;return "'$str'"}sub _identify_callers_test_package_of_choice {my$has_builder_pm=grep $_ eq "Test/Builder.pm",keys%INC;my$has_test_pm=grep $_ eq "Test.pm",keys%INC;return "Test" if$has_test_pm &&!$has_builder_pm;return "Test::Builder" if!$has_test_pm && $has_builder_pm;if ($has_test_pm && $has_builder_pm){return "Test::Builder"}}my$warned_of_unknown_test_lib;sub eq_or_diff_text {$_[3]={data_type=>"text" };goto&eq_or_diff}sub eq_or_diff_data {$_[3]={data_type=>"data" };goto&eq_or_diff}my$joint=chr(0)."A" .chr(1);sub eq_or_diff {my (@vals,$name,$options);$options=pop if @_ > 2 && ref $_[-1];($vals[0],$vals[1],$name)=@_;my($data_type,$filename_a,$filename_b);if($options){$data_type=$options->{data_type};$filename_a=$options->{filename_a};$filename_b=$options->{filename_b}}$data_type ||="text" unless ref$vals[0]|| ref$vals[1];$data_type ||="data";$filename_a ||='Got';$filename_b ||='Expected';my@widths;my@types=map _grok_type,@vals;my$dump_it=!$types[0]||!$types[1];my ($got,$expected);if ($dump_it){require Data::Dumper;local$Data::Dumper::Indent=1;local$Data::Dumper::Purity=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Deepcopy=1;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Sortkeys=exists$options->{Sortkeys}? $options->{Sortkeys}: 1;($got,$expected)=map [split /^/,Data::Dumper::Dumper($_)],@vals}else {($got,$expected)=(_flatten($types[0],$vals[0]),_flatten($types[1],$vals[1]))}my$caller=caller;my$passed =join($joint,@$got)eq join($joint,@$expected);my$diff;unless ($passed){my$context;$context=$options->{context}if exists$options->{context};$context=$dump_it ? 2**31 : grep(@$_ > 25,$got,$expected)? 3 : 25 unless defined$context;confess "context must be an integer: '$context'\n" unless$context =~ /\A\d+\z/;$diff=diff$got,$expected,{CONTEXT=>$context,STYLE=>_diff_style(),FILENAME_A=>$filename_a,FILENAME_B=>$filename_b,OFFSET_A=>$data_type eq "text" ? 1 : 0,OFFSET_B=>$data_type eq "text" ? 1 : 0,INDEX_LABEL=>$data_type eq "text" ? "Ln" : "Elt",};chomp$diff;$diff .= "\n"}my$which=_identify_callers_test_package_of_choice;if ($which eq "Test"){@_ =$passed ? ("","",$name): ("\n$diff","No differences",$name);goto&Test::ok}elsif ($which eq "Test::Builder"){my$test=Test::Builder->new;$test->ok($passed,$name);$test->diag($diff)unless$passed}else {unless ($warned_of_unknown_test_lib){Carp::cluck "Can't identify test lib in use, doesn't seem to be Test.pm or Test::Builder based\n";$warned_of_unknown_test_lib=1}if ($passed){print "ok\n"}else {$diff =~ s/^/# /gm;print "not ok\n",$diff}}}1;
TEST_DIFFERENCES

$fatpacked{"Test/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_EXCEPTION';
  use strict;use warnings;package Test::Exception;use Test::Builder;use Sub::Uplevel qw(uplevel);use base qw(Exporter);our$VERSION='0.35';our@EXPORT=qw(dies_ok lives_ok throws_ok lives_and);my$Tester=Test::Builder->new;sub import {my$self=shift;if (@_){my$package=caller;$Tester->exported_to($package);$Tester->plan(@_)};$self->export_to_level(1,$self,$_)foreach@EXPORT}sub _quiet_caller (;$) {my$height=$_[0];$height++;if (CORE::caller()eq 'DB'){package DB;if(wantarray){if (!@_){return (CORE::caller($height))[0..2]}else {my@frame_info=CORE::caller($height);@DB::args=();return@frame_info}}return CORE::caller($height)}else {if(wantarray and!@_){return (CORE::caller($height))[0..2]}else {return CORE::caller($height)}}}sub _try_as_caller {my$coderef=shift;local*CORE::GLOBAL::caller;{no warnings 'redefine';*CORE::GLOBAL::caller=\&_quiet_caller}eval {uplevel 3,$coderef};return $@};sub _is_exception {my$exception=shift;return ref$exception || $exception ne ''};sub _exception_as_string {my ($prefix,$exception)=@_;return "$prefix normal exit" unless _is_exception($exception);my$class=ref$exception;$exception="$class ($exception)" if$class && "$exception" !~ m/^\Q$class/;chomp$exception;return "$prefix $exception"};sub throws_ok (&$;$) {my ($coderef,$expecting,$description)=@_;unless (defined$expecting){require Carp;Carp::croak("throws_ok: must pass exception class/object or regex")}$description=_exception_as_string("threw",$expecting)unless defined$description;my$exception=_try_as_caller($coderef);my$regex=$Tester->maybe_regex($expecting);my$ok=$regex ? ($exception =~ m/$regex/): eval {$exception->isa(ref$expecting ? ref$expecting : $expecting)};$Tester->ok($ok,$description);unless ($ok){$Tester->diag(_exception_as_string("expecting:",$expecting));$Tester->diag(_exception_as_string("found:",$exception))};$@=$exception;return$ok};sub dies_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(_is_exception($exception),$description);$@=$exception;return$ok}sub lives_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(!_is_exception($exception),$description);$Tester->diag(_exception_as_string("died:",$exception))unless$ok;$@=$exception;return$ok}my$is_stream=eval {require Test::Stream;require Test::Stream::Event::Ok;1};our$LIVES_AND_NAME;if ($is_stream){Test::Stream->shared->munge(sub {return unless defined$LIVES_AND_NAME;my ($stream,$e)=@_;return unless$e->isa('Test::Stream::Event::Ok');return if defined$e->name;$e->set_name($LIVES_AND_NAME)})}sub lives_and (&;$) {my ($test,$description)=@_;if ($is_stream){local$LIVES_AND_NAME=$description;eval {$test->()}and return 1}else {local$Test::Builder::Level=$Test::Builder::Level + 1;my$ok=\&Test::Builder::ok;no warnings;local*Test::Builder::ok=sub {$_[2]=$description unless defined $_[2];$ok->(@_)};use warnings;eval {$test->()}and return 1};my$exception=$@;if (_is_exception($exception)){$Tester->ok(0,$description);$Tester->diag(_exception_as_string("died:",$exception))};$@=$exception;return}1;
TEST_EXCEPTION

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;{$Test::Fatal::VERSION='0.013'}use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=$Test::Builder::Level - $REAL_CALCULATED_TBL;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||=Test::Builder->new;my$ok=$Tester->ok(exception(\&$code),$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||=Test::Builder->new;my$ok=$Tester->ok(!exception(\&$code),$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_HARNESS';
  package Test::Harness;use 5.006;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Harness ();use TAP::Parser::Aggregator ();use TAP::Parser::Source ();use TAP::Parser::SourceHandler::Perl ();use Text::ParseWords qw(shellwords);use Config;use base 'Exporter';BEGIN {eval q{use Time::HiRes 'time'};our$has_time_hires=!$@}our$VERSION='3.33';*verbose=*Verbose;*switches=*Switches;*debug=*Debug;$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}our@EXPORT=qw(&runtests);our@EXPORT_OK=qw(&execute_tests $verbose $switches);our$Verbose=$ENV{HARNESS_VERBOSE}|| 0;our$Debug=$ENV{HARNESS_DEBUG}|| 0;our$Switches='-w';our$Columns=$ENV{HARNESS_COLUMNS}|| $ENV{COLUMNS}|| 80;$Columns--;our$Timer=$ENV{HARNESS_TIMER}|| 0;our$Color=$ENV{HARNESS_COLOR}|| 0;our$IgnoreExit=$ENV{HARNESS_IGNORE_EXIT}|| 0;sub _has_taint {my$test=shift;return TAP::Parser::SourceHandler::Perl->get_taint(TAP::Parser::Source->shebang($test))}sub _aggregate {my ($harness,$aggregate,@tests)=@_;local$ENV{HARNESS_OPTIONS};_apply_extra_INC($harness);_aggregate_tests($harness,$aggregate,@tests)}sub _apply_extra_INC {my$harness=shift;$harness->callback(parser_args=>sub {my ($args,$test)=@_;push @{$args->{switches}},map {"-I$_"}_filtered_inc()})}sub _aggregate_tests {my ($harness,$aggregate,@tests)=@_;$aggregate->start();$harness->aggregate_tests($aggregate,@tests);$aggregate->stop()}sub runtests {my@tests=@_;local ($\,$,);my$harness=_new_harness();my$aggregate=TAP::Parser::Aggregator->new();_aggregate($harness,$aggregate,@tests);$harness->formatter->summary($aggregate);my$total=$aggregate->total;my$passed=$aggregate->passed;my$failed=$aggregate->failed;my@parsers=$aggregate->parsers;my$num_bad=0;for my$parser (@parsers){$num_bad++ if$parser->has_problems}die(sprintf("Failed %d/%d test programs. %d/%d subtests failed.\n",$num_bad,scalar@parsers,$failed,$total))if$num_bad;return$total && $total==$passed}sub _canon {my@list=sort {$a <=> $b}@_;my@ranges=();my$count=scalar@list;my$pos=0;while ($pos < $count){my$end=$pos + 1;$end++ while$end < $count && $list[$end]<= $list[$end - 1 ]+ 1;push@ranges,($end==$pos + 1)? $list[$pos]: join('-',$list[$pos],$list[$end - 1 ]);$pos=$end}return join(' ',@ranges)}sub _new_harness {my$sub_args=shift || {};my (@lib,@switches);my@opt=map {shellwords($_)}grep {defined}$Switches,$ENV{HARNESS_PERL_SWITCHES};while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@lib,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@lib,_filtered_inc()if IS_VMS;my$verbosity=($Verbose ? ($Verbose !~ /\d/)? 1 : $Verbose : 0);my$args={timer=>$Timer,directives=>our$Directives,lib=>\@lib,switches=>\@switches,color=>$Color,verbosity=>$verbosity,ignore_exit=>$IgnoreExit,};$args->{stdout}=$sub_args->{out}if exists$sub_args->{out};my$class=$ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args->{jobs}=$1 || 9}elsif ($opt eq 'c'){$args->{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args->{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class="TAP::Harness::Archive";$args->{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Harness->_construct($class,$args)}sub _filtered_inc {my@inc=grep {!ref}@INC;if (IS_VMS){@inc=grep!/perl_root/i,@inc}elsif (IS_WIN32){s/[\\\/]+$// for@inc}my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}{my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}}sub _check_sequence {my@list=@_;my$prev;while (my$next=shift@list){return if defined$prev && $next <= $prev;$prev=$next}return 1}sub execute_tests {my%args=@_;my$harness=_new_harness(\%args);my$aggregate=TAP::Parser::Aggregator->new();my%tot=(bonus=>0,max=>0,ok=>0,bad=>0,good=>0,files=>0,tests=>0,sub_skipped=>0,todo=>0,skipped=>0,bench=>undef,);$harness->callback(made_parser=>sub {my$parser=shift;$parser->callback(plan=>sub {my$plan=shift;if ($plan->directive eq 'SKIP'){$tot{skipped}++}})});_aggregate($harness,$aggregate,@{$args{tests}});$tot{bench}=$aggregate->elapsed;my@tests=$aggregate->descriptions;$tot{files}=$tot{tests}=scalar@tests;my%failedtests=();my%todo_passed=();for my$test (@tests){my ($parser)=$aggregate->parsers($test);my@failed=$parser->failed;my$wstat=$parser->wait;my$estat=$parser->exit;my$planned=$parser->tests_planned;my@errors=$parser->parse_errors;my$passed=$parser->passed;my$actual_passed=$parser->actual_passed;my$ok_seq=_check_sequence($parser->actual_passed);$estat ||='' unless$wstat;$wstat ||='';$tot{max}+= ($planned || 0);$tot{bonus}+= $parser->todo_passed;$tot{ok}+= $passed > $actual_passed ? $passed : $actual_passed;$tot{sub_skipped}+= $parser->skipped;$tot{todo}+= $parser->todo;if (@failed || $estat || @errors){$tot{bad}++;my$huh_planned=$planned ? undef : '??';my$huh_errors=$ok_seq ? undef : '??';$failedtests{$test}={'canon'=>$huh_planned || $huh_errors || _canon(@failed)|| '??','estat'=>$estat,'failed'=>$huh_planned || $huh_errors || scalar@failed,'max'=>$huh_planned || $planned,'name'=>$test,'wstat'=>$wstat }}else {$tot{good}++}my@todo=$parser->todo_passed;if (@todo){$todo_passed{$test}={'canon'=>_canon(@todo),'estat'=>$estat,'failed'=>scalar@todo,'max'=>scalar$parser->todo,'name'=>$test,'wstat'=>$wstat }}}return (\%tot,\%failedtests,\%todo_passed)}1;
TEST_HARNESS

$fatpacked{"Test/Most.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOST';
  package Test::Most;use warnings;use strict;use Test::Most::Exception 'throw_failure';use Test::Builder::Module;our (@ISA,@EXPORT,$DATA_DUMPER_NAMES_INSTALLED);my$HAVE_TIME_HIRES;BEGIN {require Test::More;if (Test::More->can('TB_PROVIDER_META')){Test::More->import(import=>['!explain' ])}else {@Test::More::EXPORT=grep {$_ ne 'explain'}@Test::More::EXPORT;Test::More->import}eval "use Time::HiRes";$HAVE_TIME_HIRES=1 unless $@}use Test::Builder;my$OK_FUNC;BEGIN {$OK_FUNC=\&Test::Builder::ok}our$VERSION='0.34';$VERSION=eval$VERSION;BEGIN {@ISA=qw(Test::Builder::Module);@EXPORT=(Test::More->can('TB_PROVIDER_META')? grep {$_ ne 'TODO'}keys(%{Test::More->TB_PROVIDER_META->{attrs}}): @Test::More::EXPORT,qw<$TODO all_done bail_on_fail die_on_fail explain always_explain last_test_failed restore_fail set_failure_handler show always_show>)}sub import {my$bail_set=0;my%modules_to_load=map {$_=>1}qw/Test::Differences Test::Exception Test::Deep Test::Warn/;warnings->import;strict->import;eval "use Data::Dumper::Names 0.03";$DATA_DUMPER_NAMES_INSTALLED=!$@;if ($ENV{BAIL_ON_FAIL}){$bail_set=1;bail_on_fail()}if (!$bail_set and $ENV{DIE_ON_FAIL}){die_on_fail()}for my$i (0 .. $#_){if ('bail' eq $_[$i]){splice @_,$i,1;bail_on_fail();$bail_set=1;last}}my$caller=caller;for my$i (0 .. $#_){if ('timeit' eq $_[$i]){splice @_,$i,1;no strict;*{"${caller}::timeit"}=\&timeit;last}}my%exclude_symbol;my$i=0;for my$do_not_import_by_default (qw/blessed reftype/){if (grep {$_ eq $do_not_import_by_default}@_){@_=grep {$_ ne $do_not_import_by_default}@_}else {$exclude_symbol{$do_not_import_by_default}=1}}while ($i < @_){if (!$bail_set and ('die' eq $_[$i])){splice @_,$i,1;die_on_fail();$i=0;next}if ($_[$i]=~ /^-(.*)/){my$module=$1;splice @_,$i,1;unless (exists$modules_to_load{$module}){require Carp;Carp::croak("Cannot remove non-existent Test::Module ($module)")}delete$modules_to_load{$module};$i=0;next}if ($_[$i]=~ /^!(.*)/){splice @_,$i,1;$exclude_symbol{$1}=1;$i=0;next}if ('defer_plan' eq $_[$i]){require Carp;Carp::carp(<<'END')unless$ENV{DO_NOT_WARN_ON_DEFER_PLAN};splice @_,$i,1;my$builder=Test::Builder->new;$builder->{Have_Plan}=1;$builder->{TEST_MOST_deferred_plan}=1;$builder->{TEST_MOST_all_done}=0;$i=0;next}$i++}for my$module (keys%modules_to_load){eval "use $module";if (my$error=$@){require Carp;Carp::croak($error)}no strict 'refs';push@EXPORT=>grep {!$exclude_symbol{$_}}@{"${module}::EXPORT"}}goto&Test::Builder::Module::import}sub explain {_explain(\&Test::More::note,@_)}sub timeit(&;$) {my ($code,$message)=@_;unless($HAVE_TIME_HIRES){Test::Most::diag("timeit: Time::HiRes not installed");$code->()}if (!$message){my ($package,$filename,$line)=caller;$message="$filename line $line"}my$start=[Time::HiRes::gettimeofday()];$code->();explain(sprintf "$message: took %s seconds"=>Time::HiRes::tv_interval($start))}sub always_explain {_explain(\&Test::More::diag,@_)}sub _explain {my$diag=shift;no warnings 'once';$diag->(map {ref $_ ? do {require Data::Dumper;local$Data::Dumper::Indent=1;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Terse=1;Data::Dumper::Dumper($_)}: $_}@_)}sub show {_show(\&Test::More::note,@_)}sub always_show {_show(\&Test::More::diag,@_)}sub _show {unless ($DATA_DUMPER_NAMES_INSTALLED){require Carp;Carp::carp("Data::Dumper::Names 0.03 not found.  Use explain() instead of show()");goto&_explain}my$diag=shift;no warnings 'once';local$Data::Dumper::Indent=1;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Names::UpLevel=$Data::Dumper::Names::UpLevel + 2;$diag->(Data::Dumper::Names::Dumper(@_))}sub die_on_fail {set_failure_handler(sub {throw_failure})}sub bail_on_fail {set_failure_handler(sub {Test::More::BAIL_OUT("Test failed.  BAIL OUT!.\n")})}sub restore_fail {no warnings 'redefine';*Test::Builder::ok=$OK_FUNC}sub all_done {my$builder=Test::Builder->new;if ($builder->{TEST_MOST_deferred_plan}){$builder->{TEST_MOST_all_done}=1;$builder->expected_tests(@_ ? $_[0]: $builder->current_test)}}sub set_failure_handler {my$action=shift;no warnings 'redefine';Test::Builder->new->{TEST_MOST_failure_action}=$action;*Test::Builder::ok=sub {local$Test::Builder::Level=$Test::Builder::Level + 1;my$builder=$_[0];if ($builder->{TEST_MOST_test_failed}){$builder->{TEST_MOST_test_failed}=0;$action->($builder)}$builder->{TEST_MOST_test_failed}=0;my$result=$OK_FUNC->(@_);$builder->{TEST_MOST_test_failed}=!($builder->summary)[-1];return$result}}{no warnings 'redefine';sub Test::Builder::DESTROY {my$builder=$_[0];if ($builder->{TEST_MOST_test_failed}){($builder->{TEST_MOST_failure_action}|| sub {})->()}}}sub _deferred_plan_handler {my$builder=Test::Builder->new;if ($builder->{TEST_MOST_deferred_plan}and!$builder->{TEST_MOST_all_done}){$builder->expected_tests($builder->current_test + 1)}}END {_deferred_plan_handler()}1;
  defer_plan() is deprecated and will be removed in a future release of
  Test::Most. It's functionality is provided by Test::More's done_testing(),
  first added in 2009 (0.88).
  END
TEST_MOST

$fatpacked{"Test/Most/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOST_EXCEPTION';
  package Test::Most::Exception;use warnings;use strict;use base 'Exporter';our@EXPORT_OK=('throw_failure');our$VERSION='0.34';$VERSION=eval$VERSION;use Exception::Class 'Test::Most::Exception'=>{alias=>'throw_failure',description=>'Test failed.  Stopping test.',};1;
TEST_MOST_EXCEPTION

$fatpacked{"Test/NoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS';
  package Test::NoWarnings;use 5.006;use strict;use warnings;use Carp ();use Exporter ();use Test::Builder ();use Test::NoWarnings::Warning ();use vars qw($VERSION @EXPORT_OK @ISA $do_end_test);BEGIN {$VERSION='1.04';@ISA='Exporter';@EXPORT_OK=qw(clear_warnings had_no_warnings warnings);$do_end_test=0}my$TEST=Test::Builder->new;my$PID=$$;my@WARNINGS=();my$EARLY=0;$SIG{__WARN__}=make_catcher(\@WARNINGS);sub import {$do_end_test=1;if (grep {$_ eq ':early'}@_){@_=grep {$_ ne ':early'}@_;$EARLY=1}goto&Exporter::import}END {had_no_warnings()if$do_end_test}sub make_warning {local$SIG{__WARN__};my$msg=shift;my$warning=Test::NoWarnings::Warning->new;$warning->setMessage($msg);$warning->fillTest($TEST);$warning->fillTrace(__PACKAGE__);$Carp::Internal{__PACKAGE__.""}++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$warning->fillCarp($msg);$Carp::Internal{__PACKAGE__.""}--;return$warning}sub make_catcher {my$array=shift;return sub {my$msg=shift;$Carp::Internal{__PACKAGE__.""}++;push(@$array,make_warning($msg));$Carp::Internal{__PACKAGE__.""}--;if ($EARLY){$TEST->diag($array->[-1]->toString)}return$msg}}sub had_no_warnings {return 0 if $$!=$PID;local$SIG{__WARN__};my$name=shift || "no warnings";my$ok;my$diag;if (@WARNINGS==0){$ok=1}else {$ok=0;$diag="There were " .scalar(@WARNINGS)." warning(s)\n";unless ($EARLY){$diag .= join "----------\n",map {$_->toString}@WARNINGS}}$TEST->ok($ok,$name)|| $TEST->diag($diag);return$ok}sub clear_warnings {local$SIG{__WARN__};@WARNINGS=()}sub warnings {local$SIG{__WARN__};return@WARNINGS}sub builder {local$SIG{__WARN__};if (@_){$TEST=shift}return$TEST}1;
TEST_NOWARNINGS

$fatpacked{"Test/NoWarnings/Warning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS_WARNING';
  package Test::NoWarnings::Warning;use 5.006;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='1.04';eval "require Devel::StackTrace"}sub new {my$class=shift;bless {@_ },$class}sub getTrace {$_[0]->{Trace}}sub fillTrace {my$self=shift;$self->{Trace}=Devel::StackTrace->new(ignore_class=>[__PACKAGE__,@_],)if$Devel::StackTrace::VERSION}sub getCarp {$_[0]->{Carp}}sub fillCarp {my$self=shift;my$msg=shift;$Carp::Internal{__PACKAGE__ ."" }++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->{Carp}=Carp::longmess($msg);$Carp::Internal{__PACKAGE__ ."" }--}sub getMessage {$_[0]->{Message}}sub setMessage {$_[0]->{Message}=$_[1]}sub fillTest {my$self=shift;my$builder=shift;my$prev_test=$builder->current_test;$self->{Test}=$prev_test;my@tests=$builder->details;my$prev_test_name=$prev_test ? $tests[$prev_test - 1]->{name}: "";$self->{TestName}=$prev_test_name}sub getTest {$_[0]->{Test}}sub getTestName {$_[0]->{TestName}}sub toString {my$self=shift;return <<EOM}1;
  	Previous test $self->{Test} '$self->{TestName}'
  	$self->{Carp}
  EOM
TEST_NOWARNINGS_WARNING

$fatpacked{"Test/Requires.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES';
  package Test::Requires;use strict;use warnings;our$VERSION='0.08';use base 'Test::Builder::Module';use 5.006000;sub import {my$class=shift;my$caller=caller(0);{no strict 'refs';*{"$caller\::test_requires"}=\&test_requires}if (@_==1 && ref $_[0]&& ref $_[0]eq 'HASH'){while (my ($mod,$ver)=each %{$_[0]}){test_requires($mod,$ver,$caller)}}else {for my$mod (@_){test_requires($mod,undef,$caller)}}}sub test_requires {my ($mod,$ver,$caller)=@_;return if$mod eq __PACKAGE__;if (@_!=3){$caller=caller(0)}$ver ||='';eval qq{package $caller; use $mod $ver};if (my$e=$@){my$skip_all=sub {my$builder=__PACKAGE__->builder;if (not defined$builder->has_plan){$builder->skip_all(@_)}elsif ($builder->has_plan eq 'no_plan'){$builder->skip(@_);if ($builder->can('parent')&& $builder->parent){die bless {}=>'Test::Builder::Exception'}exit 0}else {for (1..$builder->has_plan){$builder->skip(@_)}if ($builder->can('parent')&& $builder->parent){die bless {}=>'Test::Builder::Exception'}exit 0}};my$msg="$e";if ($e =~ /^Can't locate/){$msg="Test requires module '$mod' but it's not found"}if ($ENV{RELEASE_TESTING}){__PACKAGE__->builder->BAIL_OUT($msg)}else {$skip_all->($msg)}}}1;
TEST_REQUIRES

$fatpacked{"Test/Script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SCRIPT';
  package Test::Script;use 5.005;use strict;use Carp ();use Exporter ();use File::Spec ();use File::Spec::Unix ();use Probe::Perl ();use IPC::Run3 ();use Test::Builder ();use vars qw{$VERSION @ISA @EXPORT};BEGIN {$VERSION='1.07';@ISA='Exporter';@EXPORT=qw{script_compiles script_compiles_ok script_runs}}sub import {my$self=shift;my$pack=caller;my$test=Test::Builder->new;$test->exported_to($pack);$test->plan(@_);for (@EXPORT){$self->export_to_level(1,$self,$_)}}my$perl=undef;sub perl () {$perl or $perl=Probe::Perl->find_perl_interpreter}sub path ($) {my$path=shift;unless (defined$path){Carp::croak("Did not provide a script name")}if (File::Spec::Unix->file_name_is_absolute($path)){Carp::croak("Script name must be relative")}File::Spec->catfile(File::Spec->curdir,split /\//,$path)}sub script_compiles {my$args=_script(shift);my$unix=shift @$args;my$path=path($unix);my$cmd=[perl,'-Mblib','-c',$path,@$args ];my$stdin='';my$stdout='';my$stderr='';my$rv=IPC::Run3::run3($cmd,\$stdin,\$stdout,\$stderr);my$exit=$? ? ($? >> 8): 0;my$ok=!!($rv and $exit==0 and $stderr =~ /syntax OK\s+\z/si);my$test=Test::Builder->new;$test->ok($ok,$_[0]|| "Script $unix compiles");$test->diag("$exit - $stderr")unless$ok;return$ok}sub script_runs {my$args=_script(shift);my$unix=shift @$args;my$path=path($unix);my$cmd=[perl,'-Mblib',$path,@$args ];my$stdin='';my$stdout='';my$stderr='';my$rv=IPC::Run3::run3($cmd,\$stdin,\$stdout,\$stderr);my$exit=$? ? ($? >> 8): 0;my$ok=!!($rv and $exit==0);my$test=Test::Builder->new;$test->ok($ok,$_[0]|| "Script $unix runs");$test->diag("$exit - $stderr")unless$ok;return$ok}sub _script {my$in=shift;if (defined _STRING($in)){return [$in ]}if (_ARRAY($in)){unless (scalar grep {not defined _STRING($_)}@$in){return$in}}Carp::croak("Invalid command parameter")}sub _ARRAY ($) {(ref $_[0]eq 'ARRAY' and @{$_[0]})? $_[0]: undef}sub _STRING ($) {(defined $_[0]and!ref $_[0]and length($_[0]))? $_[0]: undef}BEGIN {*script_compiles_ok=*script_compiles}1;
TEST_SCRIPT

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;package Test::Tester;BEGIN {if (*Test::Builder::new{CODE}){warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"}}use Test::Builder;use Test::Tester::CaptureRunner;use Test::Tester::Delegate;require Exporter;use vars qw(@ISA @EXPORT $VERSION);$VERSION="0.109";@EXPORT=qw(run_tests check_tests check_test cmp_results show_space);@ISA=qw(Exporter);my$Test=Test::Builder->new;my$Capture=Test::Tester::Capture->new;my$Delegator=Test::Tester::Delegate->new;$Delegator->{Object}=$Test;my$runner=Test::Tester::CaptureRunner->new;my$want_space=$ENV{TESTTESTERSPACE};sub show_space {$want_space=1}my$colour='';my$reset='';if (my$want_colour=$ENV{TESTTESTERCOLOUR}|| $ENV{TESTTESTERCOLOUR}){if (eval "require Term::ANSIColor"){my ($f,$b)=split(",",$want_colour);$colour=Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");$reset=Term::ANSIColor::color("reset")}}sub new_new {return$Delegator}sub capture {return Test::Tester::Capture->new}sub fh {$runner=Test::Tester::FHRunner->new;return$Test}sub find_run_tests {my$d=1;my$found=0;while ((not $found)and (my ($sub)=(caller($d))[3])){$found=($sub eq "Test::Tester::run_tests");$d++}return$d}sub run_tests {local($Delegator->{Object})=$Capture;$runner->run_tests(@_);return ($runner->get_premature,$runner->get_results)}sub check_test {my$test=shift;my$expect=shift;my$name=shift;$name="" unless defined($name);@_=($test,[$expect],$name);goto&check_tests}sub check_tests {my$test=shift;my$expects=shift;my$name=shift;$name="" unless defined($name);my ($prem,@results)=eval {run_tests($test,$name)};$Test->ok(!$@,"Test '$name' completed")|| $Test->diag($@);$Test->ok(!length($prem),"Test '$name' no premature diagnostication")|| $Test->diag("Before any testing anything, your tests said\n$prem");local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_results(\@results,$expects,$name);return ($prem,@results)}sub cmp_field {my ($result,$expect,$field,$desc)=@_;if (defined$expect->{$field}){$Test->is_eq($result->{$field},$expect->{$field},"$desc compare $field")}}sub cmp_result {my ($result,$expect,$name)=@_;my$sub_name=$result->{name};$sub_name="" unless defined($name);my$desc="subtest '$sub_name' of '$name'";{local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_field($result,$expect,"ok",$desc);cmp_field($result,$expect,"actual_ok",$desc);cmp_field($result,$expect,"type",$desc);cmp_field($result,$expect,"reason",$desc);cmp_field($result,$expect,"name",$desc)}my$depth=1;if (exists$expect->{depth}){$depth=$expect->{depth}}if (defined$depth){$Test->is_eq($result->{depth},$depth,"checking depth")|| $Test->diag('You need to change $Test::Builder::Level')}if (defined(my$exp=$expect->{diag})){$exp .= "\n" if (length($exp)and $exp !~ /\n$/);if (not $Test->ok($result->{diag}eq $exp,"subtest '$sub_name' of '$name' compare diag")){my$got=$result->{diag};my$glen=length($got);my$elen=length($exp);for ($got,$exp){my@lines=split("\n",$_);$_=join("\n",map {if ($want_space){$_=$colour.escape($_).$reset}else {"'$colour$_$reset'"}}@lines)}$Test->diag(<<EOM)}}}sub escape {my$str=shift;my$res='';for my$char (split("",$str)){my$c=ord($char);if(($c>32 and $c<125)or $c==10){$res .= $char}else {$res .= sprintf('\x{%x}',$c)}}return$res}sub cmp_results {my ($results,$expects,$name)=@_;$Test->is_num(scalar @$results,scalar @$expects,"Test '$name' result count");for (my$i=0;$i < @$expects;$i++){my$expect=$expects->[$i];my$result=$results->[$i];local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_result($result,$expect,$name)}}sub plan {my(@plan)=@_;my$caller=caller;$Test->exported_to($caller);my@imports=();for my$idx (0..$#plan){if($plan[$idx]eq 'import'){my($tag,$imports)=splice@plan,$idx,2;@imports=@$imports;last}}$Test->plan(@plan);__PACKAGE__->_export_to_level(1,__PACKAGE__,@imports)}sub import {my($class)=shift;{no warnings 'redefine';*Test::Builder::new=\&new_new}goto&plan}sub _export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}1;
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;package Test::Tester::Capture;use Test::Builder;use vars qw(@ISA);@ISA=qw(Test::Builder);BEGIN {use Config;if($] >= 5.008 && $Config{useithreads}){require threads::shared;threads::shared->import}else {*share=sub {0};*lock=sub {0}}}my$Curr_Test=0;share($Curr_Test);my@Test_Results=();share(@Test_Results);my$Prem_Diag={diag=>""};share($Curr_Test);sub new {my$class=shift;return bless {},$class}sub ok {my($self,$test,$name)=@_;$test=$test ? 1 : 0;lock$Curr_Test;$Curr_Test++;my($pack,$file,$line)=$self->caller;my$todo=$self->todo($pack);my$result={};share($result);unless($test){@$result{'ok','actual_ok' }=(($todo ? 1 : 0),0)}else {@$result{'ok','actual_ok' }=(1,$test)}if(defined$name){$name =~ s|#|\\#|g;$result->{name}=$name}else {$result->{name}=''}if($todo){my$what_todo=$todo;$result->{reason}=$what_todo;$result->{type}='todo'}else {$result->{reason}='';$result->{type}=''}$Test_Results[$Curr_Test-1]=$result;unless($test){my$msg=$todo ? "Failed (TODO)" : "Failed";$result->{fail_diag}=("	$msg test ($file at line $line)\n")}$result->{diag}="";$result->{_level}=$Test::Builder::Level;$result->{_depth}=Test::Tester::find_run_tests();return$test ? 1 : 0}sub skip {my($self,$why)=@_;$why ||='';lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>1,name=>'',type=>'skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;return 1}sub todo_skip {my($self,$why)=@_;$why ||='';lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>0,name=>'',type=>'todo_skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;return 1}sub diag {my($self,@msgs)=@_;return unless@msgs;return if $^C;for (@msgs){$_='undef' unless defined}push@msgs,"\n" unless$msgs[-1]=~ /\n\Z/;my$result=$Curr_Test ? $Test_Results[$Curr_Test - 1]: $Prem_Diag;$result->{diag}.= join("",@msgs);return 0}sub details {return@Test_Results}sub note {}sub explain {return Test::Builder::explain(@_)}sub premature {return$Prem_Diag->{diag}}sub current_test {if (@_ > 1){die "Don't try to change the test number!"}else {return$Curr_Test}}sub reset {$Curr_Test=0;@Test_Results=();$Prem_Diag={diag=>""}}1;
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  use strict;package Test::Tester::CaptureRunner;use Test::Tester::Capture;require Exporter;sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub run_tests {my$self=shift;my$test=shift;capture()->reset;$self->{StartLevel}=$Test::Builder::Level;&$test()}sub get_results {my$self=shift;my@results=capture()->details;my$start=$self->{StartLevel};for my$res (@results){next if defined$res->{depth};my$depth=$res->{_depth}- $res->{_level}- $start - 3;$res->{depth}=$depth}return@results}sub get_premature {return capture()->premature}sub capture {return Test::Tester::Capture->new}
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;use warnings;package Test::Tester::Delegate;use vars '$AUTOLOAD';sub new {my$pkg=shift;my$obj=shift;my$self=bless {},$pkg;return$self}sub AUTOLOAD {my ($sub)=$AUTOLOAD =~ /.*::(.*?)$/;return if$sub eq "DESTROY";my$obj=$_[0]->{Object};my$ref=$obj->can($sub);shift(@_);unshift(@_,$obj);goto &$ref}1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/Warn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_WARN';
  package Test::Warn;use 5.006;use strict;use warnings;use Sub::Uplevel 0.12;our$VERSION='0.30';require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=('all'=>[qw(@EXPORT) ]);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=qw(warning_is warnings_are warning_like warnings_like warnings_exist);use Test::Builder;my$Tester=Test::Builder->new;{no warnings 'once';*warning_is=*warnings_are;*warning_like=*warnings_like}sub warnings_are (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_is(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_like (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_exist (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);my$wrn_text=shift;my$wrn_rec=_canonical_got_warning($called_from,$wrn_text);for my$wrn (@exp_warning){if (_cmp_got_to_exp_warning_like($wrn_rec,$wrn)){push@got_warning,$wrn_rec;return}}warn$wrn_text};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub _to_array_if_necessary {return (ref($_[0])eq 'ARRAY')? @{$_[0]}: ($_[0])}sub _canonical_got_warning {my ($called_from,$msg)=@_;my$warn_kind=$called_from eq 'Carp' ? 'carped' : 'warn';my@warning_stack=split /\n/,$msg;return {$warn_kind=>$warning_stack[0]}}sub _canonical_exp_warning {my ($exp)=@_;if (ref($exp)eq 'HASH'){my$to_carp=$exp->{carped}or return;return (ref($to_carp)eq 'ARRAY')? map({{carped=>$_}}grep {defined $_}@$to_carp): +{carped=>$to_carp}}return {warn=>$exp}}sub _cmp_got_to_exp_warning {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');my$cmp=$got_msg =~ /^\Q$exp_msg\E at .+ line \d+\.?$/;return$cmp}sub _cmp_got_to_exp_warning_like {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');if (my$re=$Tester->maybe_regex($exp_msg)){my$cmp=$got_msg =~ /$re/;return$cmp}else {return Test::Warn::Categorization::warning_like_category($got_msg,$exp_msg)}}sub _cmp_is {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&=_cmp_got_to_exp_warning($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _cmp_like {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&=_cmp_got_to_exp_warning_like($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _diag_found_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("found carped warning: ${$_}{carped}"): $Tester->diag("found warning: ${$_}{warn}")}else {$Tester->diag("found warning: $_")}}$Tester->diag("didn't find a warning")unless @_}sub _diag_exp_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("expected to find carped warning: ${$_}{carped}"): $Tester->diag("expected to find warning: ${$_}{warn}")}else {$Tester->diag("expected to find warning: $_")}}$Tester->diag("didn't expect to find a warning")unless @_}package Test::Warn::Categorization;use Carp;my$bits=\%warnings::Bits;my@warnings=sort grep {my$warn_bits=$bits->{$_}}keys %$bits;my%warnings_in_category=('utf8'=>['Wide character in \w+\b',],);sub _warning_category_regexp {my$category=shift;my$category_bits=$bits->{$category}or return;my@category_warnings =grep {($bits->{$_}& $category_bits)eq $bits->{$_}}@warnings;my@list=map {exists$warnings_in_category{$_}? (@{$warnings_in_category{$_}}): ($_)}@category_warnings;my$re=join "|",@list;return qr/$re/}sub warning_like_category {my ($warning,$category)=@_;my$re=_warning_category_regexp($category)or carp("Unknown warning category '$category'"),return;my$ok=$warning =~ /$re/;return$ok}1;
TEST_WARN

$fatpacked{"Text/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF';
  package Text::Diff;use 5.00503;use strict;use Carp;use Exporter ();use Algorithm::Diff ();use vars qw{$VERSION @ISA @EXPORT};BEGIN {$VERSION='1.41';@ISA='Exporter';@EXPORT='diff'};use constant A=>0;use constant B=>1;use constant OPCODE=>2;use constant FLAG=>3;my%internal_styles=(Unified=>undef,Context=>undef,OldStyle=>undef,Table=>undef,);sub diff {my@seqs=(shift,shift);my$options=shift || {};for my$i (0 .. 1){my$seq=$seqs[$i];my$type=ref$seq;while ($type eq "CODE"){$seqs[$i]=$seq=$seq->($options);$type=ref$seq}my$AorB=!$i ? "A" : "B";if ($type eq "ARRAY"){$options->{"OFFSET_$AorB"}=0 unless defined$options->{"OFFSET_$AorB"}}elsif ($type eq "SCALAR"){$seqs[$i]=[split(/^/m,$$seq)];$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"}}elsif (!$type){$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"};$options->{"FILENAME_$AorB"}=$seq unless defined$options->{"FILENAME_$AorB"};$options->{"MTIME_$AorB"}=(stat($seq))[9]unless defined$options->{"MTIME_$AorB"};local $/="\n";open F,"<$seq" or carp "$!: $seq";$seqs[$i]=[<F>];close F}elsif ($type eq "GLOB" || UNIVERSAL::isa($seq,"IO::Handle")){$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"};local $/="\n";$seqs[$i]=[<$seq>]}else {confess "Can't handle input of type ",ref}}my$output;my$output_handler=$options->{OUTPUT};my$type=ref$output_handler ;if (!defined$output_handler){$output="";$output_handler=sub {$output .= shift}}elsif ($type eq "CODE"){}elsif ($type eq "SCALAR"){my$out_ref=$output_handler;$output_handler=sub {$$out_ref .= shift}}elsif ($type eq "ARRAY"){my$out_ref=$output_handler;$output_handler=sub {push @$out_ref,shift}}elsif ($type eq "GLOB" || UNIVERSAL::isa$output_handler,"IO::Handle"){my$output_handle=$output_handler;$output_handler=sub {print$output_handle shift}}else {croak "Unrecognized output type: $type"}my$style=$options->{STYLE};$style="Unified" unless defined$options->{STYLE};$style="Text::Diff::$style" if exists$internal_styles{$style};if (!$style->can("hunk")){eval "require $style; 1" or die $@}$style=$style->new if!ref$style && $style->can("new");my$ctx_lines=$options->{CONTEXT};$ctx_lines=3 unless defined$ctx_lines;$ctx_lines=0 if$style->isa("Text::Diff::OldStyle");my@keygen_args=$options->{KEYGEN_ARGS}? @{$options->{KEYGEN_ARGS}}: ();my$diffs=0;my$ctx=0;my@ops;my$hunks=0;my$emit_ops=sub {$output_handler->($style->file_header(@seqs,$options))unless$hunks++;$output_handler->($style->hunk_header(@seqs,@_,$options));$output_handler->($style->hunk (@seqs,@_,$options));$output_handler->($style->hunk_footer(@seqs,@_,$options))};my$dis_a=sub {push@ops,[@_[0,1],"-"];++$diffs ;$ctx=0};my$dis_b=sub {push@ops,[@_[0,1],"+"];++$diffs ;$ctx=0};Algorithm::Diff::traverse_sequences(@seqs,{MATCH=>sub {push@ops,[@_[0,1]," "];if ($diffs && ++$ctx > $ctx_lines * 2){$emit_ops->([splice@ops,0,$#ops - $ctx_lines ]);$ctx=$diffs=0}shift@ops if!$diffs && @ops > $ctx_lines},DISCARD_A=>$dis_a,DISCARD_B=>$dis_b,},$options->{KEYGEN},@keygen_args,);if ($diffs){$#ops -= $ctx - $ctx_lines if$ctx > $ctx_lines;$emit_ops->(\@ops)}$output_handler->($style->file_footer(@seqs,$options))if$hunks;return defined$output ? $output : $hunks}sub _header {my ($h)=@_;my ($p1,$fn1,$t1,$p2,$fn2,$t2)=@{$h}{"FILENAME_PREFIX_A","FILENAME_A","MTIME_A","FILENAME_PREFIX_B","FILENAME_B","MTIME_B" };return "" unless defined$fn1 && defined$fn2;return join("",$p1," ",$fn1,defined$t1 ? "\t" .localtime$t1 : (),"\n",$p2," ",$fn2,defined$t2 ? "\t" .localtime$t2 : (),"\n",)}sub _range {my ($ops,$a_or_b,$format)=@_;my$start=$ops->[0]->[$a_or_b];my$after=$ops->[-1]->[$a_or_b];++$after unless$ops->[-1]->[OPCODE]eq ($a_or_b==A ? "+" : "-");my$empty_range=$start==$after;++$start unless$empty_range;return $start==$after ? $format eq "unified" && $empty_range ? "$start,0" : $start : $format eq "unified" ? "$start,".($after-$start+1): "$start,$after"}sub _op_to_line {my ($seqs,$op,$a_or_b,$op_prefixes)=@_;my$opcode=$op->[OPCODE];return ()unless defined$op_prefixes->{$opcode};my$op_sym=defined$op->[FLAG]? $op->[FLAG]: $opcode;$op_sym=$op_prefixes->{$op_sym};return ()unless defined$op_sym;$a_or_b=$op->[OPCODE]ne "+" ? 0 : 1 unless defined$a_or_b;return ($op_sym,$seqs->[$a_or_b][$op->[$a_or_b]])}SCOPE: {package Text::Diff::Base;sub new {my$proto=shift;return bless {@_ },ref$proto || $proto}sub file_header {return ""}sub hunk_header {return ""}sub hunk {return ""}sub hunk_footer {return ""}sub file_footer {return ""}}@Text::Diff::Unified::ISA=qw(Text::Diff::Base);sub Text::Diff::Unified::file_header {shift;my$options=pop ;_header({FILENAME_PREFIX_A=>"---",FILENAME_PREFIX_B=>"+++",%$options })}sub Text::Diff::Unified::hunk_header {shift;pop;my$ops=pop;return join("","@@ -",_range($ops,A,"unified")," +",_range($ops,B,"unified")," @@\n",)}sub Text::Diff::Unified::hunk {shift;pop;my$ops=pop;my$prefixes={"+"=>"+"," "=>" ","-"=>"-" };return join "",map _op_to_line(\@_,$_,undef,$prefixes),@$ops}@Text::Diff::Context::ISA=qw(Text::Diff::Base);sub Text::Diff::Context::file_header {_header {FILENAME_PREFIX_A=>"***",FILENAME_PREFIX_B=>"---",%{$_[-1]}}}sub Text::Diff::Context::hunk_header {return "***************\n"}sub Text::Diff::Context::hunk {shift;pop;my$ops=pop;my$a_range=_range($ops,A,"");my$b_range=_range($ops,B,"");my$after;for (my$start=0;$start <= $#$ops ;$start=$after ){$after=$start + 1;my$opcode=$ops->[$start]->[OPCODE];next if$opcode eq " ";my$bang_it;while ($after <= $#$ops && $ops->[$after]->[OPCODE]ne " "){$bang_it ||=$ops->[$after]->[OPCODE]ne $opcode;++$after}if ($bang_it){for my$i ($start..($after-1)){$ops->[$i]->[FLAG]="!"}}}my$b_prefixes={"+"=>"+ "," "=>"  ","-"=>undef,"!"=>"! " };my$a_prefixes={"+"=>undef," "=>"  ","-"=>"- ","!"=>"! " };return join("","*** ",$a_range," ****\n",map(_op_to_line(\@_,$_,A,$a_prefixes),@$ops),"--- ",$b_range," ----\n",map(_op_to_line(\@_,$_,B,$b_prefixes),@$ops),)}@Text::Diff::OldStyle::ISA=qw(Text::Diff::Base);sub _op {my$ops=shift;my$op=$ops->[0]->[OPCODE];$op="c" if grep $_->[OPCODE]ne $op,@$ops;$op="a" if$op eq "+";$op="d" if$op eq "-";return$op}sub Text::Diff::OldStyle::hunk_header {shift;pop;my$ops=pop;my$op=_op$ops;return join "",_range($ops,A,""),$op,_range($ops,B,""),"\n"}sub Text::Diff::OldStyle::hunk {shift;pop;my$ops=pop;my$a_prefixes={"+"=>undef," "=>undef,"-"=>"< " };my$b_prefixes={"+"=>"> "," "=>undef,"-"=>undef };my$op=_op$ops;return join("",map(_op_to_line(\@_,$_,A,$a_prefixes),@$ops),$op eq "c" ? "---\n" : (),map(_op_to_line(\@_,$_,B,$b_prefixes),@$ops),)}1;
TEXT_DIFF

$fatpacked{"Text/Diff/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_CONFIG';
  package Text::Diff::Config;use strict;use warnings;use vars '$VERSION';$VERSION='1.41';use vars qw($Output_Unicode);BEGIN {$Output_Unicode=$ENV{'DIFF_OUTPUT_UNICODE'}}1;
TEXT_DIFF_CONFIG

$fatpacked{"Text/Diff/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_TABLE';
  package Text::Diff::Table;use 5.00503;use strict;use Carp;use vars qw{$VERSION @ISA @EXPORT_OK};use Text::Diff::Config;BEGIN {$VERSION='1.41';@ISA=qw(Text::Diff::Base Exporter);@EXPORT_OK=qw(expand_tabs)}my%escapes=map {my$c=$_ eq '"' || $_ eq '$' ? qq{'$_'} : $_ eq "\\" ? qq{"\\\\"} : qq{"$_"};(ord eval$c=>$_)}(map(chr,32..126),map(sprintf("\\x%02x",$_),(0..31,127..255)),"\\t","\\n","\\r","\\f","\\b","\\a","\\e");sub expand_tabs($) {my$s=shift;my$count=0;$s =~ s{(\t)(\t*)|([^\t]+)}{
           if ( $1 ) {
               my $spaces = " " x ( 8 - $count % 8  + 8 * length $2 );
               $count = 0;
               $spaces;
       }
       else {
           $count += length $3;
           $3;
      }
      }ge;return$s}sub trim_trailing_line_ends($) {my$s=shift;$s =~ s/[\r\n]+(?!\n)$//;return$s}sub escape($);SCOPE: {my$escaper=<<'EOCODE';unless (eval$escaper){$escaper =~ s/ *use *utf8 *;\n// or die "Can't drop use utf8;";eval$escaper or die $@}}sub new {my$proto=shift;return bless {@_ },$proto}my$missing_elt=["","" ];sub hunk {my$self=shift;my@seqs=(shift,shift);my$ops=shift;my$options=shift;my (@A,@B);for (@$ops){my$opcode=$_->[Text::Diff::OPCODE()];if ($opcode eq " "){push@A,$missing_elt while@A < @B;push@B,$missing_elt while@B < @A}push@A,[$_->[0]+ ($options->{OFFSET_A}|| 0),$seqs[0][$_->[0]]]if$opcode eq " " || $opcode eq "-";push@B,[$_->[1]+ ($options->{OFFSET_B}|| 0),$seqs[1][$_->[1]]]if$opcode eq " " || $opcode eq "+"}push@A,$missing_elt while@A < @B;push@B,$missing_elt while@B < @A;my@elts;for (0..$#A){my ($A,$B)=(shift@A,shift@B);my$elt_type=$B==$missing_elt ? "A" : $A==$missing_elt ? "B" : $A->[1]eq $B->[1]? "=" : "*";if ($elt_type ne "*"){if ($elt_type eq "=" || $A->[1]=~ /\S/ || $B->[1]=~ /\S/){$A->[1]=escape trim_trailing_line_ends expand_tabs$A->[1];$B->[1]=escape trim_trailing_line_ends expand_tabs$B->[1]}else {$A->[1]=escape$A->[1];$B->[1]=escape$B->[1]}}else {$A->[1]=~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;my ($l_ws_A,$body_A,$t_ws_A)=($1,$2,$3);$body_A="" unless defined$body_A;$B->[1]=~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;my ($l_ws_B,$body_B,$t_ws_B)=($1,$2,$3);$body_B="" unless defined$body_B;my$added_escapes;if ($l_ws_A ne $l_ws_B){$added_escapes=1 if$l_ws_A =~ s/\t/\\t/g;$added_escapes=1 if$l_ws_B =~ s/\t/\\t/g}if ($t_ws_A ne $t_ws_B){$added_escapes=1 if$t_ws_A =~ s/ /\\s/g;$added_escapes=1 if$t_ws_B =~ s/ /\\s/g;$added_escapes=1 if$t_ws_A =~ s/\t/\\t/g;$added_escapes=1 if$t_ws_B =~ s/\t/\\t/g}else {$t_ws_A=$t_ws_B=""}my$do_tab_escape=$added_escapes || do {my$expanded_A=expand_tabs join($body_A,$l_ws_A,$t_ws_A);my$expanded_B=expand_tabs join($body_B,$l_ws_B,$t_ws_B);$expanded_A eq $expanded_B};my$do_back_escape=$do_tab_escape || do {my ($unescaped_A,$escaped_A,$unescaped_B,$escaped_B)=map join("",/(\\.)/g),map {($_,escape $_)}expand_tabs join($body_A,$l_ws_A,$t_ws_A),expand_tabs join($body_B,$l_ws_B,$t_ws_B);$unescaped_A ne $unescaped_B && $escaped_A eq $escaped_B};if ($do_back_escape){$body_A =~ s/\\/\\\\/g;$body_B =~ s/\\/\\\\/g}my$line_A=join$body_A,$l_ws_A,$t_ws_A;my$line_B=join$body_B,$l_ws_B,$t_ws_B;unless ($do_tab_escape){$line_A=expand_tabs$line_A;$line_B=expand_tabs$line_B}$A->[1]=escape$line_A;$B->[1]=escape$line_B}push@elts,[@$A,@$B,$elt_type ]}push @{$self->{ELTS}},@elts,["bar"];return ""}sub _glean_formats {my$self=shift}sub file_footer {my$self=shift;my@seqs=(shift,shift);my$options=pop;my@heading_lines;if (defined$options->{FILENAME_A}|| defined$options->{FILENAME_B}){push@heading_lines,[map({("",escape(defined $_ ? $_ : "<undef>"))}(@{$options}{qw(FILENAME_A FILENAME_B)})),"=",]}if (defined$options->{MTIME_A}|| defined$options->{MTIME_B}){push@heading_lines,[map({("",escape((defined $_ && length $_)? localtime $_ : ""))}@{$options}{qw(MTIME_A MTIME_B)}),"=",]}if (defined$options->{INDEX_LABEL}){push@heading_lines,["","","","","=" ]unless@heading_lines;$heading_lines[-1]->[0]=$heading_lines[-1]->[2]=$options->{INDEX_LABEL}}my$four_column_mode=0;for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";if ($cols->[0]ne $cols->[2]){$four_column_mode=1;last}}unless ($four_column_mode){for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";splice @$cols,2,1}}my@w=(0,0,0,0);for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";for my$i (0..($#$cols-1)){$w[$i]=length$cols->[$i]if defined$cols->[$i]&& length$cols->[$i]> $w[$i]}}my%fmts=$four_column_mode ? ("="=>"| %$w[0]s|%-$w[1]s  | %$w[2]s|%-$w[3]s  |\n","A"=>"* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  |\n","B"=>"| %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n","*"=>"* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n",): ("="=>"| %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n","A"=>"* %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n","B"=>"| %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n","*"=>"* %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n",);$fmts{bar}=sprintf$fmts{"="},"","","","";$fmts{bar}=~ s/\S/+/g;$fmts{bar}=~ s/ /-/g;return join("",map {sprintf($fmts{$_->[-1]},@$_)}(["bar"],@heading_lines,@heading_lines ? ["bar"]: (),@{$self->{ELTS}},),);@{$self->{ELTS}}=[]}1;
        sub escape($) {
        use utf8;
        join "", map {
            my $c = $_;
            $_ = ord;
            exists $escapes{$_}
            ? $escapes{$_}
            : $Text::Diff::Config::Output_Unicode 
            ? $c
            : sprintf( "\\x{%04x}", $_ );
        } split //, shift;
        }
  
        1;
  EOCODE
TEXT_DIFF_TABLE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;BEGIN {$Try::Tiny::AUTHORITY='cpan:NUFFIN'}$Try::Tiny::VERSION='0.22';use 5.006;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {eval "use Sub::Name; 1" or *{subname}=sub {1}}sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;subname("${caller}::try {...} "=>$try);subname("${caller}::catch {...} "=>$catch)if$catch;subname("${caller}::finally {...} "=>$_)foreach@finally;my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;my@guards=map {Try::Tiny::ScopeGuard->_new($_,$failed ? $error : ())}@finally;if ($failed){if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>($] < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"namespace/autoclean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_AUTOCLEAN';
  use strict;use warnings;package namespace::autoclean;$namespace::autoclean::VERSION='0.20';use B::Hooks::EndOfScope 0.12;use List::Util qw(first);use namespace::clean 0.20;sub import {my ($class,%args)=@_;my$subcast=sub {my$i=shift;return$i if ref$i eq 'CODE';return sub {$_ =~ $i}if ref$i eq 'Regexp';return sub {$_ eq $i}};my$runtest=sub {my ($code,$method_name)=@_;local $_=$method_name;return$code->()};my$cleanee=exists$args{-cleanee}? $args{-cleanee}: scalar caller;my@also=map {$subcast->($_)}(exists$args{-also}? (ref$args{-also}eq 'ARRAY' ? @{$args{-also}}: $args{-also}): ());my@except=map {$subcast->($_)}(exists$args{-except}? (ref$args{-except}eq 'ARRAY' ? @{$args{-except}}: $args{-except}): ());on_scope_end {my$subs=namespace::clean->get_functions($cleanee);my$method_check=_method_check($cleanee);my@clean=grep {my$method=$_;!first {$runtest->($_,$method)}@except and (!$method_check->($method)or first {$runtest->($_,$method)}@also)}keys %$subs;namespace::clean->clean_subroutines($cleanee,@clean)}}sub _method_check {my$package=shift;if ((defined&Class::MOP::class_of and my$meta=Class::MOP::class_of($package))){my%methods=map {$_=>1}$meta->get_method_list;$methods{meta}=1 if$meta->isa('Moose::Meta::Role')&& Moose->VERSION < 0.90;return sub {$_[0]=~ /^\(/ || $methods{$_[0]}}}else {my$does=$package->can('does')? 'does' : $package->can('DOES')? 'DOES' : undef;require Sub::Identify;return sub {return 1 if $_[0]=~ /^\(/;my$coderef=do {no strict 'refs';\&{$package .'::' .$_[0]}};my$code_stash=Sub::Identify::stash_name($coderef);return 1 if$code_stash eq $package;return 1 if$does && eval {$package->$does($code_stash)};return 1 if$code_stash eq 'constant';return 0}}}1;
NAMESPACE_AUTOCLEAN

$fatpacked{"namespace/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN';
  package namespace::clean;use warnings;use strict;use Package::Stash;our$VERSION='0.25';our$STORAGE_VAR='__NAMESPACE_CLEAN_STORAGE';use B::Hooks::EndOfScope 'on_scope_end';use constant FIXUP_NEEDED=>$] < 5.015_005_1;use constant FIXUP_RENAME_SUB=>$] > 5.008_008_9 && $] < 5.013_005_1;{no strict;delete ${__PACKAGE__."::"}{FIXUP_NEEDED};delete ${__PACKAGE__."::"}{FIXUP_RENAME_SUB}}my$sub_utils_loaded;my$DebuggerFixup=sub {my ($f,$sub,$cleanee_stash,$deleted_stash)=@_;if (FIXUP_RENAME_SUB){if (!defined$sub_utils_loaded){$sub_utils_loaded=do {my$sn_ver=0.04;eval {require Sub::Name;Sub::Name->VERSION($sn_ver)}or die "Sub::Name $sn_ver required when running under -d or equivalent: $@";my$si_ver=0.04;eval {require Sub::Identify;Sub::Identify->VERSION($si_ver)}or die "Sub::Identify $si_ver required when running under -d or equivalent: $@";1}? 1 : 0}if (Sub::Identify::sub_fullname($sub)eq ($cleanee_stash->name ."::$f")){my$new_fq=$deleted_stash->name ."::$f";Sub::Name::subname($new_fq,$sub);$deleted_stash->add_symbol("&$f",$sub)}}else {$deleted_stash->add_symbol("&$f",$sub)}};my$RemoveSubs=sub {my$cleanee=shift;my$store=shift;my$cleanee_stash=Package::Stash->new($cleanee);my$deleted_stash;SYMBOL: for my$f (@_){next SYMBOL if$store->{exclude}{$f };my$sub=$cleanee_stash->get_symbol("&$f")or next SYMBOL;my$need_debugger_fixup=FIXUP_NEEDED && $^P && ref(my$globref=\$cleanee_stash->namespace->{$f})eq 'GLOB' ;if (FIXUP_NEEDED && $need_debugger_fixup){$DebuggerFixup->($f,$sub,$cleanee_stash,$deleted_stash ||=Package::Stash->new("namespace::clean::deleted::$cleanee"),)}my@symbols=map {my$name=$_ .$f;my$def=$cleanee_stash->get_symbol($name);defined($def)? [$name,$def]: ()}'$','@','%','';$cleanee_stash->remove_glob($f);if (FIXUP_NEEDED &&!FIXUP_RENAME_SUB && $need_debugger_fixup){*$globref=$deleted_stash->namespace->{$f}}$cleanee_stash->add_symbol(@$_)for@symbols}};sub clean_subroutines {my ($nc,$cleanee,@subs)=@_;$RemoveSubs->($cleanee,{},@subs)}sub import {my ($pragma,@args)=@_;my (%args,$is_explicit);ARG: while (@args){if ($args[0]=~ /^\-/){my$key=shift@args;my$value=shift@args;$args{$key }=$value}else {$is_explicit++;last ARG}}my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;if ($is_explicit){on_scope_end {$RemoveSubs->($cleanee,{},@args)}}else {my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);my$stash=Package::Stash->new($cleanee);my%except=map {($_=>1)}($args{-except }? (ref$args{-except }eq 'ARRAY' ? @{$args{-except }}: $args{-except }): ());for my$f (keys %$functions){next if$except{$f };next unless$stash->has_symbol("&$f");$store->{remove}{$f }=1}unless ($store->{handler_is_installed}){on_scope_end {$RemoveSubs->($cleanee,$store,keys %{$store->{remove}})};$store->{handler_is_installed}=1}return 1}}sub unimport {my ($pragma,%args)=@_;my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);for my$f (keys %$functions){next if$store->{remove}{$f }or $store->{exclude}{$f };$store->{exclude}{$f }=1}return 1}sub get_class_store {my ($pragma,$class)=@_;my$stash=Package::Stash->new($class);my$var="%$STORAGE_VAR";$stash->add_symbol($var,{})unless$stash->has_symbol($var);return$stash->get_symbol($var)}sub get_functions {my ($pragma,$class)=@_;my$stash=Package::Stash->new($class);return {map {$_=>$stash->get_symbol("&$_")}$stash->list_all_symbols('CODE')}}no warnings;'Danger! Laws of Thermodynamics may not apply.'
NAMESPACE_CLEAN

$fatpacked{"syntax.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX';
  use strict;use warnings;package syntax;{$syntax::VERSION='0.004'}BEGIN {$syntax::AUTHORITY='cpan:PHAYLON'}use Carp qw(carp);use Data::OptList 0.104 qw(mkopt);use namespace::clean;$Carp::Internal{+__PACKAGE__ }++;$Carp::Internal{'Devel::Declare' }||=1;sub import_into {my ($class,$into,@args)=@_;my$import=mkopt \@args;for my$declaration (@$import){my ($feature,$options)=@$declaration;$class->_install_feature($feature,$into,$options,[@args],)}return 1}sub unimport_from {my ($class,$from,@args)=@_;for my$feature (@args){$class->_uninstall_feature($feature,$from,)}return 1}sub import {my ($class,@args)=@_;my$caller=caller;return$class->import_into($caller,@args)}sub unimport {my ($class,@args)=@_;my$caller=caller;return$class->unimport_from($caller,@args)}sub _parse_feature_name {my ($class,$feature)=@_;my$name=join '/',map ucfirst,split m{/},join '',map ucfirst,split qr{_},$feature;my$file="Syntax/Feature/${name}.pm";my$package=$file;s{ \/ }{::}xg,s{ \.pm \Z }{}xgi for$package;return$package,$file}sub _uninstall_feature {my ($class,$feature,$target)=@_;my ($package,$file)=$class->_parse_feature_name($feature);require$file;unless ($package->can('uninstall')){carp "Syntax extension $package does not know how to uninstall";return}return$package->uninstall(from=>$target,identifier=>$feature,)}sub _install_feature {my ($class,$feature,$target,$options,$all_params)=@_;my ($package,$file)=$class->_parse_feature_name($feature);require$file;return$package->install(into=>$target,options=>$options,identifier=>$feature,outer=>$all_params,)}1;
SYNTAX

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/Load/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_LOAD_XS';
  package Class::Load::XS;BEGIN {$Class::Load::XS::AUTHORITY='cpan:SARTAK'}$Class::Load::XS::VERSION='0.08';use strict;use warnings;use Class::Load 0.20;use XSLoader;XSLoader::load(__PACKAGE__,exists$Class::Load::XS::{VERSION}? ${$Class::Load::XS::{VERSION}}: (),);1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_LOAD_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP';
  package Class::MOP;$Class::MOP::VERSION='2.1213';use strict;use warnings;use 5.008003;use MRO::Compat;use Class::Load 0.07 ();use Scalar::Util 'weaken','isweak','reftype','blessed';use Data::OptList;use Try::Tiny;use Class::MOP::Mixin::AttributeCore;use Class::MOP::Mixin::HasAttributes;use Class::MOP::Mixin::HasMethods;use Class::MOP::Class;use Class::MOP::Attribute;use Class::MOP::Method;BEGIN {*IS_RUNNING_ON_5_10=($] < 5.009_005)? sub () {0}: sub () {1};*check_package_cache_flag=\&mro::get_pkg_gen}XSLoader::load('Moose',$Class::MOP::{VERSION}? ${$Class::MOP::{VERSION}}: ());{my%METAS;sub get_all_metaclasses {%METAS}sub get_all_metaclass_instances {values%METAS}sub get_all_metaclass_names {keys%METAS}sub get_metaclass_by_name {$METAS{$_[0]}}sub store_metaclass_by_name {$METAS{$_[0]}=$_[1]}sub weaken_metaclass {weaken($METAS{$_[0]})}sub metaclass_is_weak {isweak($METAS{$_[0]})}sub does_metaclass_exist {exists$METAS{$_[0]}&& defined$METAS{$_[0]}}sub remove_metaclass_by_name {delete$METAS{$_[0]};return}sub class_of {return unless defined $_[0];my$class=blessed($_[0])|| $_[0];return$METAS{$class}}}sub load_class {Class::MOP::Deprecated::deprecated(message=>'Class::MOP::load_class is deprecated',feature=>'Class::Load wrapper functions',);require Class::Load;goto&Class::Load::load_class}sub load_first_existing_class {Class::MOP::Deprecated::deprecated(message=>'Class::MOP::load_first_existing_class is deprecated',feature=>'Class::Load wrapper functions',);require Class::Load;goto&Class::Load::load_first_existing_class}sub is_class_loaded {Class::MOP::Deprecated::deprecated(message=>'Class::MOP::is_class_loaded is deprecated',feature=>'Class::Load wrapper functions',);require Class::Load;goto&Class::Load::is_class_loaded}sub _definition_context {my%context;@context{qw(package file line)}=caller(1);return (definition_context=>\%context,)}Class::MOP::Mixin::HasMethods->meta->add_attribute(Class::MOP::Attribute->new('_methods'=>(reader=>{'_method_map'=>\&Class::MOP::Mixin::HasMethods::_method_map },default=>sub {{}},_definition_context(),)));Class::MOP::Mixin::HasMethods->meta->add_attribute(Class::MOP::Attribute->new('method_metaclass'=>(reader=>{'method_metaclass'=>\&Class::MOP::Mixin::HasMethods::method_metaclass },default=>'Class::MOP::Method',_definition_context(),)));Class::MOP::Mixin::HasMethods->meta->add_attribute(Class::MOP::Attribute->new('wrapped_method_metaclass'=>(reader=>{'wrapped_method_metaclass'=>\&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass },default=>'Class::MOP::Method::Wrapped',_definition_context(),)));Class::MOP::Mixin::HasAttributes->meta->add_attribute(Class::MOP::Attribute->new('attributes'=>(reader=>{'_attribute_map'=>\&Class::MOP::Mixin::HasAttributes::_attribute_map },default=>sub {{}},_definition_context(),)));Class::MOP::Mixin::HasAttributes->meta->add_attribute(Class::MOP::Attribute->new('attribute_metaclass'=>(reader=>{'attribute_metaclass'=>\&Class::MOP::Mixin::HasAttributes::attribute_metaclass },default=>'Class::MOP::Attribute',_definition_context(),)));Class::MOP::Package->meta->add_attribute(Class::MOP::Attribute->new('package'=>(reader=>{'name'=>\&Class::MOP::Package::name },_definition_context(),)));Class::MOP::Package->meta->add_attribute(Class::MOP::Attribute->new('namespace'=>(reader=>{'namespace'=>\&Class::MOP::Package::namespace },init_arg=>undef,default=>sub {\undef},_definition_context(),)));Class::MOP::Module->meta->add_attribute(Class::MOP::Attribute->new('version'=>(reader=>{'version'=>\&Class::MOP::Module::version },init_arg=>undef,default=>sub {\undef},_definition_context(),)));Class::MOP::Module->meta->add_attribute(Class::MOP::Attribute->new('authority'=>(reader=>{'authority'=>\&Class::MOP::Module::authority },init_arg=>undef,default=>sub {\undef},_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('superclasses'=>(accessor=>{'superclasses'=>\&Class::MOP::Class::superclasses },init_arg=>undef,default=>sub {\undef},_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('instance_metaclass'=>(reader=>{'instance_metaclass'=>\&Class::MOP::Class::instance_metaclass },default=>'Class::MOP::Instance',_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('immutable_trait'=>(reader=>{'immutable_trait'=>\&Class::MOP::Class::immutable_trait },default=>"Class::MOP::Class::Immutable::Trait",_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('constructor_name'=>(reader=>{'constructor_name'=>\&Class::MOP::Class::constructor_name,},default=>"new",_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('constructor_class'=>(reader=>{'constructor_class'=>\&Class::MOP::Class::constructor_class,},default=>"Class::MOP::Method::Constructor",_definition_context(),)));Class::MOP::Class->meta->add_attribute(Class::MOP::Attribute->new('destructor_class'=>(reader=>{'destructor_class'=>\&Class::MOP::Class::destructor_class,},_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('name'=>(reader=>{'name'=>\&Class::MOP::Mixin::AttributeCore::name },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('accessor'=>(reader=>{'accessor'=>\&Class::MOP::Mixin::AttributeCore::accessor },predicate=>{'has_accessor'=>\&Class::MOP::Mixin::AttributeCore::has_accessor },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('reader'=>(reader=>{'reader'=>\&Class::MOP::Mixin::AttributeCore::reader },predicate=>{'has_reader'=>\&Class::MOP::Mixin::AttributeCore::has_reader },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('initializer'=>(reader=>{'initializer'=>\&Class::MOP::Mixin::AttributeCore::initializer },predicate=>{'has_initializer'=>\&Class::MOP::Mixin::AttributeCore::has_initializer },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('definition_context'=>(reader=>{'definition_context'=>\&Class::MOP::Mixin::AttributeCore::definition_context },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('writer'=>(reader=>{'writer'=>\&Class::MOP::Mixin::AttributeCore::writer },predicate=>{'has_writer'=>\&Class::MOP::Mixin::AttributeCore::has_writer },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('predicate'=>(reader=>{'predicate'=>\&Class::MOP::Mixin::AttributeCore::predicate },predicate=>{'has_predicate'=>\&Class::MOP::Mixin::AttributeCore::has_predicate },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('clearer'=>(reader=>{'clearer'=>\&Class::MOP::Mixin::AttributeCore::clearer },predicate=>{'has_clearer'=>\&Class::MOP::Mixin::AttributeCore::has_clearer },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('builder'=>(reader=>{'builder'=>\&Class::MOP::Mixin::AttributeCore::builder },predicate=>{'has_builder'=>\&Class::MOP::Mixin::AttributeCore::has_builder },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('init_arg'=>(reader=>{'init_arg'=>\&Class::MOP::Mixin::AttributeCore::init_arg },predicate=>{'has_init_arg'=>\&Class::MOP::Mixin::AttributeCore::has_init_arg },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('default'=>(predicate=>{'has_default'=>\&Class::MOP::Mixin::AttributeCore::has_default },_definition_context(),)));Class::MOP::Mixin::AttributeCore->meta->add_attribute(Class::MOP::Attribute->new('insertion_order'=>(reader=>{'insertion_order'=>\&Class::MOP::Mixin::AttributeCore::insertion_order },writer=>{'_set_insertion_order'=>\&Class::MOP::Mixin::AttributeCore::_set_insertion_order },predicate=>{'has_insertion_order'=>\&Class::MOP::Mixin::AttributeCore::has_insertion_order },_definition_context(),)));Class::MOP::Attribute->meta->add_attribute(Class::MOP::Attribute->new('associated_class'=>(reader=>{'associated_class'=>\&Class::MOP::Attribute::associated_class },_definition_context(),)));Class::MOP::Attribute->meta->add_attribute(Class::MOP::Attribute->new('associated_methods'=>(reader=>{'associated_methods'=>\&Class::MOP::Attribute::associated_methods },default=>sub {[]},_definition_context(),)));Class::MOP::Attribute->meta->add_method('clone'=>sub {my$self=shift;$self->meta->clone_object($self,@_)});Class::MOP::Method->meta->add_attribute(Class::MOP::Attribute->new('body'=>(reader=>{'body'=>\&Class::MOP::Method::body },_definition_context(),)));Class::MOP::Method->meta->add_attribute(Class::MOP::Attribute->new('associated_metaclass'=>(reader=>{'associated_metaclass'=>\&Class::MOP::Method::associated_metaclass },_definition_context(),)));Class::MOP::Method->meta->add_attribute(Class::MOP::Attribute->new('package_name'=>(reader=>{'package_name'=>\&Class::MOP::Method::package_name },_definition_context(),)));Class::MOP::Method->meta->add_attribute(Class::MOP::Attribute->new('name'=>(reader=>{'name'=>\&Class::MOP::Method::name },_definition_context(),)));Class::MOP::Method->meta->add_attribute(Class::MOP::Attribute->new('original_method'=>(reader=>{'original_method'=>\&Class::MOP::Method::original_method },writer=>{'_set_original_method'=>\&Class::MOP::Method::_set_original_method },_definition_context(),)));Class::MOP::Method::Wrapped->meta->add_attribute(Class::MOP::Attribute->new('modifier_table'=>(_definition_context(),)));Class::MOP::Method::Generated->meta->add_attribute(Class::MOP::Attribute->new('is_inline'=>(reader=>{'is_inline'=>\&Class::MOP::Method::Generated::is_inline },default=>0,_definition_context(),)));Class::MOP::Method::Generated->meta->add_attribute(Class::MOP::Attribute->new('definition_context'=>(reader=>{'definition_context'=>\&Class::MOP::Method::Generated::definition_context },_definition_context(),)));Class::MOP::Method::Inlined->meta->add_attribute(Class::MOP::Attribute->new('_expected_method_class'=>(reader=>{'_expected_method_class'=>\&Class::MOP::Method::Inlined::_expected_method_class },_definition_context(),)));Class::MOP::Method::Accessor->meta->add_attribute(Class::MOP::Attribute->new('attribute'=>(reader=>{'associated_attribute'=>\&Class::MOP::Method::Accessor::associated_attribute },_definition_context(),)));Class::MOP::Method::Accessor->meta->add_attribute(Class::MOP::Attribute->new('accessor_type'=>(reader=>{'accessor_type'=>\&Class::MOP::Method::Accessor::accessor_type },_definition_context(),)));Class::MOP::Method::Constructor->meta->add_attribute(Class::MOP::Attribute->new('options'=>(reader=>{'options'=>\&Class::MOP::Method::Constructor::options },default=>sub {+{}},_definition_context(),)));Class::MOP::Method::Constructor->meta->add_attribute(Class::MOP::Attribute->new('associated_metaclass'=>(init_arg=>"metaclass",reader=>{'associated_metaclass'=>\&Class::MOP::Method::Constructor::associated_metaclass },_definition_context(),)));Class::MOP::Instance->meta->add_attribute(Class::MOP::Attribute->new('associated_metaclass',reader=>{associated_metaclass=>\&Class::MOP::Instance::associated_metaclass },_definition_context(),),);Class::MOP::Instance->meta->add_attribute(Class::MOP::Attribute->new('_class_name',init_arg=>undef,reader=>{_class_name=>\&Class::MOP::Instance::_class_name },_definition_context(),),);Class::MOP::Instance->meta->add_attribute(Class::MOP::Attribute->new('attributes',reader=>{attributes=>\&Class::MOP::Instance::get_all_attributes },_definition_context(),),);Class::MOP::Instance->meta->add_attribute(Class::MOP::Attribute->new('slots',reader=>{slots=>\&Class::MOP::Instance::slots },_definition_context(),),);Class::MOP::Instance->meta->add_attribute(Class::MOP::Attribute->new('slot_hash',reader=>{slot_hash=>\&Class::MOP::Instance::slot_hash },_definition_context(),),);Class::MOP::Object->meta->_add_meta_method('meta');Class::MOP::Mixin->meta->_add_meta_method('meta');require Class::MOP::Deprecated unless our$no_deprecated;Class::MOP::Instance->meta->get_meta_instance;undef Class::MOP::Instance->meta->{_package_cache_flag};$_->meta->make_immutable(inline_constructor=>0,constructor_name=>"_new",inline_accessors=>0,)for qw/Class::MOP::Package Class::MOP::Module Class::MOP::Class Class::MOP::Attribute Class::MOP::Method Class::MOP::Instance Class::MOP::Object Class::MOP::Method::Generated Class::MOP::Method::Inlined Class::MOP::Method::Accessor Class::MOP::Method::Constructor Class::MOP::Method::Wrapped Class::MOP::Method::Meta Class::MOP::Method::Overload/;$_->meta->make_immutable(inline_constructor=>0,constructor_name=>undef,inline_accessors=>0,)for qw/Class::MOP::Mixin Class::MOP::Mixin::AttributeCore Class::MOP::Mixin::HasAttributes Class::MOP::Mixin::HasMethods/;1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_ATTRIBUTE';
  package Class::MOP::Attribute;$Class::MOP::Attribute::VERSION='2.1213';use strict;use warnings;use Class::MOP::Method::Accessor;use Carp 'confess';use Scalar::Util 'blessed','weaken';use Try::Tiny;use parent 'Class::MOP::Object','Class::MOP::Mixin::AttributeCore';sub new {my ($class,@args)=@_;unshift@args,"name" if@args % 2==1;my%options=@args;my$name=$options{name};(defined$name)|| $class->_throw_exception(MOPAttributeNewNeedsAttributeName=>class=>$class,params=>\%options);$options{init_arg}=$name if not exists$options{init_arg};if(exists$options{builder}){$class->_throw_exception(BuilderMustBeAMethodName=>class=>$class,params=>\%options)if ref$options{builder}||!(defined$options{builder});$class->_throw_exception(BothBuilderAndDefaultAreNotAllowed=>class=>$class,params=>\%options)if exists$options{default}}else {($class->is_default_a_coderef(\%options))|| $class->_throw_exception(ReferencesAreNotAllowedAsDefault=>class=>$class,params=>\%options,attribute_name=>$options{name})if exists$options{default}&& ref$options{default}}if($options{required}and not(defined($options{builder})|| defined($options{init_arg})|| exists$options{default})){$class->_throw_exception(RequiredAttributeLacksInitialization=>class=>$class,params=>\%options)}$class->_new(\%options)}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$options=@_==1 ? $_[0]: {@_};bless {'name'=>$options->{name},'accessor'=>$options->{accessor},'reader'=>$options->{reader},'writer'=>$options->{writer},'predicate'=>$options->{predicate},'clearer'=>$options->{clearer},'builder'=>$options->{builder},'init_arg'=>$options->{init_arg},exists$options->{default}? ('default'=>$options->{default}): (),'initializer'=>$options->{initializer},'definition_context'=>$options->{definition_context},'associated_class'=>undef,'associated_methods'=>[],'insertion_order'=>undef,},$class}sub clone {my$self=shift;my%options=@_;(blessed($self))|| confess "Can only clone an instance";return bless {%{$self},%options }=>ref($self)}sub initialize_instance_slot {my ($self,$meta_instance,$instance,$params)=@_;my$init_arg=$self->{'init_arg'};if(defined$init_arg and exists$params->{$init_arg}){$self->_set_initial_slot_value($meta_instance,$instance,$params->{$init_arg},)}elsif (exists$self->{'default'}){$self->_set_initial_slot_value($meta_instance,$instance,$self->default($instance),)}elsif (defined(my$builder=$self->{'builder'})){if ($builder=$instance->can($builder)){$self->_set_initial_slot_value($meta_instance,$instance,$instance->$builder,)}else {$self->_throw_exception(BuilderMethodNotSupportedForAttribute=>attribute=>$self,instance=>$instance)}}}sub _set_initial_slot_value {my ($self,$meta_instance,$instance,$value)=@_;my$slot_name=$self->name;return$meta_instance->set_slot_value($instance,$slot_name,$value)unless$self->has_initializer;my$callback=$self->_make_initializer_writer_callback($meta_instance,$instance,$slot_name);my$initializer=$self->initializer;$instance->$initializer($value,$callback,$self)}sub _make_initializer_writer_callback {my$self=shift;my ($meta_instance,$instance,$slot_name)=@_;return sub {$meta_instance->set_slot_value($instance,$slot_name,$_[0])}}sub get_read_method {my$self=shift;my$reader=$self->reader || $self->accessor;return$reader unless ref$reader;my ($name)=%$reader;return$name}sub get_write_method {my$self=shift;my$writer=$self->writer || $self->accessor;return$writer unless ref$writer;my ($name)=%$writer;return$name}sub get_read_method_ref {my$self=shift;if ((my$reader=$self->get_read_method)&& $self->associated_class){return$self->associated_class->get_method($reader)}else {my$code=sub {$self->get_value(@_)};if (my$class=$self->associated_class){return$class->method_metaclass->wrap($code,package_name=>$class->name,name=>'__ANON__')}else {return$code}}}sub get_write_method_ref {my$self=shift;if ((my$writer=$self->get_write_method)&& $self->associated_class){return$self->associated_class->get_method($writer)}else {my$code=sub {$self->set_value(@_)};if (my$class=$self->associated_class){return$class->method_metaclass->wrap($code,package_name=>$class->name,name=>'__ANON__')}else {return$code}}}sub slots {(shift)->name}sub attach_to_class {my ($self,$class)=@_;(blessed($class)&& $class->isa('Class::MOP::Class'))|| $self->_throw_exception(AttachToClassNeedsAClassMOPClassInstanceOrASubclass=>attribute=>$self,class=>$class);weaken($self->{'associated_class'}=$class)}sub detach_from_class {my$self=shift;$self->{'associated_class'}=undef}sub associate_method {my ($self,$method)=@_;push @{$self->{'associated_methods'}}=>$method}sub set_initial_value {my ($self,$instance,$value)=@_;$self->_set_initial_slot_value(Class::MOP::Class->initialize(ref($instance))->get_meta_instance,$instance,$value)}sub set_value {shift->set_raw_value(@_)}sub set_raw_value {my$self=shift;my ($instance,$value)=@_;my$mi=Class::MOP::Class->initialize(ref($instance))->get_meta_instance;return$mi->set_slot_value($instance,$self->name,$value)}sub _inline_set_value {my$self=shift;return$self->_inline_instance_set(@_).';'}sub _inline_instance_set {my$self=shift;my ($instance,$value)=@_;my$mi=$self->associated_class->get_meta_instance;return$mi->inline_set_slot_value($instance,$self->name,$value)}sub get_value {shift->get_raw_value(@_)}sub get_raw_value {my$self=shift;my ($instance)=@_;my$mi=Class::MOP::Class->initialize(ref($instance))->get_meta_instance;return$mi->get_slot_value($instance,$self->name)}sub _inline_get_value {my$self=shift;return$self->_inline_instance_get(@_).';'}sub _inline_instance_get {my$self=shift;my ($instance)=@_;my$mi=$self->associated_class->get_meta_instance;return$mi->inline_get_slot_value($instance,$self->name)}sub has_value {my$self=shift;my ($instance)=@_;my$mi=Class::MOP::Class->initialize(ref($instance))->get_meta_instance;return$mi->is_slot_initialized($instance,$self->name)}sub _inline_has_value {my$self=shift;return$self->_inline_instance_has(@_).';'}sub _inline_instance_has {my$self=shift;my ($instance)=@_;my$mi=$self->associated_class->get_meta_instance;return$mi->inline_is_slot_initialized($instance,$self->name)}sub clear_value {my$self=shift;my ($instance)=@_;my$mi=Class::MOP::Class->initialize(ref($instance))->get_meta_instance;return$mi->deinitialize_slot($instance,$self->name)}sub _inline_clear_value {my$self=shift;return$self->_inline_instance_clear(@_).';'}sub _inline_instance_clear {my$self=shift;my ($instance)=@_;my$mi=$self->associated_class->get_meta_instance;return$mi->inline_deinitialize_slot($instance,$self->name)}sub accessor_metaclass {'Class::MOP::Method::Accessor'}sub _process_accessors {my ($self,$type,$accessor,$generate_as_inline_methods)=@_;my$method_ctx={%{$self->definition_context || {}}};if (ref($accessor)){(ref($accessor)eq 'HASH')|| $self->_throw_exception(BadOptionFormat=>attribute=>$self,option_value=>$accessor,option_name=>$type);my ($name,$method)=%{$accessor};$method_ctx->{description}=$self->_accessor_description($name,$type);$method=$self->accessor_metaclass->wrap($method,attribute=>$self,package_name=>$self->associated_class->name,name=>$name,associated_metaclass=>$self->associated_class,definition_context=>$method_ctx,);$self->associate_method($method);return ($name,$method)}else {my$inline_me=($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);my$method;try {$method_ctx->{description}=$self->_accessor_description($accessor,$type);$method=$self->accessor_metaclass->new(attribute=>$self,is_inline=>$inline_me,accessor_type=>$type,package_name=>$self->associated_class->name,name=>$accessor,associated_metaclass=>$self->associated_class,definition_context=>$method_ctx,)}catch {$self->_throw_exception(CouldNotCreateMethod=>attribute=>$self,option_value=>$accessor,option_name=>$type,error=>$_)};$self->associate_method($method);return ($accessor,$method)}}sub _accessor_description {my$self=shift;my ($name,$type)=@_;my$desc="$type " .$self->associated_class->name ."::$name";if ($name ne $self->name){$desc .= " of attribute " .$self->name}return$desc}sub install_accessors {my$self=shift;my$inline=shift;my$class=$self->associated_class;$class->add_method($self->_process_accessors('accessor'=>$self->accessor(),$inline))if$self->has_accessor();$class->add_method($self->_process_accessors('reader'=>$self->reader(),$inline))if$self->has_reader();$class->add_method($self->_process_accessors('writer'=>$self->writer(),$inline))if$self->has_writer();$class->add_method($self->_process_accessors('predicate'=>$self->predicate(),$inline))if$self->has_predicate();$class->add_method($self->_process_accessors('clearer'=>$self->clearer(),$inline))if$self->has_clearer();return}{my$_remove_accessor=sub {my ($accessor,$class)=@_;if (ref($accessor)&& ref($accessor)eq 'HASH'){($accessor)=keys %{$accessor}}my$method=$class->get_method($accessor);$class->remove_method($accessor)if (ref($method)&& $method->isa('Class::MOP::Method::Accessor'))};sub remove_accessors {my$self=shift;$_remove_accessor->($self->accessor(),$self->associated_class())if$self->has_accessor();$_remove_accessor->($self->reader(),$self->associated_class())if$self->has_reader();$_remove_accessor->($self->writer(),$self->associated_class())if$self->has_writer();$_remove_accessor->($self->predicate(),$self->associated_class())if$self->has_predicate();$_remove_accessor->($self->clearer(),$self->associated_class())if$self->has_clearer();return}}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS';
  package Class::MOP::Class;$Class::MOP::Class::VERSION='2.1213';use strict;use warnings;use Class::MOP::Instance;use Class::MOP::Method::Wrapped;use Class::MOP::Method::Accessor;use Class::MOP::Method::Constructor;use Class::MOP::MiniTrait;use Carp 'confess';use Module::Runtime 'use_package_optimistically';use Scalar::Util 'blessed','reftype','weaken';use Sub::Name 'subname';use Try::Tiny;use List::MoreUtils 'all';use parent 'Class::MOP::Module','Class::MOP::Mixin::HasAttributes','Class::MOP::Mixin::HasMethods';sub initialize {my$class=shift;my$package_name;if (@_ % 2){$package_name=shift}else {my%options=@_;$package_name=$options{package}}($package_name &&!ref($package_name))|| ($class||__PACKAGE__)->_throw_exception(InitializeTakesUnBlessedPackageName=>package_name=>$package_name);return Class::MOP::get_metaclass_by_name($package_name)|| $class->_construct_class_instance(package=>$package_name,@_)}sub reinitialize {my ($class,@args)=@_;unshift@args,"package" if@args % 2;my%options=@args;my$old_metaclass=blessed($options{package})? $options{package}: Class::MOP::get_metaclass_by_name($options{package});$options{weaken}=Class::MOP::metaclass_is_weak($old_metaclass->name)if!exists$options{weaken}&& blessed($old_metaclass)&& $old_metaclass->isa('Class::MOP::Class');$old_metaclass->_remove_generated_metaobjects if$old_metaclass && $old_metaclass->isa('Class::MOP::Class');my$new_metaclass=$class->SUPER::reinitialize(%options);$new_metaclass->_restore_metaobjects_from($old_metaclass)if$old_metaclass && $old_metaclass->isa('Class::MOP::Class');return$new_metaclass}sub _construct_class_instance {my$class=shift;my$options=@_==1 ? $_[0]: {@_};my$package_name=$options->{package};(defined$package_name && $package_name)|| $class->_throw_exception("ConstructClassInstanceTakesPackageName");if (defined(my$meta=Class::MOP::get_metaclass_by_name($package_name))){return$meta}$class =ref$class ? $class->_real_ref_name : $class;my$meta;if ($class eq 'Class::MOP::Class'){$meta=$class->_new($options)}else {$meta=$class->meta->_construct_instance($options)}$meta->_check_metaclass_compatibility();Class::MOP::store_metaclass_by_name($package_name,$meta);Class::MOP::weaken_metaclass($package_name)if$options->{weaken};$meta}sub _real_ref_name {my$self=shift;return$self->is_immutable ? $self->_get_mutable_metaclass_name(): ref$self}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$options=@_==1 ? $_[0]: {@_};return bless {'package'=>$options->{package},'namespace'=>\undef,'methods'=>{},'version'=>\undef,'authority'=>\undef,'superclasses'=>\undef,'attributes'=>{},'attribute_metaclass'=>($options->{'attribute_metaclass'}|| 'Class::MOP::Attribute'),'method_metaclass'=>($options->{'method_metaclass'}|| 'Class::MOP::Method'),'wrapped_method_metaclass'=>($options->{'wrapped_method_metaclass'}|| 'Class::MOP::Method::Wrapped'),'instance_metaclass'=>($options->{'instance_metaclass'}|| 'Class::MOP::Instance'),'immutable_trait'=>($options->{'immutable_trait'}|| 'Class::MOP::Class::Immutable::Trait'),'constructor_name'=>($options->{constructor_name}|| 'new'),'constructor_class'=>($options->{constructor_class}|| 'Class::MOP::Method::Constructor'),'destructor_class'=>$options->{destructor_class},},$class}{my%base_metaclass=(attribute_metaclass=>'Class::MOP::Attribute',method_metaclass=>'Class::MOP::Method',wrapped_method_metaclass=>'Class::MOP::Method::Wrapped',instance_metaclass=>'Class::MOP::Instance',constructor_class=>'Class::MOP::Method::Constructor',destructor_class=>'Class::MOP::Method::Destructor',);sub _base_metaclasses {%base_metaclass}}sub _check_metaclass_compatibility {my$self=shift;my@superclasses=$self->superclasses or return;$self->_fix_metaclass_incompatibility(@superclasses);my%base_metaclass=$self->_base_metaclasses;return if ref($self)eq 'Class::MOP::Class' && all {my$meta=$self->$_;!defined($meta)|| $meta eq $base_metaclass{$_}}keys%base_metaclass;for my$superclass (@superclasses){$self->_check_class_metaclass_compatibility($superclass)}for my$metaclass_type (keys%base_metaclass){next unless defined$self->$metaclass_type;for my$superclass (@superclasses){$self->_check_single_metaclass_compatibility($metaclass_type,$superclass)}}}sub _check_class_metaclass_compatibility {my$self=shift;my ($superclass_name)=@_;if (!$self->_class_metaclass_is_compatible($superclass_name)){my$super_meta=Class::MOP::get_metaclass_by_name($superclass_name);my$super_meta_type=$super_meta->_real_ref_name;$self->_throw_exception(IncompatibleMetaclassOfSuperclass=>class_name=>$self->name,class_meta_type=>ref($self),superclass_name=>$superclass_name,superclass_meta_type=>$super_meta_type)}}sub _class_metaclass_is_compatible {my$self=shift;my ($superclass_name)=@_;my$super_meta=Class::MOP::get_metaclass_by_name($superclass_name)|| return 1;my$super_meta_name=$super_meta->_real_ref_name;return$self->_is_compatible_with($super_meta_name)}sub _check_single_metaclass_compatibility {my$self=shift;my ($metaclass_type,$superclass_name)=@_;if (!$self->_single_metaclass_is_compatible($metaclass_type,$superclass_name)){my$super_meta=Class::MOP::get_metaclass_by_name($superclass_name);$self->_throw_exception(MetaclassTypeIncompatible=>class_name=>$self->name,superclass_name=>$superclass_name,metaclass_type=>$metaclass_type)}}sub _single_metaclass_is_compatible {my$self=shift;my ($metaclass_type,$superclass_name)=@_;my$super_meta=Class::MOP::get_metaclass_by_name($superclass_name)|| return 1;return 1 unless$super_meta->can($metaclass_type);return 1 unless defined$super_meta->$metaclass_type;return 0 unless defined$self->$metaclass_type;return$self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type)}sub _fix_metaclass_incompatibility {my$self=shift;my@supers=map {Class::MOP::Class->initialize($_)}@_;my$necessary=0;for my$super (@supers){$necessary=1 if$self->_can_fix_metaclass_incompatibility($super)}return unless$necessary;for my$super (@supers){if (!$self->_class_metaclass_is_compatible($super->name)){$self->_fix_class_metaclass_incompatibility($super)}}my%base_metaclass=$self->_base_metaclasses;for my$metaclass_type (keys%base_metaclass){for my$super (@supers){if (!$self->_single_metaclass_is_compatible($metaclass_type,$super->name)){$self->_fix_single_metaclass_incompatibility($metaclass_type,$super)}}}}sub _can_fix_metaclass_incompatibility {my$self=shift;my ($super_meta)=@_;return 1 if$self->_class_metaclass_can_be_made_compatible($super_meta);my%base_metaclass=$self->_base_metaclasses;for my$metaclass_type (keys%base_metaclass){return 1 if$self->_single_metaclass_can_be_made_compatible($super_meta,$metaclass_type)}return}sub _class_metaclass_can_be_made_compatible {my$self=shift;my ($super_meta)=@_;return$self->_can_be_made_compatible_with($super_meta->_real_ref_name)}sub _single_metaclass_can_be_made_compatible {my$self=shift;my ($super_meta,$metaclass_type)=@_;my$specific_meta=$self->$metaclass_type;return unless$super_meta->can($metaclass_type);my$super_specific_meta=$super_meta->$metaclass_type;return unless defined$super_specific_meta;return 1 unless defined$specific_meta;return 1 if$specific_meta->_can_be_made_compatible_with($super_specific_meta)}sub _fix_class_metaclass_incompatibility {my$self=shift;my ($super_meta)=@_;if ($self->_class_metaclass_can_be_made_compatible($super_meta)){($self->is_pristine)|| $self->_throw_exception(CannotFixMetaclassCompatibility=>class_name=>$self->name,superclass=>$super_meta);my$super_meta_name=$super_meta->_real_ref_name;$self->_make_compatible_with($super_meta_name)}}sub _fix_single_metaclass_incompatibility {my$self=shift;my ($metaclass_type,$super_meta)=@_;if ($self->_single_metaclass_can_be_made_compatible($super_meta,$metaclass_type)){($self->is_pristine)|| $self->_throw_exception(CannotFixMetaclassCompatibility=>class_name=>$self->name,superclass=>$super_meta,metaclass_type=>$metaclass_type);my$new_metaclass=$self->$metaclass_type ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type): $super_meta->$metaclass_type;$self->{$metaclass_type}=$new_metaclass}}sub _restore_metaobjects_from {my$self=shift;my ($old_meta)=@_;$self->_restore_metamethods_from($old_meta);$self->_restore_metaattributes_from($old_meta)}sub _remove_generated_metaobjects {my$self=shift;for my$attr (map {$self->get_attribute($_)}$self->get_attribute_list){$attr->remove_accessors}}sub create {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2==1;my%options=@args;(ref$options{superclasses}eq 'ARRAY')|| __PACKAGE__->_throw_exception(CreateMOPClassTakesArrayRefOfSuperclasses=>class=>$class,params=>\%options)if exists$options{superclasses};(ref$options{attributes}eq 'ARRAY')|| __PACKAGE__->_throw_exception(CreateMOPClassTakesArrayRefOfAttributes=>class=>$class,params=>\%options)if exists$options{attributes};(ref$options{methods}eq 'HASH')|| __PACKAGE__->_throw_exception(CreateMOPClassTakesHashRefOfMethods=>class=>$class,params=>\%options)if exists$options{methods};my$package=delete$options{package};my$superclasses=delete$options{superclasses};my$attributes=delete$options{attributes};my$methods=delete$options{methods};my$meta_name=exists$options{meta_name}? delete$options{meta_name}: 'meta';my$meta=$class->SUPER::create($package=>%options);$meta->_add_meta_method($meta_name)if defined$meta_name;$meta->superclasses(@{$superclasses})if defined$superclasses;if (defined$attributes){for my$attr (@{$attributes}){$meta->add_attribute($attr)}}if (defined$methods){for my$method_name (keys %{$methods}){$meta->add_method($method_name,$methods->{$method_name})}}return$meta}sub _anon_package_prefix {'Class::MOP::Class::__ANON__::SERIAL::'}sub create_anon_class {shift->create_anon(@_)}sub is_anon_class {shift->is_anon(@_)}sub _anon_cache_key {my$class=shift;my%options=@_;return join '='=>(join('|',sort @{$options{superclasses}|| []}),)}sub new_object {my$class=shift;return$class->_construct_class_instance(@_)if$class->name->isa('Class::MOP::Class');return$class->_construct_instance(@_)}sub _construct_instance {my$class=shift;my$params=@_==1 ? $_[0]: {@_};my$meta_instance=$class->get_meta_instance();my$instance;if (my$instance_class=blessed($params->{__INSTANCE__})){($instance_class eq $class->name)|| $class->_throw_exception(InstanceBlessedIntoWrongClass=>class_name=>$class->name,params=>$params,instance=>$params->{__INSTANCE__});$instance=$params->{__INSTANCE__}}elsif (exists$params->{__INSTANCE__}){$class->_throw_exception(InstanceMustBeABlessedReference=>class_name=>$class->name,params=>$params,instance=>$params->{__INSTANCE__})}else {$instance=$meta_instance->create_instance()}for my$attr ($class->get_all_attributes()){$attr->initialize_instance_slot($meta_instance,$instance,$params)}if (Class::MOP::metaclass_is_weak($class->name)){$meta_instance->_set_mop_slot($instance,$class)}return$instance}sub _inline_new_object {my$self=shift;return ('my $class = shift;','$class = Scalar::Util::blessed($class) || $class;',$self->_inline_fallback_constructor('$class'),$self->_inline_params('$params','$class'),$self->_inline_generate_instance('$instance','$class'),$self->_inline_slot_initializers,$self->_inline_preserve_weak_metaclasses,$self->_inline_extra_init,'return $instance',)}sub _inline_fallback_constructor {my$self=shift;my ($class)=@_;return ('return ' .$self->_generate_fallback_constructor($class),'if ' .$class .' ne \'' .$self->name .'\';',)}sub _generate_fallback_constructor {my$self=shift;my ($class)=@_;return 'Class::MOP::Class->initialize(' .$class .')->new_object(@_)',}sub _inline_params {my$self=shift;my ($params,$class)=@_;return ('my ' .$params .' = @_ == 1 ? $_[0] : {@_};',)}sub _inline_generate_instance {my$self=shift;my ($inst,$class)=@_;return ('my ' .$inst .' = ' .$self->_inline_create_instance($class).';',)}sub _inline_create_instance {my$self=shift;return$self->get_meta_instance->inline_create_instance(@_)}sub _inline_slot_initializers {my$self=shift;my$idx=0;return map {$self->_inline_slot_initializer($_,$idx++)}sort {$a->name cmp $b->name}$self->get_all_attributes}sub _inline_slot_initializer {my$self=shift;my ($attr,$idx)=@_;if (defined(my$init_arg=$attr->init_arg)){my@source=('if (exists $params->{\'' .$init_arg .'\'}) {',$self->_inline_init_attr_from_constructor($attr,$idx),'}',);if (my@default=$self->_inline_init_attr_from_default($attr,$idx)){push@source,('else {',@default,'}',)}return@source}elsif (my@default=$self->_inline_init_attr_from_default($attr,$idx)){return ('{',@default,'}',)}else {return ()}}sub _inline_init_attr_from_constructor {my$self=shift;my ($attr,$idx)=@_;my@initial_value=$attr->_inline_set_value('$instance','$params->{\'' .$attr->init_arg .'\'}',);push@initial_value,('$attrs->[' .$idx .']->set_initial_value(','$instance,',$attr->_inline_instance_get('$instance'),');',)if$attr->has_initializer;return@initial_value}sub _inline_init_attr_from_default {my$self=shift;my ($attr,$idx)=@_;my$default=$self->_inline_default_value($attr,$idx);return unless$default;my@initial_value=$attr->_inline_set_value('$instance',$default);push@initial_value,('$attrs->[' .$idx .']->set_initial_value(','$instance,',$attr->_inline_instance_get('$instance'),');',)if$attr->has_initializer;return@initial_value}sub _inline_default_value {my$self=shift;my ($attr,$index)=@_;if ($attr->has_default){if ($attr->is_default_a_coderef){return '$defaults->[' .$index .']->($instance)'}else {return '$defaults->[' .$index .']'}}elsif ($attr->has_builder){return '$instance->' .$attr->builder}else {return}}sub _inline_preserve_weak_metaclasses {my$self=shift;if (Class::MOP::metaclass_is_weak($self->name)){return ($self->_inline_set_mop_slot('$instance','Class::MOP::class_of($class)').';')}else {return ()}}sub _inline_extra_init {}sub _eval_environment {my$self=shift;my@attrs=sort {$a->name cmp $b->name}$self->get_all_attributes;my$defaults=[map {$_->default}@attrs];return {'$defaults'=>\$defaults,}}sub get_meta_instance {my$self=shift;$self->{'_meta_instance'}||=$self->_create_meta_instance()}sub _create_meta_instance {my$self=shift;my$instance=$self->instance_metaclass->new(associated_metaclass=>$self,attributes=>[$self->get_all_attributes()],);$self->add_meta_instance_dependencies()if$instance->is_dependent_on_superclasses();return$instance}sub _inline_rebless_instance {my$self=shift;return$self->get_meta_instance->inline_rebless_instance_structure(@_)}sub _inline_get_mop_slot {my$self=shift;return$self->get_meta_instance->_inline_get_mop_slot(@_)}sub _inline_set_mop_slot {my$self=shift;return$self->get_meta_instance->_inline_set_mop_slot(@_)}sub _inline_clear_mop_slot {my$self=shift;return$self->get_meta_instance->_inline_clear_mop_slot(@_)}sub clone_object {my$class=shift;my$instance=shift;(blessed($instance)&& $instance->isa($class->name))|| $class->_throw_exception(CloneObjectExpectsAnInstanceOfMetaclass=>class_name=>$class->name,instance=>$instance,);return$instance if$instance->isa('Class::MOP::Class');$class->_clone_instance($instance,@_)}sub _clone_instance {my ($class,$instance,%params)=@_;(blessed($instance))|| $class->_throw_exception(OnlyInstancesCanBeCloned=>class_name=>$class->name,instance=>$instance,params=>\%params);my$meta_instance=$class->get_meta_instance();my$clone=$meta_instance->clone_instance($instance);for my$attr ($class->get_all_attributes()){if (defined(my$init_arg=$attr->init_arg)){if (exists$params{$init_arg}){$attr->set_value($clone,$params{$init_arg})}}}return$clone}sub _force_rebless_instance {my ($self,$instance,%params)=@_;my$old_metaclass=Class::MOP::class_of($instance);$old_metaclass->rebless_instance_away($instance,$self,%params)if$old_metaclass;my$meta_instance=$self->get_meta_instance;if (Class::MOP::metaclass_is_weak($old_metaclass->name)){$meta_instance->_clear_mop_slot($instance)}$meta_instance->rebless_instance_structure($_[1],$self);$self->_fixup_attributes_after_rebless($instance,$old_metaclass,%params);if (Class::MOP::metaclass_is_weak($self->name)){$meta_instance->_set_mop_slot($instance,$self)}}sub rebless_instance {my ($self,$instance,%params)=@_;my$old_metaclass=Class::MOP::class_of($instance);my$old_class=$old_metaclass ? $old_metaclass->name : blessed($instance);$self->name->isa($old_class)|| $self->_throw_exception(CanReblessOnlyIntoASubclass=>class_name=>$self->name,instance=>$instance,instance_class=>blessed($instance),params=>\%params,);$self->_force_rebless_instance($_[1],%params);return$instance}sub rebless_instance_back {my ($self,$instance)=@_;my$old_metaclass=Class::MOP::class_of($instance);my$old_class =$old_metaclass ? $old_metaclass->name : blessed($instance);$old_class->isa($self->name)|| $self->_throw_exception(CanReblessOnlyIntoASuperclass=>class_name=>$self->name,instance=>$instance,instance_class=>blessed($instance),);$self->_force_rebless_instance($_[1]);return$instance}sub rebless_instance_away {}sub _fixup_attributes_after_rebless {my$self=shift;my ($instance,$rebless_from,%params)=@_;my$meta_instance=$self->get_meta_instance;for my$attr ($rebless_from->get_all_attributes){next if$self->find_attribute_by_name($attr->name);$meta_instance->deinitialize_slot($instance,$_)for$attr->slots}for my$attr ($self->get_all_attributes){if ($attr->has_value($instance)){if (defined(my$init_arg=$attr->init_arg)){$params{$init_arg}=$attr->get_value($instance)unless exists$params{$init_arg}}else {$attr->set_value($instance,$attr->get_value($instance))}}}for my$attr ($self->get_all_attributes){$attr->initialize_instance_slot($meta_instance,$instance,\%params)}}sub _attach_attribute {my ($self,$attribute)=@_;$attribute->attach_to_class($self)}sub _post_add_attribute {my ($self,$attribute)=@_;$self->invalidate_meta_instances;try {local$SIG{__DIE__};$attribute->install_accessors}catch {$self->remove_attribute($attribute->name);die $_}}sub remove_attribute {my$self=shift;my$removed_attribute=$self->SUPER::remove_attribute(@_)or return;$self->invalidate_meta_instances;$removed_attribute->remove_accessors;$removed_attribute->detach_from_class;return$removed_attribute}sub find_attribute_by_name {my ($self,$attr_name)=@_;for my$class ($self->linearized_isa){my$meta=Class::MOP::Class->initialize($class);return$meta->get_attribute($attr_name)if$meta->has_attribute($attr_name)}return}sub get_all_attributes {my$self=shift;my%attrs=map {%{Class::MOP::Class->initialize($_)->_attribute_map}}reverse$self->linearized_isa;return values%attrs}sub superclasses {my$self=shift;my$isa=$self->get_or_add_package_symbol('@ISA');if (@_){my@supers=@_;@{$isa}=@supers;my$class=$self->name;$class->isa($class);$self->_check_metaclass_compatibility();$self->_superclasses_updated()}return @{$isa}}sub _superclasses_updated {my$self=shift;$self->update_meta_instance_dependencies();$self->_superclass_metas(map {Class::MOP::class_of($_)}$self->superclasses)}sub _superclass_metas {my$self=shift;$self->{_superclass_metas}=[@_]}sub subclasses {my$self=shift;my$super_class=$self->name;return @{$super_class->mro::get_isarev()}}sub direct_subclasses {my$self=shift;my$super_class=$self->name;return grep {grep {$_ eq $super_class}Class::MOP::Class->initialize($_)->superclasses}$self->subclasses}sub linearized_isa {return @{mro::get_linear_isa((shift)->name)}}sub class_precedence_list {my$self=shift;my$name=$self->name;unless (Class::MOP::IS_RUNNING_ON_5_10()){($name || return)->isa('This is a test for circular inheritance')}if (mro::get_mro($name)eq 'c3'){return @{mro::get_linear_isa($name)}}else {return ($name,map {Class::MOP::Class->initialize($_)->class_precedence_list()}$self->superclasses())}}sub _method_lookup_order {return (shift->linearized_isa,'UNIVERSAL')}{my$fetch_and_prepare_method=sub {my ($self,$method_name)=@_;my$wrapped_metaclass=$self->wrapped_method_metaclass;my$method=$self->get_method($method_name);unless ($method){$method=$self->find_next_method_by_name($method_name);(defined$method)|| $self->_throw_exception(MethodNameNotFoundInInheritanceHierarchy=>class_name=>$self->name,method_name=>$method_name);$method=$wrapped_metaclass->wrap($method,package_name=>$self->name,name=>$method_name,)}else {$method=$wrapped_metaclass->wrap($method,package_name=>$self->name,name=>$method_name,)unless$method->isa($wrapped_metaclass)}$self->add_method($method_name=>$method);return$method};sub add_before_method_modifier {my ($self,$method_name,$method_modifier)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodModifierNeedsMethodName=>class_name=>$self->name);my$method=$fetch_and_prepare_method->($self,$method_name);$method->add_before_modifier(subname(':before'=>$method_modifier))}sub add_after_method_modifier {my ($self,$method_name,$method_modifier)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodModifierNeedsMethodName=>class_name=>$self->name);my$method=$fetch_and_prepare_method->($self,$method_name);$method->add_after_modifier(subname(':after'=>$method_modifier))}sub add_around_method_modifier {my ($self,$method_name,$method_modifier)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodModifierNeedsMethodName=>class_name=>$self->name);my$method=$fetch_and_prepare_method->($self,$method_name);$method->add_around_modifier(subname(':around'=>$method_modifier))}}sub find_method_by_name {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodNameNotGiven=>class_name=>$self->name);for my$class ($self->_method_lookup_order){my$method=Class::MOP::Class->initialize($class)->get_method($method_name);return$method if defined$method}return}sub get_all_methods {my$self=shift;my%methods;for my$class (reverse$self->_method_lookup_order){my$meta=Class::MOP::Class->initialize($class);$methods{$_->name }=$_ for$meta->_get_local_methods}return values%methods}sub get_all_method_names {my$self=shift;map {$_->name}$self->get_all_methods}sub find_all_methods_by_name {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodNameNotGiven=>class_name=>$self->name);my@methods;for my$class ($self->_method_lookup_order){my$meta=Class::MOP::Class->initialize($class);push@methods=>{name=>$method_name,class=>$class,code=>$meta->get_method($method_name)}if$meta->has_method($method_name)}return@methods}sub find_next_method_by_name {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MethodNameNotGiven=>class_name=>$self->name);my@cpl=($self->_method_lookup_order);shift@cpl;for my$class (@cpl){my$method=Class::MOP::Class->initialize($class)->get_method($method_name);return$method if defined$method}return}sub update_meta_instance_dependencies {my$self=shift;if ($self->{meta_instance_dependencies}){return$self->add_meta_instance_dependencies}}sub add_meta_instance_dependencies {my$self=shift;$self->remove_meta_instance_dependencies;my@attrs=$self->get_all_attributes();my%seen;my@classes=grep {not $seen{$_->name }++}map {$_->associated_class}@attrs;for my$class (@classes){$class->add_dependent_meta_instance($self)}$self->{meta_instance_dependencies}=\@classes}sub remove_meta_instance_dependencies {my$self=shift;if (my$classes=delete$self->{meta_instance_dependencies}){for my$class (@$classes){$class->remove_dependent_meta_instance($self)}return$classes}return}sub add_dependent_meta_instance {my ($self,$metaclass)=@_;push @{$self->{dependent_meta_instances}},$metaclass}sub remove_dependent_meta_instance {my ($self,$metaclass)=@_;my$name=$metaclass->name;@$_=grep {$_->name ne $name}@$_ for$self->{dependent_meta_instances}}sub invalidate_meta_instances {my$self=shift;$_->invalidate_meta_instance()for$self,@{$self->{dependent_meta_instances}}}sub invalidate_meta_instance {my$self=shift;undef$self->{_meta_instance}}sub is_pristine {my$self=shift;return if$self->get_attribute_list;for my$method (map {$self->get_method($_)}$self->get_method_list){return if$method->isa("Class::MOP::Method::Generated")}return 1}sub is_mutable {1}sub is_immutable {0}sub immutable_options {%{$_[0]{__immutable}{options}|| {}}}sub _immutable_options {my ($self,@args)=@_;return (inline_accessors=>1,inline_constructor=>1,inline_destructor=>0,debug=>0,immutable_trait=>$self->immutable_trait,constructor_name=>$self->constructor_name,constructor_class=>$self->constructor_class,destructor_class=>$self->destructor_class,@args,)}sub make_immutable {my ($self,@args)=@_;return$self unless$self->is_mutable;my ($file,$line)=(caller)[1..2];$self->_initialize_immutable(file=>$file,line=>$line,$self->_immutable_options(@args),);$self->_rebless_as_immutable(@args);return$self}sub make_mutable {my$self=shift;if ($self->is_immutable){my@args=$self->immutable_options;$self->_rebless_as_mutable();$self->_remove_inlined_code(@args);delete$self->{__immutable};return$self}else {return}}sub _rebless_as_immutable {my ($self,@args)=@_;$self->{__immutable}{original_class}=ref$self;bless$self=>$self->_immutable_metaclass(@args)}sub _immutable_metaclass {my ($self,%args)=@_;if (my$class=$args{immutable_metaclass}){return$class}my$trait=$args{immutable_trait}=$self->immutable_trait || $self->_throw_exception(NoImmutableTraitSpecifiedForClass=>class_name=>$self->name,params=>\%args);my$meta=$self->meta;my$meta_attr=$meta->find_attribute_by_name("immutable_trait");my$class_name;if ($meta_attr and $trait eq $meta_attr->default){$class_name='Class::MOP::Class::Immutable::' .ref($self)}else {$class_name=join '::','Class::MOP::Class::Immutable::CustomTrait',$trait,'ForMetaClass',ref($self)}return$class_name if Class::MOP::does_metaclass_exist($class_name);my$meta_name=$meta->_real_ref_name;my$immutable_meta=$meta_name->create($class_name,superclasses=>[ref$self ],);Class::MOP::MiniTrait::apply($immutable_meta,$trait);$immutable_meta->make_immutable(inline_constructor=>0,inline_accessors=>0,);return$class_name}sub _remove_inlined_code {my$self=shift;$self->remove_method($_->name)for$self->_inlined_methods;delete$self->{__immutable}{inlined_methods}}sub _inlined_methods {@{$_[0]{__immutable}{inlined_methods}|| []}}sub _add_inlined_method {my ($self,$method)=@_;push @{$self->{__immutable}{inlined_methods}||=[]},$method}sub _initialize_immutable {my ($self,%args)=@_;$self->{__immutable}{options}=\%args;$self->_install_inlined_code(%args)}sub _install_inlined_code {my ($self,%args)=@_;$self->_inline_accessors(%args)if$args{inline_accessors};$self->_inline_constructor(%args)if$args{inline_constructor};$self->_inline_destructor(%args)if$args{inline_destructor}}sub _rebless_as_mutable {my$self=shift;bless$self,$self->_get_mutable_metaclass_name;return$self}sub _inline_accessors {my$self=shift;for my$attr_name ($self->get_attribute_list){$self->get_attribute($attr_name)->install_accessors(1)}}sub _inline_constructor {my ($self,%args)=@_;my$name=$args{constructor_name};return unless defined$name;if ($self->has_method($name)&&!$args{replace_constructor}){my$class=$self->name;warn "Not inlining a constructor for $class since it defines" ." its own constructor.\n" ."If you are certain you don't need to inline your" ." constructor, specify inline_constructor => 0 in your" ." call to $class->meta->make_immutable\n";return}my$constructor_class=$args{constructor_class};{local $@;use_package_optimistically($constructor_class)}my$constructor=$constructor_class->new(options=>\%args,metaclass=>$self,is_inline=>1,package_name=>$self->name,name=>$name,definition_context=>{description=>"constructor " .$self->name ."::" .$name,file=>$args{file},line=>$args{line},},);if ($args{replace_constructor}or $constructor->can_be_inlined){$self->add_method($name=>$constructor);$self->_add_inlined_method($constructor)}}sub _inline_destructor {my ($self,%args)=@_;(exists$args{destructor_class}&& defined$args{destructor_class})|| $self->_throw_exception(NoDestructorClassSpecified=>class_name=>$self->name,params=>\%args,);if ($self->has_method('DESTROY')&&!$args{replace_destructor}){my$class=$self->name;warn "Not inlining a destructor for $class since it defines" ." its own destructor.\n";return}my$destructor_class=$args{destructor_class};{local $@;use_package_optimistically($destructor_class)}return unless$destructor_class->is_needed($self);my$destructor=$destructor_class->new(options=>\%args,metaclass=>$self,package_name=>$self->name,name=>'DESTROY',definition_context=>{description=>"destructor " .$self->name ."::DESTROY",file=>$args{file},line=>$args{line},},);if ($args{replace_destructor}or $destructor->can_be_inlined){$self->add_method('DESTROY'=>$destructor);$self->_add_inlined_method($destructor)}}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT';
  package Class::MOP::Class::Immutable::Trait;$Class::MOP::Class::Immutable::Trait::VERSION='2.1213';use strict;use warnings;use MRO::Compat;use Scalar::Util 'blessed','weaken';use Module::Runtime 'use_module';sub _get_mutable_metaclass_name {$_[0]{__immutable}{original_class}}sub is_mutable {0}sub is_immutable {1}sub _immutable_metaclass {ref $_[1]}sub _immutable_read_only {my$name=shift;__throw_exception(CallingReadOnlyMethodOnAnImmutableInstance=>method_name=>$name)}sub _immutable_cannot_call {my$name=shift;__throw_exception(CallingMethodOnAnImmutableInstance=>method_name=>$name)}for my$name (qw/superclasses/){no strict 'refs';*{__PACKAGE__."::$name"}=sub {my$orig=shift;my$self=shift;_immutable_read_only($name)if @_;$self->$orig}}for my$name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/){no strict 'refs';*{__PACKAGE__."::$name"}=sub {_immutable_cannot_call($name)}}sub class_precedence_list {my$orig=shift;my$self=shift;@{$self->{__immutable}{class_precedence_list}||=[$self->$orig ]}}sub linearized_isa {my$orig=shift;my$self=shift;@{$self->{__immutable}{linearized_isa}||=[$self->$orig ]}}sub get_all_methods {my$orig=shift;my$self=shift;@{$self->{__immutable}{get_all_methods}||=[$self->$orig ]}}sub get_all_method_names {my$orig=shift;my$self=shift;@{$self->{__immutable}{get_all_method_names}||=[$self->$orig ]}}sub get_all_attributes {my$orig=shift;my$self=shift;@{$self->{__immutable}{get_all_attributes}||=[$self->$orig ]}}sub get_meta_instance {my$orig=shift;my$self=shift;$self->{__immutable}{get_meta_instance}||=$self->$orig}sub _method_map {my$orig=shift;my$self=shift;$self->{__immutable}{_method_map}||=$self->$orig}sub __throw_exception {my ($exception_type,@args_to_exception)=@_;die use_module("Moose::Exception::$exception_type")->new(@args_to_exception)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_DEPRECATED';
  package Class::MOP::Deprecated;$Class::MOP::Deprecated::VERSION='2.1213';use strict;use warnings;use Package::DeprecationManager -deprecations=>{'Class::Load wrapper functions'=>'2.1100',};1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_DEPRECATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_INSTANCE';
  package Class::MOP::Instance;$Class::MOP::Instance::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'isweak','weaken','blessed';use parent 'Class::MOP::Object';my$RESERVED_MOP_SLOT='<<MOP>>';sub BUILDARGS {my ($class,@args)=@_;if (@args==1){unshift@args,"associated_metaclass"}elsif (@args >= 2 && blessed($args[0])&& $args[0]->isa("Class::MOP::Class")){my ($meta,@attrs)=@args;@args=(associated_metaclass=>$meta,attributes=>\@attrs)}my%options=@args;$options{slots}||=[map {$_->slots}@{$options{attributes}|| []}];$options{slot_hash}={map {$_=>undef}@{$options{slots}}};return \%options}sub new {my$class=shift;my$options=$class->BUILDARGS(@_);my$instance=$class->_new(%$options);weaken($instance->{'associated_metaclass'});return$instance}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'associated_metaclass'=>$params->{associated_metaclass},'attributes'=>$params->{attributes},'slots'=>$params->{slots},'slot_hash'=>$params->{slot_hash},}=>$class}sub _class_name {$_[0]->{_class_name}||=$_[0]->associated_metaclass->name}sub create_instance {my$self=shift;bless {},$self->_class_name}sub clone_instance {my ($self,$instance)=@_;my$clone=$self->create_instance;for my$attr ($self->get_all_attributes){next unless$attr->has_value($instance);for my$slot ($attr->slots){my$val=$self->get_slot_value($instance,$slot);$self->set_slot_value($clone,$slot,$val);$self->weaken_slot_value($clone,$slot)if$self->slot_value_is_weak($instance,$slot)}}$self->_set_mop_slot($clone,$self->_get_mop_slot($instance))if$self->_has_mop_slot($instance);return$clone}sub get_all_slots {my$self=shift;return @{$self->{'slots'}}}sub get_all_attributes {my$self=shift;return @{$self->{attributes}}}sub is_valid_slot {my ($self,$slot_name)=@_;exists$self->{'slot_hash'}->{$slot_name}}sub get_slot_value {my ($self,$instance,$slot_name)=@_;$instance->{$slot_name}}sub set_slot_value {my ($self,$instance,$slot_name,$value)=@_;$instance->{$slot_name}=$value}sub initialize_slot {my ($self,$instance,$slot_name)=@_;return}sub deinitialize_slot {my ($self,$instance,$slot_name)=@_;delete$instance->{$slot_name}}sub initialize_all_slots {my ($self,$instance)=@_;for my$slot_name ($self->get_all_slots){$self->initialize_slot($instance,$slot_name)}}sub deinitialize_all_slots {my ($self,$instance)=@_;for my$slot_name ($self->get_all_slots){$self->deinitialize_slot($instance,$slot_name)}}sub is_slot_initialized {my ($self,$instance,$slot_name,$value)=@_;exists$instance->{$slot_name}}sub weaken_slot_value {my ($self,$instance,$slot_name)=@_;weaken$instance->{$slot_name}}sub slot_value_is_weak {my ($self,$instance,$slot_name)=@_;isweak$instance->{$slot_name}}sub strengthen_slot_value {my ($self,$instance,$slot_name)=@_;$self->set_slot_value($instance,$slot_name,$self->get_slot_value($instance,$slot_name))}sub rebless_instance_structure {my ($self,$instance,$metaclass)=@_;bless $_[1],$metaclass->name}sub is_dependent_on_superclasses {return}sub _get_mop_slot {my ($self,$instance)=@_;$self->get_slot_value($instance,$RESERVED_MOP_SLOT)}sub _has_mop_slot {my ($self,$instance)=@_;$self->is_slot_initialized($instance,$RESERVED_MOP_SLOT)}sub _set_mop_slot {my ($self,$instance,$value)=@_;$self->set_slot_value($instance,$RESERVED_MOP_SLOT,$value)}sub _clear_mop_slot {my ($self,$instance)=@_;$self->deinitialize_slot($instance,$RESERVED_MOP_SLOT)}sub is_inlinable {1}sub inline_create_instance {my ($self,$class_variable)=@_;'bless {} => ' .$class_variable}sub inline_slot_access {my ($self,$instance,$slot_name)=@_;sprintf q[%s->{"%s"}],$instance,quotemeta($slot_name)}sub inline_get_is_lvalue {1}sub inline_get_slot_value {my ($self,$instance,$slot_name)=@_;$self->inline_slot_access($instance,$slot_name)}sub inline_set_slot_value {my ($self,$instance,$slot_name,$value)=@_;$self->inline_slot_access($instance,$slot_name)." = $value",}sub inline_initialize_slot {my ($self,$instance,$slot_name)=@_;return ''}sub inline_deinitialize_slot {my ($self,$instance,$slot_name)=@_;"delete " .$self->inline_slot_access($instance,$slot_name)}sub inline_is_slot_initialized {my ($self,$instance,$slot_name)=@_;"exists " .$self->inline_slot_access($instance,$slot_name)}sub inline_weaken_slot_value {my ($self,$instance,$slot_name)=@_;sprintf "Scalar::Util::weaken( %s )",$self->inline_slot_access($instance,$slot_name)}sub inline_strengthen_slot_value {my ($self,$instance,$slot_name)=@_;$self->inline_set_slot_value($instance,$slot_name,$self->inline_slot_access($instance,$slot_name))}sub inline_rebless_instance_structure {my ($self,$instance,$class_variable)=@_;"bless $instance => $class_variable"}sub _inline_get_mop_slot {my ($self,$instance)=@_;$self->inline_get_slot_value($instance,$RESERVED_MOP_SLOT)}sub _inline_set_mop_slot {my ($self,$instance,$value)=@_;$self->inline_set_slot_value($instance,$RESERVED_MOP_SLOT,$value)}sub _inline_clear_mop_slot {my ($self,$instance)=@_;$self->inline_deinitialize_slot($instance,$RESERVED_MOP_SLOT)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD';
  package Class::MOP::Method;$Class::MOP::Method::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'weaken','reftype','blessed';use parent 'Class::MOP::Object';use overload '&{}'=>sub {$_[0]->body},fallback=>1;sub wrap {my ($class,@args)=@_;unshift@args,'body' if@args % 2==1;my%params=@args;my$code=$params{body};if (blessed($code)&& $code->isa(__PACKAGE__)){my$method=$code->clone;delete$params{body};Class::MOP::class_of($class)->rebless_instance($method,%params);return$method}elsif (!ref$code || 'CODE' ne reftype($code)){$class->_throw_exception(WrapTakesACodeRefToBless=>params=>\%params,class=>$class,code=>$code)}($params{package_name}&& $params{name})|| $class->_throw_exception(PackageNameAndNameParamsNotGivenToWrap=>params=>\%params,class=>$class,code=>$code);my$self=$class->_new(\%params);weaken($self->{associated_metaclass})if$self->{associated_metaclass};return$self}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'body'=>$params->{body},'associated_metaclass'=>$params->{associated_metaclass},'package_name'=>$params->{package_name},'name'=>$params->{name},'original_method'=>$params->{original_method},}=>$class}sub associated_metaclass {shift->{'associated_metaclass'}}sub attach_to_class {my ($self,$class)=@_;$self->{associated_metaclass}=$class;weaken($self->{associated_metaclass})}sub detach_from_class {my$self=shift;delete$self->{associated_metaclass}}sub fully_qualified_name {my$self=shift;$self->package_name .'::' .$self->name}sub original_method {(shift)->{'original_method'}}sub _set_original_method {$_[0]->{'original_method'}=$_[1]}sub original_package_name {my$self=shift;$self->original_method ? $self->original_method->original_package_name : $self->package_name}sub original_name {my$self=shift;$self->original_method ? $self->original_method->original_name : $self->name}sub original_fully_qualified_name {my$self=shift;$self->original_method ? $self->original_method->original_fully_qualified_name : $self->fully_qualified_name}sub execute {my$self=shift;$self->body->(@_)}sub clone {my$self=shift;my$clone=bless {%{$self},@_ },blessed($self);weaken($clone->{associated_metaclass})if$clone->{associated_metaclass};$clone->_set_original_method($self);return$clone}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR';
  package Class::MOP::Method::Accessor;$Class::MOP::Method::Accessor::VERSION='2.1213';use strict;use warnings;use Carp 'confess';use Scalar::Util 'blessed','weaken';use Try::Tiny;use parent 'Class::MOP::Method::Generated';sub new {my$class=shift;my%options=@_;(exists$options{attribute})|| $class->_throw_exception(MustSupplyAnAttributeToConstructWith=>params=>\%options,class=>$class,);(exists$options{accessor_type})|| $class->_throw_exception(MustSupplyAnAccessorTypeToConstructWith=>params=>\%options,class=>$class,);(blessed($options{attribute})&& $options{attribute}->isa('Class::MOP::Attribute'))|| $class->_throw_exception(MustSupplyAClassMOPAttributeInstance=>params=>\%options,class=>$class);($options{package_name}&& $options{name})|| $class->_throw_exception(MustSupplyPackageNameAndName=>params=>\%options,class=>$class);my$self=$class->_new(\%options);weaken($self->{'attribute'});$self->_initialize_body;return$self}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {body=>$params->{body},associated_metaclass=>$params->{associated_metaclass},package_name=>$params->{package_name},name=>$params->{name},original_method=>$params->{original_method},is_inline=>$params->{is_inline}|| 0,definition_context=>$params->{definition_context},attribute=>$params->{attribute},accessor_type=>$params->{accessor_type},}=>$class}sub associated_attribute {(shift)->{'attribute'}}sub accessor_type {(shift)->{'accessor_type'}}sub _initialize_body {my$self=shift;my$method_name=join "_"=>('_generate',$self->accessor_type,'method',($self->is_inline ? 'inline' : ()));$self->{'body'}=$self->$method_name()}sub _generate_accessor_method {my$self=shift;my$attr=$self->associated_attribute;return sub {if (@_ >= 2){$attr->set_value($_[0],$_[1])}$attr->get_value($_[0])}}sub _generate_accessor_method_inline {my$self=shift;my$attr=$self->associated_attribute;return try {$self->_compile_code(['sub {','if (@_ > 1) {',$attr->_inline_set_value('$_[0]','$_[1]'),'}',$attr->_inline_get_value('$_[0]'),'}',])}catch {$self->_throw_exception(CouldNotGenerateInlineAttributeMethod=>instance=>$self,error=>$_,option=>"accessor")}}sub _generate_reader_method {my$self=shift;my$attr=$self->associated_attribute;my$class=$attr->associated_class;return sub {$self->_throw_exception(CannotAssignValueToReadOnlyAccessor=>class_name=>$class->name,value=>$_[1],attribute=>$attr)if @_ > 1;$attr->get_value($_[0])}}sub _generate_reader_method_inline {my$self=shift;my$attr=$self->associated_attribute;my$attr_name=$attr->name;return try {$self->_compile_code(['sub {','if (@_ > 1) {',$self->_inline_throw_exception(CannotAssignValueToReadOnlyAccessor=>'class_name                          => ref $_[0],'.'value                               => $_[1],'."attribute_name                      => '".$attr_name."'",).';','}',$attr->_inline_get_value('$_[0]'),'}',])}catch {$self->_throw_exception(CouldNotGenerateInlineAttributeMethod=>instance=>$self,error=>$_,option=>"reader")}}sub _inline_throw_exception {my ($self,$exception_type,$throw_args)=@_;return 'die Module::Runtime::use_module("Moose::Exception::' .$exception_type .'")->new(' .($throw_args || '').')'}sub _generate_writer_method {my$self=shift;my$attr=$self->associated_attribute;return sub {$attr->set_value($_[0],$_[1])}}sub _generate_writer_method_inline {my$self=shift;my$attr=$self->associated_attribute;return try {$self->_compile_code(['sub {',$attr->_inline_set_value('$_[0]','$_[1]'),'}',])}catch {$self->_throw_exception(CouldNotGenerateInlineAttributeMethod=>instance=>$self,error=>$_,option=>"writer")}}sub _generate_predicate_method {my$self=shift;my$attr=$self->associated_attribute;return sub {$attr->has_value($_[0])}}sub _generate_predicate_method_inline {my$self=shift;my$attr=$self->associated_attribute;return try {$self->_compile_code(['sub {',$attr->_inline_has_value('$_[0]'),'}',])}catch {$self->_throw_exception(CouldNotGenerateInlineAttributeMethod=>instance=>$self,error=>$_,option=>"predicate")}}sub _generate_clearer_method {my$self=shift;my$attr=$self->associated_attribute;return sub {$attr->clear_value($_[0])}}sub _generate_clearer_method_inline {my$self=shift;my$attr=$self->associated_attribute;return try {$self->_compile_code(['sub {',$attr->_inline_clear_value('$_[0]'),'}',])}catch {$self->_throw_exception(CouldNotGenerateInlineAttributeMethod=>instance=>$self,error=>$_,option=>"clearer")}}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR';
  package Class::MOP::Method::Constructor;$Class::MOP::Method::Constructor::VERSION='2.1213';use strict;use warnings;use Carp 'confess';use Scalar::Util 'blessed','weaken';use Try::Tiny;use parent 'Class::MOP::Method::Inlined';sub new {my$class=shift;my%options=@_;(blessed$options{metaclass}&& $options{metaclass}->isa('Class::MOP::Class'))|| $class->_throw_exception(MustSupplyAMetaclass=>params=>\%options,class=>$class)if$options{is_inline};($options{package_name}&& $options{name})|| $class->_throw_exception(MustSupplyPackageNameAndName=>params=>\%options,class=>$class);my$self=$class->_new(\%options);weaken($self->{'associated_metaclass'});$self->_initialize_body;return$self}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {body=>$params->{body},package_name=>$params->{package_name},name=>$params->{name},original_method=>$params->{original_method},is_inline=>$params->{is_inline}|| 0,definition_context=>$params->{definition_context},_expected_method_class=>$params->{_expected_method_class},options=>$params->{options}|| {},associated_metaclass=>$params->{metaclass},},$class}sub options {(shift)->{'options'}}sub associated_metaclass {(shift)->{'associated_metaclass'}}sub _initialize_body {my$self=shift;my$method_name='_generate_constructor_method';$method_name .= '_inline' if$self->is_inline;$self->{'body'}=$self->$method_name}sub _eval_environment {my$self=shift;return$self->associated_metaclass->_eval_environment}sub _generate_constructor_method {return sub {Class::MOP::Class->initialize(shift)->new_object(@_)}}sub _generate_constructor_method_inline {my$self=shift;my$meta=$self->associated_metaclass;my@source=('sub {',$meta->_inline_new_object,'}',);warn join("\n",@source)if$self->options->{debug};my$code=try {$self->_compile_code(\@source)}catch {my$source=join("\n",@source);$self->_throw_exception(CouldNotEvalConstructor=>constructor_method=>$self,source=>$source,error=>$_)};return$code}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Generated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED';
  package Class::MOP::Method::Generated;$Class::MOP::Method::Generated::VERSION='2.1213';use strict;use warnings;use Eval::Closure;use parent 'Class::MOP::Method';sub new {$_[0]->_throw_exception(CannotCallAnAbstractBaseMethod=>package_name=>__PACKAGE__)}sub _initialize_body {$_[0]->_throw_exception(NoBodyToInitializeInAnAbstractBaseClass=>package_name=>__PACKAGE__)}sub _generate_description {my ($self,$context)=@_;$context ||=$self->definition_context;my$desc="generated method";my$origin="unknown origin";if (defined$context){if (defined$context->{description}){$desc=$context->{description}}if (defined$context->{file}|| defined$context->{line}){$origin="defined at " .(defined$context->{file}? $context->{file}: "<unknown file>")." line " .(defined$context->{line}? $context->{line}: "<unknown line>")}}return "$desc ($origin)"}sub _compile_code {my ($self,@args)=@_;unshift@args,'source' if@args % 2;my%args=@args;my$context=delete$args{context};my$environment=$self->can('_eval_environment')? $self->_eval_environment : {};return eval_closure(environment=>$environment,description=>$self->_generate_description($context),%args,)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Inlined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_INLINED';
  package Class::MOP::Method::Inlined;$Class::MOP::Method::Inlined::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed','weaken','looks_like_number','refaddr';use parent 'Class::MOP::Method::Generated';sub _uninlined_body {my$self=shift;my$super_method =$self->associated_metaclass->find_next_method_by_name($self->name)or return;if ($super_method->isa(__PACKAGE__)){return$super_method->_uninlined_body}else {return$super_method->body}}sub can_be_inlined {my$self=shift;my$metaclass=$self->associated_metaclass;my$class=$metaclass->name;my$inherited_method =$metaclass->find_next_method_by_name($self->name);if ($inherited_method && $inherited_method->isa('Class::MOP::Method::Wrapped')){warn "Not inlining '" .$self->name ."' for $class since it " ."has method modifiers which would be lost if it were inlined\n";return 0}my$expected_class=$self->_expected_method_class or return 1;my$expected_method=$expected_class->can($self->name);if (!$expected_method){warn "Not inlining '" .$self->name ."' for $class since ${expected_class}::" .$self->name ." is not defined\n";return 0}my$actual_method=$class->can($self->name)or return 1;return 1 if refaddr($expected_method)==refaddr($actual_method);if ($inherited_method->isa(__PACKAGE__)){if ($inherited_method->_uninlined_body && refaddr($inherited_method->_uninlined_body)==refaddr($expected_method)){return 1}}elsif (refaddr($inherited_method->body)==refaddr($expected_method)){return 1}my$warning ="Not inlining '" .$self->name ."' for $class since it is not" ." inheriting the default ${expected_class}::" .$self->name ."\n";if ($self->isa("Class::MOP::Method::Constructor")){$warning .= "If you are certain you don't need to inline your" ." constructor, specify inline_constructor => 0 in your" ." call to $class->meta->make_immutable\n"}warn$warning;return 0}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_INLINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_META';
  package Class::MOP::Method::Meta;$Class::MOP::Method::Meta::VERSION='2.1213';use strict;use warnings;use Carp 'confess';use Scalar::Util 'blessed','weaken';use constant DEBUG_NO_META=>$ENV{DEBUG_NO_META}? 1 : 0;use parent 'Class::MOP::Method';sub _is_caller_mop_internal {my$self=shift;my ($caller)=@_;return$caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/}sub _generate_meta_method {my$method_self=shift;my$metaclass=shift;weaken($metaclass);sub {if (DEBUG_NO_META){confess "'meta' method called by MOP internals" if!$_[0]->isa('Class::MOP::Object')&&!$_[0]->isa('Class::MOP::Mixin')&& $method_self->_is_caller_mop_internal(scalar caller)}$metaclass->initialize(blessed($_[0])|| $_[0])}}sub wrap {my ($class,@args)=@_;unshift@args,'body' if@args % 2==1;my%params=@args;$class->_throw_exception(CannotOverrideBodyOfMetaMethods=>params=>\%params,class=>$class)if$params{body};my$metaclass_class=$params{associated_metaclass}->meta;$params{body}=$class->_generate_meta_method($metaclass_class);return$class->SUPER::wrap(%params)}sub _make_compatible_with {my$self=shift;my ($other)=@_;return$self unless$other->_is_compatible_with($self->_real_ref_name);return$self->SUPER::_make_compatible_with(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_META

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Overload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_OVERLOAD';
  package Class::MOP::Method::Overload;$Class::MOP::Method::Overload::VERSION='2.1213';use strict;use warnings;use Carp 'confess';use parent 'Class::MOP::Method';sub wrap {my$class=shift;my (@args)=@_;unshift@args,'body' if@args % 2==1;my%params=@args;$class->_throw_exception(OperatorIsRequired=>params=>\%params,class=>$class)unless exists$params{operator};return$class->SUPER::wrap(name=>"($params{operator}",%params,)}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'body'=>$params->{body},'associated_metaclass'=>$params->{associated_metaclass},'package_name'=>$params->{package_name},'name'=>$params->{name},'original_method'=>$params->{original_method},'operator'=>$params->{operator},}=>$class}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_OVERLOAD

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Wrapped.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED';
  package Class::MOP::Method::Wrapped;$Class::MOP::Method::Wrapped::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed';use parent 'Class::MOP::Method';my$_build_wrapped_method=sub {my$modifier_table=shift;my ($before,$after,$around)=($modifier_table->{before},$modifier_table->{after},$modifier_table->{around},);if (@$before && @$after){$modifier_table->{cache}=sub {for my$c (@$before){$c->(@_)};my@rval;((defined wantarray)? ((wantarray)? (@rval=$around->{cache}->(@_)): ($rval[0]=$around->{cache}->(@_))): $around->{cache}->(@_));for my$c (@$after){$c->(@_)};return unless defined wantarray;return wantarray ? @rval : $rval[0]}}elsif (@$before &&!@$after){$modifier_table->{cache}=sub {for my$c (@$before){$c->(@_)};return$around->{cache}->(@_)}}elsif (@$after &&!@$before){$modifier_table->{cache}=sub {my@rval;((defined wantarray)? ((wantarray)? (@rval=$around->{cache}->(@_)): ($rval[0]=$around->{cache}->(@_))): $around->{cache}->(@_));for my$c (@$after){$c->(@_)};return unless defined wantarray;return wantarray ? @rval : $rval[0]}}else {$modifier_table->{cache}=$around->{cache}}};sub wrap {my ($class,$code,%params)=@_;(blessed($code)&& $code->isa('Class::MOP::Method'))|| $class->_throw_exception(CanOnlyWrapBlessedCode=>params=>\%params,class=>$class,code=>$code);my$modifier_table={cache=>undef,orig=>$code->body,before=>[],after=>[],around=>{cache=>$code->body,methods=>[],},};$_build_wrapped_method->($modifier_table);return$class->SUPER::wrap(sub {$modifier_table->{cache}->(@_)},package_name=>$params{package_name}|| $code->package_name,name=>$params{name}|| $code->name,original_method=>$code,modifier_table=>$modifier_table,)}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'body'=>$params->{body},'associated_metaclass'=>$params->{associated_metaclass},'package_name'=>$params->{package_name},'name'=>$params->{name},'original_method'=>$params->{original_method},'modifier_table'=>$params->{modifier_table}}=>$class}sub get_original_method {my$code=shift;$code->original_method}sub add_before_modifier {my$code=shift;my$modifier=shift;unshift @{$code->{'modifier_table'}->{before}}=>$modifier;$_build_wrapped_method->($code->{'modifier_table'})}sub before_modifiers {my$code=shift;return @{$code->{'modifier_table'}->{before}}}sub add_after_modifier {my$code=shift;my$modifier=shift;push @{$code->{'modifier_table'}->{after}}=>$modifier;$_build_wrapped_method->($code->{'modifier_table'})}sub after_modifiers {my$code=shift;return @{$code->{'modifier_table'}->{after}}}{my$compile_around_method=sub {{my$f1=pop;return$f1 unless @_;my$f2=pop;push @_,sub {$f2->($f1,@_)};redo}};sub add_around_modifier {my$code=shift;my$modifier=shift;unshift @{$code->{'modifier_table'}->{around}->{methods}}=>$modifier;$code->{'modifier_table'}->{around}->{cache}=$compile_around_method->(@{$code->{'modifier_table'}->{around}->{methods}},$code->{'modifier_table'}->{orig});$_build_wrapped_method->($code->{'modifier_table'})}}sub around_modifiers {my$code=shift;return @{$code->{'modifier_table'}->{around}->{methods}}}sub _make_compatible_with {my$self=shift;my ($other)=@_;return$self unless$other->_is_compatible_with($self->_real_ref_name);return$self->SUPER::_make_compatible_with(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/MiniTrait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MINITRAIT';
  package Class::MOP::MiniTrait;$Class::MOP::MiniTrait::VERSION='2.1213';use strict;use warnings;use Module::Runtime 'use_package_optimistically';sub apply {my ($to_class,$trait)=@_;for (grep {!ref}$to_class,$trait){use_package_optimistically($_);$_=Class::MOP::Class->initialize($_)}for my$meth (grep {$_->package_name ne 'UNIVERSAL'}$trait->get_all_methods){my$meth_name=$meth->name;next if index($meth_name,'__')==0;if ($to_class->find_method_by_name($meth_name)){$to_class->add_around_method_modifier($meth_name,$meth->body)}else {$to_class->add_method($meth_name,$meth->clone)}}}require Class::MOP;1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MINITRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN';
  package Class::MOP::Mixin;$Class::MOP::Mixin::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed';use Module::Runtime 'use_module';sub meta {require Class::MOP::Class;Class::MOP::Class->initialize(blessed($_[0])|| $_[0])}sub _throw_exception {my ($class,$exception_type,@args_to_exception)=@_;die use_module("Moose::Exception::$exception_type")->new(@args_to_exception)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE';
  package Class::MOP::Mixin::AttributeCore;$Class::MOP::Mixin::AttributeCore::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed';use parent 'Class::MOP::Mixin';sub has_accessor {defined $_[0]->{'accessor'}}sub has_reader {defined $_[0]->{'reader'}}sub has_writer {defined $_[0]->{'writer'}}sub has_predicate {defined $_[0]->{'predicate'}}sub has_clearer {defined $_[0]->{'clearer'}}sub has_builder {defined $_[0]->{'builder'}}sub has_init_arg {defined $_[0]->{'init_arg'}}sub has_default {exists $_[0]->{'default'}}sub has_initializer {defined $_[0]->{'initializer'}}sub has_insertion_order {defined $_[0]->{'insertion_order'}}sub _set_insertion_order {$_[0]->{'insertion_order'}=$_[1]}sub has_read_method {$_[0]->has_reader || $_[0]->has_accessor}sub has_write_method {$_[0]->has_writer || $_[0]->has_accessor}sub is_default_a_coderef {my ($value)=ref $_[0]? $_[0]->{'default'}: $_[1]->{'default'};return unless ref($value);return ref($value)eq 'CODE' || (blessed($value)&& $value->isa('Class::MOP::Method'))}sub default {my ($self,$instance)=@_;if (defined$instance && $self->is_default_a_coderef){return$self->{'default'}->($instance)}$self->{'default'}}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/HasAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES';
  package Class::MOP::Mixin::HasAttributes;$Class::MOP::Mixin::HasAttributes::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed';use parent 'Class::MOP::Mixin';sub add_attribute {my$self=shift;my$attribute =blessed($_[0])? $_[0]: $self->attribute_metaclass->new(@_);($attribute->isa('Class::MOP::Mixin::AttributeCore'))|| $self->_throw_exception(AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass=>attribute=>$attribute,class_name=>$self->name,);$self->_attach_attribute($attribute);my$attr_name=$attribute->name;$self->remove_attribute($attr_name)if$self->has_attribute($attr_name);my$order=(scalar keys %{$self->_attribute_map});$attribute->_set_insertion_order($order);$self->_attribute_map->{$attr_name}=$attribute;$self->_post_add_attribute($attribute)if$self->can('_post_add_attribute');return$attribute}sub has_attribute {my ($self,$attribute_name)=@_;(defined$attribute_name)|| $self->_throw_exception(MustDefineAnAttributeName=>class_name=>$self->name);exists$self->_attribute_map->{$attribute_name}}sub get_attribute {my ($self,$attribute_name)=@_;(defined$attribute_name)|| $self->_throw_exception(MustDefineAnAttributeName=>class_name=>$self->name);return$self->_attribute_map->{$attribute_name}}sub remove_attribute {my ($self,$attribute_name)=@_;(defined$attribute_name)|| $self->_throw_exception(MustDefineAnAttributeName=>class_name=>$self->name);my$removed_attribute=$self->_attribute_map->{$attribute_name};return unless defined$removed_attribute;delete$self->_attribute_map->{$attribute_name};return$removed_attribute}sub get_attribute_list {my$self=shift;keys %{$self->_attribute_map}}sub _restore_metaattributes_from {my$self=shift;my ($old_meta)=@_;for my$attr (sort {$a->insertion_order <=> $b->insertion_order}map {$old_meta->get_attribute($_)}$old_meta->get_attribute_list){$attr->_make_compatible_with($self->attribute_metaclass);$self->add_attribute($attr)}}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/HasMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS';
  package Class::MOP::Mixin::HasMethods;$Class::MOP::Mixin::HasMethods::VERSION='2.1213';use strict;use warnings;use Class::MOP::Method::Meta;use Class::MOP::Method::Overload;use Scalar::Util 'blessed','reftype';use Sub::Name 'subname';use overload ();use parent 'Class::MOP::Mixin';sub _meta_method_class {'Class::MOP::Method::Meta'}sub _add_meta_method {my$self=shift;my ($name)=@_;my$existing_method=$self->can('find_method_by_name')? $self->find_method_by_name($name): $self->get_method($name);return if$existing_method && $existing_method->isa($self->_meta_method_class);$self->add_method($name=>$self->_meta_method_class->wrap(name=>$name,package_name=>$self->name,associated_metaclass=>$self,))}sub wrap_method_body {my ($self,%args)=@_;($args{body}&& 'CODE' eq reftype$args{body})|| $self->_throw_exception(CodeBlockMustBeACodeRef=>instance=>$self,params=>\%args);$self->method_metaclass->wrap(package_name=>$self->name,%args,)}sub add_method {my ($self,$method_name,$method)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MustDefineAMethodName=>instance=>$self);my$package_name=$self->name;my$body;if (blessed($method)&& $method->isa('Class::MOP::Method')){$body=$method->body;if ($method->package_name ne $package_name){$method=$method->clone(package_name=>$package_name,name=>$method_name,)}$method->attach_to_class($self)}else {$body=$method}$self->_method_map->{$method_name}=$method;my ($current_package,$current_name)=Class::MOP::get_code_info($body);subname($package_name .'::' .$method_name,$body)unless defined$current_name && $current_name !~ /^__ANON__/;$self->add_package_symbol("&$method_name",$body);$self->update_package_cache_flag}sub _code_is_mine {my ($self,$code)=@_;my ($code_package,$code_name)=Class::MOP::get_code_info($code);return ($code_package && $code_package eq $self->name)|| ($code_package eq 'constant' && $code_name eq '__ANON__')}sub has_method {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MustDefineAMethodName=>instance=>$self);my$method=$self->_get_maybe_raw_method($method_name)or return;return defined($self->_method_map->{$method_name}=$method)}sub get_method {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MustDefineAMethodName=>instance=>$self);my$method=$self->_get_maybe_raw_method($method_name)or return;return$method if blessed($method)&& $method->isa('Class::MOP::Method');return$self->_method_map->{$method_name}=$self->wrap_method_body(body=>$method,name=>$method_name,associated_metaclass=>$self,)}sub _get_maybe_raw_method {my ($self,$method_name)=@_;my$map_entry=$self->_method_map->{$method_name};return$map_entry if defined$map_entry;my$code=$self->get_package_symbol("&$method_name");return unless$code && $self->_code_is_mine($code);return$code}sub remove_method {my ($self,$method_name)=@_;(defined$method_name && length$method_name)|| $self->_throw_exception(MustDefineAMethodName=>instance=>$self);my$removed_method=delete$self->_method_map->{$method_name};$self->remove_package_symbol("&$method_name");$removed_method->detach_from_class if blessed($removed_method)&& $removed_method->isa('Class::MOP::Method');$self->update_package_cache_flag;return$removed_method}sub get_method_list {my$self=shift;return keys %{$self->_full_method_map}}sub _get_local_methods {my$self=shift;return values %{$self->_full_method_map}}sub _restore_metamethods_from {my$self=shift;my ($old_meta)=@_;my$package_name=$self->name;my$debugger_enabled=($^P & 0x10);my$debug_method_info;for my$method ($old_meta->_get_local_methods){my$method_name=$method->name;$debug_method_info='';if ($debugger_enabled){$debug_method_info=$DB::sub{$package_name ."::" .$method_name}}$method->_make_compatible_with($self->method_metaclass);$self->add_method($method_name=>$method);if ($debugger_enabled && $debug_method_info){$DB::sub{$package_name ."::" .$method_name}=$debug_method_info}}}sub reset_package_cache_flag {(shift)->{'_package_cache_flag'}=undef}sub update_package_cache_flag {my$self=shift;$self->{'_package_cache_flag'}=Class::MOP::check_package_cache_flag($self->name)}sub _full_method_map {my$self=shift;my$pkg_gen=Class::MOP::check_package_cache_flag($self->name);if (($self->{_package_cache_flag_full}|| -1)!=$pkg_gen){$self->get_method($_)for$self->list_all_package_symbols('CODE');$self->{_package_cache_flag_full}=$pkg_gen}return$self->_method_map}my$overload_operators;sub overload_operators {$overload_operators ||=[map {split /\s+/}values%overload::ops];return @$overload_operators}sub is_overloaded {my$self=shift;return overload::Overloaded($self->name)}sub _overload_map {my$self=shift;return {}unless$self->is_overloaded;my%map;for my$op ($self->overload_operators){my$body=$self->_get_overloaded_operator_body($op);next unless defined$body;$map{$op}=$body}return \%map}sub get_overload_list {my$self=shift;return keys %{$self->_overload_map}}sub get_all_overloaded_operators {my$self=shift;my$map=$self->_overload_map;return map {$self->_wrap_overload($_,$map->{$_})}keys %$map}sub has_overloaded_operator {my$self=shift;my ($op)=@_;return defined$self->_get_overloaded_operator_body($op)}sub get_overloaded_operator {my$self=shift;my ($op)=@_;my$body=$self->_get_overloaded_operator_body($op);return unless defined$body;return$self->_wrap_overload($op,$body)}sub add_overloaded_operator {my$self=shift;my ($op,$body)=@_;$self->name->overload::OVERLOAD($op=>$body)}sub remove_overloaded_operator {my$self=shift;my ($op)=@_;if ($] < 5.018){$self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++}$self->remove_package_symbol('&(' .$op)}sub _get_overloaded_operator_body {my$self=shift;my ($op)=@_;return overload::Method($self->name,$op)}sub _wrap_overload {my$self=shift;my ($op,$body)=@_;return Class::MOP::Method::Overload->wrap(operator=>$op,package_name=>$self->name,associated_metaclass=>$self,body=>$body,)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MODULE';
  package Class::MOP::Module;$Class::MOP::Module::VERSION='2.1213';use strict;use warnings;use Carp 'confess';use Scalar::Util 'blessed';use parent 'Class::MOP::Package';sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'package'=>$params->{package},namespace=>\undef,version=>\undef,authority=>\undef }=>$class}sub version {my$self=shift;${$self->get_or_add_package_symbol('$VERSION')}}sub authority {my$self=shift;${$self->get_or_add_package_symbol('$AUTHORITY')}}sub identifier {my$self=shift;join '-'=>($self->name,($self->version || ()),($self->authority || ()),)}sub create {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2==1;my%options=@args;my$package=delete$options{package};my$version=delete$options{version};my$authority=delete$options{authority};my$meta=$class->SUPER::create($package=>%options);$meta->_instantiate_module($version,$authority);return$meta}sub _anon_package_prefix {'Class::MOP::Module::__ANON__::SERIAL::'}sub _anon_cache_key {my$class=shift;my%options=@_;$class->_throw_exception(PackagesAndModulesAreNotCachable=>class_name=>$class,params=>\%options,is_module=>1)}sub _instantiate_module {my($self,$version,$authority)=@_;my$package_name=$self->name;$self->add_package_symbol('$VERSION'=>$version)if defined$version;$self->add_package_symbol('$AUTHORITY'=>$authority)if defined$authority;return}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MODULE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OBJECT';
  package Class::MOP::Object;$Class::MOP::Object::VERSION='2.1213';use strict;use warnings;use parent 'Class::MOP::Mixin';use Scalar::Util 'blessed';use Module::Runtime 'use_module';sub throw_error {shift->_throw_exception(Legacy=>message=>join('',@_))}sub _inline_throw_error {my ($self,$message)=@_;return 'die Module::Runtime::use_module("Moose::Exception::Legacy")->new(message => ' .$message.')'}sub _new {Class::MOP::class_of(shift)->new_object(@_)}sub dump {my$self=shift;require Data::Dumper;local$Data::Dumper::Maxdepth=shift || 1;Data::Dumper::Dumper$self}sub _real_ref_name {my$self=shift;return blessed($self)}sub _is_compatible_with {my$self=shift;my ($other_name)=@_;return$self->isa($other_name)}sub _can_be_made_compatible_with {my$self=shift;return!$self->_is_compatible_with(@_)&& defined($self->_get_compatible_metaclass(@_))}sub _make_compatible_with {my$self=shift;my ($other_name)=@_;my$new_metaclass=$self->_get_compatible_metaclass($other_name);unless (defined$new_metaclass){$self->_throw_exception(CannotMakeMetaclassCompatible=>superclass_name=>$other_name,class=>$self,)}$new_metaclass->meta->_force_rebless_instance($self)if blessed($self)ne $new_metaclass;return$self}sub _get_compatible_metaclass {my$self=shift;my ($other_name)=@_;return$self->_get_compatible_metaclass_by_subclassing($other_name)}sub _get_compatible_metaclass_by_subclassing {my$self=shift;my ($other_name)=@_;my$meta_name=blessed($self)? $self->_real_ref_name : $self;if ($meta_name->isa($other_name)){return$meta_name}elsif ($other_name->isa($meta_name)){return$other_name}return}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_PACKAGE';
  package Class::MOP::Package;$Class::MOP::Package::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed','reftype','weaken';use Carp 'confess';use Devel::GlobalDestruction 'in_global_destruction';use Module::Runtime 'module_notional_filename';use Package::Stash;use parent 'Class::MOP::Object';sub initialize {my ($class,@args)=@_;unshift@args,"package" if@args % 2;my%options=@args;my$package_name=delete$options{package};if (my$meta=Class::MOP::get_metaclass_by_name($package_name)){return$meta}else {my$meta=(ref$class || $class)->_new({'package'=>$package_name,%options,});Class::MOP::store_metaclass_by_name($package_name,$meta);Class::MOP::weaken_metaclass($package_name)if$options{weaken};return$meta}}sub reinitialize {my ($class,@args)=@_;unshift@args,"package" if@args % 2;my%options=@args;my$package_name=delete$options{package};(defined$package_name && $package_name && (!blessed$package_name || $package_name->isa('Class::MOP::Package')))|| $class->_throw_exception(MustPassAPackageNameOrAnExistingClassMOPPackageInstance=>params=>\%options,class=>$class);$package_name=$package_name->name if blessed$package_name;Class::MOP::remove_metaclass_by_name($package_name);$class->initialize($package_name,%options)}sub create {my$class=shift;my@args=@_;my$meta=$class->initialize(@args);my$filename=module_notional_filename($meta->name);$INC{$filename}='(set by Moose)' unless exists$INC{$filename};return$meta}{my$ANON_SERIAL=0;my%ANON_PACKAGE_CACHE;sub _anon_package_prefix {'Class::MOP::Package::__ANON__::SERIAL::'}sub is_anon {my$self=shift;no warnings 'uninitialized';my$prefix=$self->_anon_package_prefix;$self->name =~ /^\Q$prefix/}sub create_anon {my ($class,%options)=@_;my$cache_ok=delete$options{cache};$options{weaken}=!$cache_ok unless exists$options{weaken};my$cache_key;if ($cache_ok){$cache_key=$class->_anon_cache_key(%options);undef$cache_ok if!defined($cache_key)}if ($cache_ok){if (defined$ANON_PACKAGE_CACHE{$cache_key}){return$ANON_PACKAGE_CACHE{$cache_key}}}my$package_name=$class->_anon_package_prefix .++$ANON_SERIAL;my$meta=$class->create($package_name,%options);if ($cache_ok){$ANON_PACKAGE_CACHE{$cache_key}=$meta;weaken($ANON_PACKAGE_CACHE{$cache_key})}return$meta}sub _anon_cache_key {my$class=shift;my%options=@_;$class->_throw_exception(PackagesAndModulesAreNotCachable=>class_name=>$class,params=>\%options,is_module=>0)}sub DESTROY {my$self=shift;return if in_global_destruction();$self->_free_anon if$self->is_anon}sub _free_anon {my$self=shift;my$name=$self->name;my$current_meta=Class::MOP::get_metaclass_by_name($name);return if defined($current_meta)&& $current_meta ne $self;my ($first_fragments,$last_fragment)=($name =~ /^(.*)::(.*)$/);no strict 'refs';@{$name .'::ISA'}=();%{$name .'::'}=();delete ${$first_fragments .'::'}{$last_fragment .'::'};Class::MOP::remove_metaclass_by_name($name);delete$INC{module_notional_filename($name)}}}sub _new {my$class=shift;return Class::MOP::Class->initialize($class)->new_object(@_)if$class ne __PACKAGE__;my$params=@_==1 ? $_[0]: {@_};return bless {'package'=>$params->{package},namespace=>\undef,}=>$class}sub _package_stash {$_[0]->{_package_stash}||=Package::Stash->new($_[0]->name)}sub namespace {$_[0]->_package_stash->namespace}sub add_package_symbol {my$self=shift;$self->_package_stash->add_symbol(@_)}sub remove_package_glob {my$self=shift;$self->_package_stash->remove_glob(@_)}sub has_package_symbol {my$self=shift;$self->_package_stash->has_symbol(@_)}sub get_package_symbol {my$self=shift;$self->_package_stash->get_symbol(@_)}sub get_or_add_package_symbol {my$self=shift;$self->_package_stash->get_or_add_symbol(@_)}sub remove_package_symbol {my$self=shift;$self->_package_stash->remove_symbol(@_)}sub list_all_package_symbols {my$self=shift;$self->_package_stash->list_all_symbols(@_)}sub get_all_package_symbols {my$self=shift;$self->_package_stash->get_all_symbols(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_PACKAGE

$fatpacked{"x86_64-linux-gnu-thread-multi/List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_MOREUTILS';
  package List::MoreUtils;use 5.00503;use strict;use Exporter ();use DynaLoader ();use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};BEGIN {$VERSION='0.33';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{any all none notall true false firstidx first_index lastidx last_index insert_after insert_after_string apply indexes after after_incl before before_incl firstval first_value lastval last_value each_array each_arrayref pairwise natatime mesh zip uniq distinct minmax part};%EXPORT_TAGS=(all=>\@EXPORT_OK,);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap List::MoreUtils$VERSION;1}unless$ENV{LIST_MOREUTILS_PP}}eval <<'END_PERL' unless defined&any;die $@ if $@;*first_index=\&firstidx;*last_index=\&lastidx;*first_value=\&firstval;*last_value=\&lastval;*zip=\&mesh;*distinct=\&uniq;1;
  
  # Use pure scalar boolean return values for compatibility with XS
  use constant YES => ! 0;
  use constant NO  => ! 1;
  
  sub any (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES if $f->();
      }
      return NO;
  }
  
  sub all (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO unless $f->();
      }
      return YES;
  }
  
  sub none (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO if $f->();
      }
      return YES;
  }
  
  sub notall (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES unless $f->();
      }
      return NO;
  }
  
  sub true (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ if $f->();
      }
      return $count;
  }
  
  sub false (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ unless $f->();
      }
      return $count;
  }
  
  sub firstidx (&@) {
      my $f = shift;
      foreach my $i ( 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastidx (&@) {
      my $f = shift;
      foreach my $i ( reverse 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub insert_after (&$\@) {
      my ($f, $val, $list) = @_;
      my $c = -1;
      local *_;
      foreach my $i ( 0 .. $#$list ) {
          $_ = $list->[$i];
          $c = $i, last if $f->();
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@) {
      my ($string, $val, $list) = @_;
      my $c = -1;
      foreach my $i ( 0 .. $#$list ) {
          local $^W = 0;
          $c = $i, last if $string eq $list->[$i];
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@) {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@) {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do {
          my $x = $lag;
          $lag = $test->();
          $x
      }, @_;
  }
  
  sub after_incl (&@) {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@) {
      my $test = shift;
      my $more = 1;
      grep $more &&= ! $test->(), @_;
  }
  
  sub before_incl (&@) {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do {
          my $x = $lag;
          $lag = ! $test->();
          $x
      }, @_;
  }
  
  sub indexes (&@) {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub lastval (&@) {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- ) {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub firstval (&@) {
      my $test = shift;
      foreach ( @_ ) {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub pairwise (&\@\@) {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local ( *A, *B ) = @_;
  
      # Localise $a, $b
      my ( $caller_a, $caller_b ) = do {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg.'::a'}, \*{$pkg.'::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B? $#A : $#B;
  
      # This map expression is also the return value
      local( *$caller_a, *$caller_b );
      map {
          # Assign to $a, $b as refs to caller's array elements
          ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
  
          # Perform the transformation
          $op->();
      }  0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      return each_arrayref(@_);
  }
  
  sub each_arrayref {
      my @list  = @_; # The list of references to the arrays
      my $index = 0;  # Which one the caller will get next
      my $max   = 0;  # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach ( @list ) {
          unless ( ref $_ eq 'ARRAY' ) {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if ( @_ ) {
              my $method = shift;
              unless ( $method eq 'index' ) {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0  ||  $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list; 
      }
  }
  
  sub natatime ($@) {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
      }
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      my $max = -1;
      $max < $#$_ && ( $max = $#$_ ) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max; 
  }
  
  sub uniq (@) {
      my %seen = ();
      grep { not $seen{$_}++ } @_;
  }
  
  sub minmax (@) {
      return unless @_;
      my $min = my $max = $_[0];
  
      for ( my $i = 1; $i < @_; $i += 2 ) {
          if ( $_[$i-1] <= $_[$i] ) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      if ( @_ & 1 ) {
          my $i = $#_;
          if ($_[$i-1] <= $_[$i]) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@) {
      my ($code, @list) = @_;
      my @parts;
      push @{ $parts[ $code->($_) ] }, $_  foreach @list;
      return @parts;
  }
  
  sub _XScompiled {
      return 0;
  }
  
  END_PERL
X86_64-LINUX-GNU-THREAD-MULTI_LIST_MOREUTILS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE';
  use strict;use warnings;package Moose;$Moose::VERSION='2.1213';$Moose::AUTHORITY='cpan:STEVAN';use 5.008003;use Scalar::Util 'blessed';use Carp 'carp','confess';use Module::Runtime 'module_notional_filename';use Class::Load 'is_class_loaded','load_class';use Moose::Deprecated;use Moose::Exporter;use Class::MOP;BEGIN {die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION" if$Moose::VERSION && $Class::MOP::VERSION ne $Moose::VERSION}use Moose::Meta::Class;use Moose::Meta::TypeConstraint;use Moose::Meta::TypeCoercion;use Moose::Meta::Attribute;use Moose::Meta::Instance;use Moose::Object;use Moose::Meta::Role;use Moose::Meta::Role::Composite;use Moose::Meta::Role::Application;use Moose::Meta::Role::Application::RoleSummation;use Moose::Meta::Role::Application::ToClass;use Moose::Meta::Role::Application::ToRole;use Moose::Meta::Role::Application::ToInstance;use Moose::Util::TypeConstraints;use Moose::Util 'throw_exception';use Moose::Meta::Attribute::Native;sub extends {my$meta=shift;unless (@_){throw_exception(ExtendsMissingArgs=>class_name=>$meta->name)}$meta->superclasses(@_)}sub with {Moose::Util::apply_all_roles(shift,@_)}sub throw_error {shift;Class::MOP::Object->throw_error(@_)}sub has {my$meta=shift;my$name=shift;my%context=Moose::Util::_caller_info;$context{context}='has declaration';$context{type}='class';my@options=(definition_context=>\%context,@_);my$attrs=(ref($name)eq 'ARRAY')? $name : [($name)];$meta->add_attribute($_,@options)for @$attrs}sub before {Moose::Util::add_method_modifier(shift,'before',\@_)}sub after {Moose::Util::add_method_modifier(shift,'after',\@_)}sub around {Moose::Util::add_method_modifier(shift,'around',\@_)}our$SUPER_PACKAGE;our$SUPER_BODY;our@SUPER_ARGS;sub super {if (@_){carp 'Arguments passed to super() are ignored'}return if defined$SUPER_PACKAGE && $SUPER_PACKAGE ne caller();return unless$SUPER_BODY;$SUPER_BODY->(@SUPER_ARGS)}sub override {my$meta=shift;my ($name,$method)=@_;$meta->add_override_method_modifier($name=>$method)}sub inner {my$pkg=caller();our (%INNER_BODY,%INNER_ARGS);if (my$body=$INNER_BODY{$pkg}){my@args=@{$INNER_ARGS{$pkg}};local$INNER_ARGS{$pkg};local$INNER_BODY{$pkg};return$body->(@args)}else {return}}sub augment {my$meta=shift;my ($name,$method)=@_;$meta->add_augment_method_modifier($name=>$method)}Moose::Exporter->setup_import_methods(with_meta=>[qw(extends with has before after around override augment) ],as_is=>[qw(super inner),\&Carp::confess,\&Scalar::Util::blessed,],);sub init_meta {shift;my%args=@_;my$class=$args{for_class}or throw_exception(InitMetaRequiresClass=>params=>\%args);my$base_class=$args{base_class}|| 'Moose::Object';my$metaclass=$args{metaclass}|| 'Moose::Meta::Class';my$meta_name=exists$args{meta_name}? $args{meta_name}: 'meta';throw_exception(MetaclassNotLoaded=>class_name=>$metaclass)unless is_class_loaded($metaclass);throw_exception(MetaclassMustBeASubclassOfMooseMetaClass=>class_name=>$metaclass)unless$metaclass->isa('Moose::Meta::Class');class_type($class)unless find_type_constraint($class);my$meta;if ($meta=Class::MOP::get_metaclass_by_name($class)){unless ($meta->isa("Moose::Meta::Class")){if ($meta->isa('Moose::Meta::Role')){throw_exception(MetaclassIsARoleNotASubclassOfGivenMetaclass=>role_name=>$class,metaclass=>$metaclass,role=>$meta)}else {throw_exception(MetaclassIsNotASubclassOfGivenMetaclass=>class_name=>$class,metaclass=>$metaclass,class=>$meta)}}}else {my (undef,@isa)=@{mro::get_linear_isa($class)};for my$ancestor (@isa){my$ancestor_meta=Class::MOP::get_metaclass_by_name($ancestor)|| next;my$ancestor_meta_class=$ancestor_meta->_real_ref_name;unless ($metaclass->isa($ancestor_meta_class)){if ($ancestor_meta_class->isa($metaclass)){$metaclass=$ancestor_meta_class}}}$meta=$metaclass->initialize($class);my$filename=module_notional_filename($meta->name);$INC{$filename}='(set by Moose)' unless exists$INC{$filename}}if (defined$meta_name){my$existing=$meta->get_method($meta_name);if ($existing &&!$existing->isa('Class::MOP::Method::Meta')){Carp::cluck "Moose is overwriting an existing method named " ."$meta_name in class $class with a method " ."which returns the class's metaclass. If this is " ."actually what you want, you should remove the " ."existing method, otherwise, you should rename or " ."disable this generated method using the " ."'-meta_name' option to 'use Moose'."}$meta->_add_meta_method($meta_name)}$meta->superclasses($base_class)unless$meta->superclasses();return$meta}sub _get_caller {goto&Moose::Exporter::_get_caller}$_->make_immutable(inline_constructor=>1,constructor_name=>"_new",inline_accessors=>1)for grep {$_->is_mutable}map {$_->meta}qw(Moose::Meta::Attribute Moose::Meta::Class Moose::Meta::Instance Moose::Meta::TypeCoercion Moose::Meta::TypeCoercion::Union Moose::Meta::Method Moose::Meta::Method::Constructor Moose::Meta::Method::Destructor Moose::Meta::Method::Overridden Moose::Meta::Method::Augmented Moose::Meta::Role Moose::Meta::Role::Attribute Moose::Meta::Role::Method Moose::Meta::Role::Method::Required Moose::Meta::Role::Method::Conflicting Moose::Meta::Role::Composite Moose::Meta::Role::Application Moose::Meta::Role::Application::RoleSummation Moose::Meta::Role::Application::ToClass Moose::Meta::Role::Application::ToRole Moose::Meta::Role::Application::ToInstance);$_->make_immutable(inline_constructor=>0,constructor_name=>undef,inline_accessors=>1)for grep {$_->is_mutable}map {$_->meta}qw(Moose::Meta::Method::Accessor Moose::Meta::Method::Delegation Moose::Meta::Mixin::AttributeCore);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_CONFLICTS';
  package Moose::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Moose',-conflicts=>{'Catalyst'=>'5.90049999','Config::MVP'=>'2.200004','Devel::REPL'=>'1.003020','Dist::Zilla::Plugin::Git'=>'2.016','Fey'=>'0.36','Fey::ORM'=>'0.42','File::ChangeNotify'=>'0.15','HTTP::Throwable'=>'0.017','KiokuDB'=>'0.51','Markdent'=>'0.16','Mason'=>'2.18','MooseX::ABC'=>'0.05','MooseX::Aliases'=>'0.08','MooseX::AlwaysCoerce'=>'0.13','MooseX::App'=>'1.22','MooseX::Attribute::Deflator'=>'2.1.7','MooseX::Attribute::Dependent'=>'1.1.0','MooseX::Attribute::Prototype'=>'0.10','MooseX::AttributeHelpers'=>'0.22','MooseX::AttributeIndexes'=>'1.0.0','MooseX::AttributeInflate'=>'0.02','MooseX::CascadeClearing'=>'0.03','MooseX::ClassAttribute'=>'0.26','MooseX::Constructor::AllErrors'=>'0.021','MooseX::Declare'=>'0.35','MooseX::FollowPBP'=>'0.02','MooseX::Getopt'=>'0.56','MooseX::InstanceTracking'=>'0.04','MooseX::LazyRequire'=>'0.06','MooseX::Meta::Attribute::Index'=>'0.04','MooseX::Meta::Attribute::Lvalue'=>'0.05','MooseX::Method::Signatures'=>'0.44','MooseX::MethodAttributes'=>'0.22','MooseX::NonMoose'=>'0.24','MooseX::Object::Pluggable'=>'0.0011','MooseX::POE'=>'0.214','MooseX::Params::Validate'=>'0.05','MooseX::PrivateSetters'=>'0.03','MooseX::Role::Cmd'=>'0.06','MooseX::Role::Parameterized'=>'1.00','MooseX::Role::WithOverloading'=>'0.07','MooseX::Runnable'=>'0.03','MooseX::Scaffold'=>'0.05','MooseX::SemiAffordanceAccessor'=>'0.05','MooseX::SetOnce'=>'0.100473','MooseX::Singleton'=>'0.25','MooseX::SlurpyConstructor'=>'1.1','MooseX::Storage'=>'0.42','MooseX::StrictConstructor'=>'0.12','MooseX::Traits'=>'0.11','MooseX::Types'=>'0.19','MooseX::Types::Parameterizable'=>'0.05','MooseX::Types::Set::Object'=>'0.03','MooseX::Types::Signal'=>'1.101930','MooseX::UndefTolerant'=>'0.11','PRANG'=>'0.14','Pod::Elemental'=>'0.093280','Pod::Weaver'=>'3.101638','Reaction'=>'0.002003','Test::Able'=>'0.10','Test::CleanNamespaces'=>'0.03','Test::Moose::More'=>'0.022','Test::TempDir'=>'0.05','Throwable'=>'0.102080','namespace::autoclean'=>'0.08',},-also=>[qw(Carp Class::Load Class::Load::XS Data::OptList Devel::GlobalDestruction Devel::StackTrace Dist::CheckConflicts Eval::Closure List::MoreUtils MRO::Compat Module::Runtime Module::Runtime::Conflicts Package::DeprecationManager Package::Stash Package::Stash::XS Params::Util Scalar::Util Sub::Exporter Sub::Name Task::Weaken Try::Tiny parent strict warnings) ],;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_CONFLICTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_DEPRECATED';
  package Moose::Deprecated;$Moose::Deprecated::VERSION='2.1213';use strict;use warnings;use Package::DeprecationManager 0.07 -deprecations=>{'non-arrayref form of enum'=>'2.1100','non-arrayref form of duck_type'=>'2.1100',},-ignore=>[qr/^(?:Class::MOP|Moose)(?:::)?/],;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_DEPRECATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION';
  package Moose::Exception;$Moose::Exception::VERSION='2.1213';use Moose;use Devel::StackTrace 1.33;has 'trace'=>(is=>'ro',isa=>'Devel::StackTrace',builder=>'_build_trace',lazy=>1,documentation=>"This attribute is read-only and isa L<Devel::StackTrace>. ".'It is lazy & dependent on $exception->message.');has 'message'=>(is=>'ro',isa=>'Str',builder=>'_build_message',lazy=>1,documentation=>"This attribute is read-only and isa Str. "."It is lazy and has a default value 'Error'.");use overload '""'=>sub {my$self=shift;return$self->trace->as_string,},fallback=>1,;sub _build_trace {my$self=shift;my$skip=0;while (my@c=caller(++$skip)){last if$c[3]=~ /^(.*)::new$/ && $self->isa($1)}$skip++;Devel::StackTrace->new(message=>$self->message,indent=>1,skip_frames=>$skip,)}sub _build_message {"Error"}sub BUILD {my$self=shift;$self->trace}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AccessorMustReadWrite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE';
  package Moose::Exception::AccessorMustReadWrite;$Moose::Exception::AccessorMustReadWrite::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"Cannot define an accessor name on a read-only attribute, accessors are read/write"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddParameterizableTypeTakesParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE';
  package Moose::Exception::AddParameterizableTypeTakesParameterizableType;$Moose::Exception::AddParameterizableTypeTakesParameterizableType::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'type_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Type must be a Moose::Meta::TypeConstraint::Parameterizable not ".$self->type_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddRoleTakesAMooseMetaRoleInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE';
  package Moose::Exception::AddRoleTakesAMooseMetaRoleInstance;$Moose::Exception::AddRoleTakesAMooseMetaRoleInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'role_to_be_added'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {"Roles must be instances of Moose::Meta::Role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddRoleToARoleTakesAMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE';
  package Moose::Exception::AddRoleToARoleTakesAMooseMetaRole;$Moose::Exception::AddRoleToARoleTakesAMooseMetaRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'role_to_be_added'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {"Roles must be instances of Moose::Meta::Role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ApplyTakesABlessedInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE';
  package Moose::Exception::ApplyTakesABlessedInstance;$Moose::Exception::ApplyTakesABlessedInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'param'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {"You must pass in an blessed instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttachToClassNeedsAClassMOPClassInstanceOrASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS';
  package Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass;$Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'class'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"You must pass a Class::MOP::Class instance (or a subclass)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES';
  package Moose::Exception::AttributeConflictInRoles;$Moose::Exception::AttributeConflictInRoles::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'second_role_name'=>(is=>'ro',isa=>'Str',required=>1);has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$role_name=$self->role_name;my$second_role_name=$self->second_role_name;my$attribute_name=$self->attribute_name;"Role '$role_name' has encountered an attribute conflict" ." while being composed into '$second_role_name'." ." This is a fatal error and cannot be disambiguated." ." The conflicting attribute is named '$attribute_name'."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION';
  package Moose::Exception::AttributeConflictInSummation;$Moose::Exception::AttributeConflictInSummation::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role','Moose::Exception::Role::AttributeName';has 'second_role_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;my$role1=$self->role_name;my$role2=$self->second_role_name;my$attr_name=$self->attribute_name;return "We have encountered an attribute conflict with '$attr_name'" ." during role composition. " ." This attribute is defined in both $role1 and $role2." ." This is a fatal error and cannot be disambiguated."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeExtensionIsNotSupportedInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES';
  package Moose::Exception::AttributeExtensionIsNotSupportedInRoles;$Moose::Exception::AttributeExtensionIsNotSupportedInRoles::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {"has '+attr' is not supported in roles"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED';
  package Moose::Exception::AttributeIsRequired;$Moose::Exception::AttributeIsRequired::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching attribute instance:\n"."    my \$class = Moose::Util::find_meta( \$exception->class_name );\n"."    my \$attribute = \$class->get_attribute( \$exception->attribute_name );\n",);has 'params'=>(is=>'ro',isa=>'HashRef',predicate=>'has_params',);sub _build_message {my$self=shift;"Attribute (".$self->attribute_name.") is required"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS';
  package Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass;$Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'attribute'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH';
  package Moose::Exception::AttributeNamesDoNotMatch;$Moose::Exception::AttributeNamesDoNotMatch::VERSION='2.1213';use Moose;extends 'Moose::Exception';has attribute_name=>(is=>'ro',isa=>'Str',required=>1,);has attribute=>(is=>'ro',isa=>'Class::MOP::Attribute',required=>1,);sub _build_message {my$self=shift;"attribute_name (".$self-> attribute_name.") does not match attribute->name (".$self->attribute->name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeValueIsNotAnObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT';
  package Moose::Exception::AttributeValueIsNotAnObject;$Moose::Exception::AttributeValueIsNotAnObject::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance','Moose::Exception::Role::Attribute';has 'method'=>(is=>'ro',isa=>'Moose::Meta::Method::Delegation',required=>1,);has 'given_value'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {my$self=shift;"Cannot delegate ".$self->method->name." to " .$self->method->delegate_to_method." because the value of " .$self->attribute->name ." is not an object (got '".$self->given_value."')"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeValueIsNotDefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED';
  package Moose::Exception::AttributeValueIsNotDefined;$Moose::Exception::AttributeValueIsNotDefined::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance','Moose::Exception::Role::Attribute';has 'method'=>(is=>'ro',isa=>'Moose::Meta::Method::Delegation',required=>1,);sub _build_message {my$self=shift;"Cannot delegate ".$self->method->name." to " .$self->method->delegate_to_method." because the value of " .$self->attribute->name ." is not defined"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AutoDeRefNeedsArrayRefOrHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF';
  package Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef;$Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BadOptionFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT';
  package Moose::Exception::BadOptionFormat;$Moose::Exception::BadOptionFormat::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'option_name'=>(is=>'ro',isa=>'Str',required=>1);has 'option_value'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"bad accessor/reader/writer/predicate/clearer format, must be a HASH ref"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BothBuilderAndDefaultAreNotAllowed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED';
  package Moose::Exception::BothBuilderAndDefaultAreNotAllowed;$Moose::Exception::BothBuilderAndDefaultAreNotAllowed::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"Setting both default and builder is not allowed."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderDoesNotExist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST';
  package Moose::Exception::BuilderDoesNotExist;$Moose::Exception::BuilderDoesNotExist::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute','Moose::Exception::Role::Instance';sub _build_message {my$self=shift;blessed($self->instance)." does not support builder method '".$self->attribute->builder."' for attribute '".$self->attribute->name."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMethodNotSupportedForAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForAttribute;$Moose::Exception::BuilderMethodNotSupportedForAttribute::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute','Moose::Exception::Role::Instance';sub _build_message {my$self=shift;blessed($self->instance)." does not support builder method '".$self->attribute->builder ."' for attribute '" .$self->attribute->name ."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMethodNotSupportedForInlineAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForInlineAttribute;$Moose::Exception::BuilderMethodNotSupportedForInlineAttribute::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance','Moose::Exception::Role::Class';has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1);has 'builder'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;$self->class_name." does not support builder method '".$self->builder ."' for attribute '" .$self->attribute_name ."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMustBeAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME';
  package Moose::Exception::BuilderMustBeAMethodName;$Moose::Exception::BuilderMustBeAMethodName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"builder must be a defined scalar value which is a method name"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CallingMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingMethodOnAnImmutableInstance;$Moose::Exception::CallingMethodOnAnImmutableInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"The '".$self->method_name."' method cannot be called on an immutable instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CallingReadOnlyMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance;$Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"The '".$self->method_name."' method is read-only when called on an immutable instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanExtendOnlyClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES';
  package Moose::Exception::CanExtendOnlyClasses;$Moose::Exception::CanExtendOnlyClasses::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';sub _build_message {my$self=shift;my$role_name=$self->role_name;return "You cannot inherit from a Moose Role ($role_name)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanOnlyConsumeRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE';
  package Moose::Exception::CanOnlyConsumeRole;$Moose::Exception::CanOnlyConsumeRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'role_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"You can only consume roles, ".$self->role_name." is not a Moose role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanOnlyWrapBlessedCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE';
  package Moose::Exception::CanOnlyWrapBlessedCode;$Moose::Exception::CanOnlyWrapBlessedCode::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'code'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"Can only wrap blessed CODE"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanReblessOnlyIntoASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS';
  package Moose::Exception::CanReblessOnlyIntoASubclass;$Moose::Exception::CanReblessOnlyIntoASubclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Class','Moose::Exception::Role::Instance','Moose::Exception::Role::InstanceClass';sub _build_message {my$self=shift;my$instance_class=$self->instance_class;"You may rebless only into a subclass of ($instance_class), of which (".$self->class_name .") isn't."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanReblessOnlyIntoASuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS';
  package Moose::Exception::CanReblessOnlyIntoASuperclass;$Moose::Exception::CanReblessOnlyIntoASuperclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Instance','Moose::Exception::Role::InstanceClass';sub _build_message {my$self=shift;"You may rebless only into a superclass of (".blessed($self->instance)."), of which (".$self->class_name .") isn't."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAddAdditionalTypeCoercionsToUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION';
  package Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion;$Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'type_coercion_union_object'=>(is=>'ro',isa=>'Moose::Meta::TypeCoercion::Union',required=>1);sub _build_message {return "Cannot add additional type coercions to Union types"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAddAsAnAttributeToARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE';
  package Moose::Exception::CannotAddAsAnAttributeToARole;$Moose::Exception::CannotAddAsAnAttributeToARole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'attribute_class'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"Cannot add a ".$self->attribute_class." as an attribute to a role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotApplyBaseClassRolesToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE';
  package Moose::Exception::CannotApplyBaseClassRolesToRole;$Moose::Exception::CannotApplyBaseClassRolesToRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Role';sub _build_message {"You can only apply base class roles to a Moose class, not a role."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAssignValueToReadOnlyAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR';
  package Moose::Exception::CannotAssignValueToReadOnlyAccessor;$Moose::Exception::CannotAssignValueToReadOnlyAccessor::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::EitherAttributeOrAttributeName';has 'value'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"Cannot assign a value to a read-only accessor"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAugmentIfLocalMethodPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT';
  package Moose::Exception::CannotAugmentIfLocalMethodPresent;$Moose::Exception::CannotAugmentIfLocalMethodPresent::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Method';sub _build_message {"Cannot add an augment method if a local method is already present"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAugmentNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD';
  package Moose::Exception::CannotAugmentNoSuperMethod;$Moose::Exception::CannotAugmentNoSuperMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You cannot augment '".$self->method_name."' because it has no super method"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAutoDerefWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA';
  package Moose::Exception::CannotAutoDerefWithoutIsa;$Moose::Exception::CannotAutoDerefWithoutIsa::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You cannot auto-dereference without specifying a type constraint on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAutoDereferenceTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT';
  package Moose::Exception::CannotAutoDereferenceTypeConstraint;$Moose::Exception::CannotAutoDereferenceTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute','Moose::Exception::Role::Instance','Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Can not auto de-reference the type constraint '" .$self->type_name ."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCalculateNativeType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE';
  package Moose::Exception::CannotCalculateNativeType;$Moose::Exception::CannotCalculateNativeType::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';sub _build_message {my$self=shift;"Cannot calculate native type for " .ref$self->instance}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCallAnAbstractBaseMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD';
  package Moose::Exception::CannotCallAnAbstractBaseMethod;$Moose::Exception::CannotCallAnAbstractBaseMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'package_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;$self->package_name." is an abstract base class, you must provide a constructor."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCallAnAbstractMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD';
  package Moose::Exception::CannotCallAnAbstractMethod;$Moose::Exception::CannotCallAnAbstractMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"Abstract method"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCoerceAWeakRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF';
  package Moose::Exception::CannotCoerceAWeakRef;$Moose::Exception::CannotCoerceAWeakRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You cannot have a weak reference to a coerced value on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCoerceAttributeWhichHasNoCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION';
  package Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion;$Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions','Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;my$name=$self->attribute_name;my$type=$self->type_name;return "You cannot coerce an attribute ($name) unless its type ($type) has a coercion"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateHigherOrderTypeWithoutATypeParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER';
  package Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter;$Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {"You cannot create a Higher Order type without a type parameter"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent;$Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role','Moose::Exception::Role::Method';has 'role_being_applied_name'=>(is=>'ro',isa=>'Str',required=>1);has 'aliased_method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"Cannot create a method alias if a local method of the same name exists"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresentInClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass;$Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role','Moose::Exception::Role::Method','Moose::Exception::Role::Class';has 'aliased_method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"Cannot create a method alias if a local method of the same name exists"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotDelegateLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT';
  package Moose::Exception::CannotDelegateLocalMethodIsPresent;$Moose::Exception::CannotDelegateLocalMethodIsPresent::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute','Moose::Exception::Role::Method';sub _build_message {my$self=shift;"You cannot overwrite a locally defined method (".$self->method->name.") with a delegation"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotDelegateWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA';
  package Moose::Exception::CannotDelegateWithoutIsa;$Moose::Exception::CannotDelegateWithoutIsa::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';sub _build_message {"Cannot delegate methods based on a Regexp without a type constraint (isa)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS';
  package Moose::Exception::CannotFindDelegateMetaclass;$Moose::Exception::CannotFindDelegateMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';sub _build_message {my$self=shift;"Cannot find delegate metaclass for attribute ".$self->attribute->name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE';
  package Moose::Exception::CannotFindType;$Moose::Exception::CannotFindType::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'type_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Cannot find type '".$self->type_name."', perhaps you forgot to load it"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindTypeGivenToMatchOnType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE';
  package Moose::Exception::CannotFindTypeGivenToMatchOnType;$Moose::Exception::CannotFindTypeGivenToMatchOnType::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'to_match'=>(is=>'ro',isa=>'Any',required=>1);has 'action'=>(is=>'ro',isa=>'Any',required=>1);has 'type'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;my$type=$self->type;return "Cannot find or parse the type '$type'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFixMetaclassCompatibility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY';
  package Moose::Exception::CannotFixMetaclassCompatibility;$Moose::Exception::CannotFixMetaclassCompatibility::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'superclass'=>(is=>'ro',isa=>'Object',required=>1);has 'metaclass_type'=>(is=>'ro',isa=>'Str',);sub _build_message {my$self=shift;my$class_name=$self->class_name;"Can't fix metaclass incompatibility for $class_name because it is not pristine."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotGenerateInlineConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT';
  package Moose::Exception::CannotGenerateInlineConstraint;$Moose::Exception::CannotGenerateInlineConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';has 'parameterizable_type_object_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching parameterizable type constraint(Moose::Meta::TypeConstraint::Parameterizable):\n"."    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",);has 'value'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$type=$self->type_name;return "Can't generate an inline constraint for $type, since none was defined"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotInitializeMooseMetaRoleComposite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE';
  package Moose::Exception::CannotInitializeMooseMetaRoleComposite;$Moose::Exception::CannotInitializeMooseMetaRoleComposite::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'role_composite'=>(is=>'ro',isa=>'Moose::Meta::Role::Composite',required=>1);has 'old_meta'=>(is=>'ro',isa=>'Any',required=>1);has 'args'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotInlineTypeConstraintCheck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK';
  package Moose::Exception::CannotInlineTypeConstraintCheck;$Moose::Exception::CannotInlineTypeConstraintCheck::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;'Cannot inline a type constraint check for ' .$self->type_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotLocatePackageInINC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC';
  package Moose::Exception::CannotLocatePackageInINC;$Moose::Exception::CannotLocatePackageInINC::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'INC'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'possible_packages'=>(is=>'ro',isa=>'Str',required=>1);has 'metaclass_name'=>(is=>'ro',isa=>'Str',required=>1);has 'type'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;my$possible_packages=$self->possible_packages;my@inc=@{$self->INC};return "Can't locate $possible_packages in \@INC (\@INC contains: @INC)."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotMakeMetaclassCompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE';
  package Moose::Exception::CannotMakeMetaclassCompatible;$Moose::Exception::CannotMakeMetaclassCompatible::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'superclass_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$class_name=$self->class_name;my$superclass=$self->superclass_name;return "Can't make $class_name compatible with metaclass $superclass"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideALocalMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD';
  package Moose::Exception::CannotOverrideALocalMethod;$Moose::Exception::CannotOverrideALocalMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"Cannot add an override of method '".$self->method_name."' because there is a local version of '".$self->method_name."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideBodyOfMetaMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS';
  package Moose::Exception::CannotOverrideBodyOfMetaMethods;$Moose::Exception::CannotOverrideBodyOfMetaMethods::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"Overriding the body of meta methods is not allowed"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT';
  package Moose::Exception::CannotOverrideLocalMethodIsPresent;$Moose::Exception::CannotOverrideLocalMethodIsPresent::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Method';sub _build_message {"Cannot add an override method if a local method is already present"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD';
  package Moose::Exception::CannotOverrideNoSuperMethod;$Moose::Exception::CannotOverrideNoSuperMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You cannot override '".$self->method_name."' because it has no super method"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotRegisterUnnamedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT';
  package Moose::Exception::CannotRegisterUnnamedTypeConstraint;$Moose::Exception::CannotRegisterUnnamedTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"can't register an unnamed type constraint"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotUseLazyBuildAndDefaultSimultaneously.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY';
  package Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously;$Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You can not use lazy_build and default for the same attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CircularReferenceInAlso.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO';
  package Moose::Exception::CircularReferenceInAlso;$Moose::Exception::CircularReferenceInAlso::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'also_parameter'=>(is=>'ro',isa=>'Str',required=>1);has 'stack'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {my$self=shift;my$also_member=$self->also_parameter;my@stack=@{$self->stack};my$existing_stack=join(', ',@stack);return "Circular reference in 'also' parameter to Moose::Exporter between " ."$existing_stack and $also_member"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassDoesNotHaveInitMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA';
  package Moose::Exception::ClassDoesNotHaveInitMeta;$Moose::Exception::ClassDoesNotHaveInitMeta::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'traits'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {my$self=shift;my$class=$self->class_name;return "Cannot provide traits when $class does not have an init_meta() method"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE';
  package Moose::Exception::ClassDoesTheExcludedRole;$Moose::Exception::ClassDoesTheExcludedRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role','Moose::Exception::Role::Class';has 'excluded_role_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$excluded_role_name=$self->excluded_role_name;my$class_name=$self->class_name;return "The class $class_name does the excluded role '$excluded_role_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH';
  package Moose::Exception::ClassNamesDoNotMatch;$Moose::Exception::ClassNamesDoNotMatch::VERSION='2.1213';use Moose;extends 'Moose::Exception';has class_name=>(is=>'ro',isa=>'Str',required=>1,);has class=>(is=>'ro',isa=>'Class::MOP::Class',required=>1,);sub _build_message {my$self=shift;"class_name (".$self-> class_name.") does not match class->name (".$self->class->name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CloneObjectExpectsAnInstanceOfMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS';
  package Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass;$Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'instance'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {my$self=shift;"You must pass an instance of the metaclass (" .$self->class_name."), not (".$self->instance.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CodeBlockMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF';
  package Moose::Exception::CodeBlockMustBeACodeRef;$Moose::Exception::CodeBlockMustBeACodeRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Instance';sub _build_message {"Your code block must be a CODE reference"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercingWithoutCoercions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS';
  package Moose::Exception::CoercingWithoutCoercions;$Moose::Exception::CoercingWithoutCoercions::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Cannot coerce without a type coercion"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercionAlreadyExists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS';
  package Moose::Exception::CoercionAlreadyExists;$Moose::Exception::CoercionAlreadyExists::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';has 'constraint_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"A coercion action already exists for '".$self->constraint_name."'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercionNeedsTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT';
  package Moose::Exception::CoercionNeedsTypeConstraint;$Moose::Exception::CoercionNeedsTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You cannot have coercion without specifying a type constraint on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusions;$Moose::Exception::ConflictDetectedInCheckRoleExclusions::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'excluded_role_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$role_name=$self->role_name;my$excluded_role_name=$self->excluded_role_name;return "Conflict detected: $role_name excludes role '$excluded_role_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusionsInToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass;$Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Role';sub _build_message {my$self=shift;my$class_name=$self->class_name;my$role_name=$self->role_name;return "Conflict detected: $class_name excludes role '$role_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConstructClassInstanceTakesPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME';
  package Moose::Exception::ConstructClassInstanceTakesPackageName;$Moose::Exception::ConstructClassInstanceTakesPackageName::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You must pass a package name"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotCreateMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD';
  package Moose::Exception::CouldNotCreateMethod;$Moose::Exception::CouldNotCreateMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'option_name'=>(is=>'ro',isa=>'Str',required=>1);has 'option_value'=>(is=>'ro',isa=>'Any',required=>1);has 'error'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Could not create the '".$self->option_name."' method for " .$self->attribute->name ." because : ".$self->error}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotCreateWriter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER';
  package Moose::Exception::CouldNotCreateWriter;$Moose::Exception::CouldNotCreateWriter::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::EitherAttributeOrAttributeName','Moose::Exception::Role::Instance';has 'error'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$error=$self->error;my$attribute_name=$self->attribute_name;return "Could not create writer for '$attribute_name' " ."because $error"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotEvalConstructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR';
  package Moose::Exception::CouldNotEvalConstructor;$Moose::Exception::CouldNotEvalConstructor::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'constructor_method'=>(is=>'ro',isa=>'Class::MOP::Method::Constructor',required=>1);has 'source'=>(is=>'ro',isa=>'Str',required=>1);has 'error'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$error=$self->error;my$source=$self->source;return "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$error"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotEvalDestructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR';
  package Moose::Exception::CouldNotEvalDestructor;$Moose::Exception::CouldNotEvalDestructor::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'method_destructor_object'=>(is=>'ro',isa=>'Moose::Meta::Method::Destructor',required=>1);has 'source'=>(is=>'ro',isa=>'Str',required=>1);has 'error'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$error=$self->error;my$source=$self->source;return "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$error"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotFindTypeConstraintToCoerceFrom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM';
  package Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom;$Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';has 'constraint_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Could not find the type constraint (".$self->constraint_name.") to coerce from"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotGenerateInlineAttributeMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD';
  package Moose::Exception::CouldNotGenerateInlineAttributeMethod;$Moose::Exception::CouldNotGenerateInlineAttributeMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';has 'option'=>(is=>'ro',isa=>'Str',required=>1);has 'error'=>(is=>'ro',isa=>'Str|Moose::Exception',required=>1);sub _build_message {my$self=shift;"Could not generate inline ".$self->option." because : ".$self->error}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotLocateTypeConstraintForUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION';
  package Moose::Exception::CouldNotLocateTypeConstraintForUnion;$Moose::Exception::CouldNotLocateTypeConstraintForUnion::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Could not locate type constraint (".$self->type_name.") for the union"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotParseType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE';
  package Moose::Exception::CouldNotParseType;$Moose::Exception::CouldNotParseType::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'type'=>(is=>'ro',isa=>'Str',required=>1);has 'position'=>(is=>'ro',isa=>'Int',required=>1);sub _build_message {my$self=shift;my$type=$self->type;my$length=length($type);my$position=$self->position;return "'$type' didn't parse (parse-pos=$position" ." and str-length=$length)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes;$Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreateMOPClass';sub _build_message {"You must pass an ARRAY ref of attributes"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfSuperclasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses;$Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreateMOPClass';sub _build_message {"You must pass an ARRAY ref of superclasses"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateMOPClassTakesHashRefOfMethods;$Moose::Exception::CreateMOPClassTakesHashRefOfMethods::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreateMOPClass';sub _build_message {"You must pass an HASH ref of methods"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesArrayRefOfRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES';
  package Moose::Exception::CreateTakesArrayRefOfRoles;$Moose::Exception::CreateTakesArrayRefOfRoles::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreate';sub _build_message {"You must pass an ARRAY ref of roles"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesHashRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES';
  package Moose::Exception::CreateTakesHashRefOfAttributes;$Moose::Exception::CreateTakesHashRefOfAttributes::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreate';sub _build_message {"You must pass a HASH ref of attributes"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateTakesHashRefOfMethods;$Moose::Exception::CreateTakesHashRefOfMethods::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::RoleForCreate';sub _build_message {"You must pass a HASH ref of methods"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DefaultToMatchOnTypeMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF';
  package Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef;$Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'to_match'=>(is=>'ro',isa=>'Any',required=>1);has 'default_action'=>(is=>'ro',isa=>'Any',required=>1);has 'cases_to_be_matched'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {my$self=shift;my$default=$self->default_action;return "Default case must be a CODE ref, not $default"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToAClassWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED';
  package Moose::Exception::DelegationToAClassWhichIsNotLoaded;$Moose::Exception::DelegationToAClassWhichIsNotLoaded::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'class_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"The ".$self->attribute->name." attribute is trying to delegate to a class which has not been loaded - ".$self->class_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToARoleWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED';
  package Moose::Exception::DelegationToARoleWhichIsNotLoaded;$Moose::Exception::DelegationToARoleWhichIsNotLoaded::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'role_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"The ".$self->attribute->name." attribute is trying to delegate to a role which has not been loaded - ".$self->role_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToATypeWhichIsNotAClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS';
  package Moose::Exception::DelegationToATypeWhichIsNotAClass;$Moose::Exception::DelegationToATypeWhichIsNotAClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';sub _build_message {my$self=shift;"The ".$self->attribute->name." attribute is trying to delegate to a type (".$self->attribute->type_constraint->name.") that is not backed by a class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DoesRequiresRoleName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME';
  package Moose::Exception::DoesRequiresRoleName;$Moose::Exception::DoesRequiresRoleName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"You must supply a role name to does()"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/EnumCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs;$Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'array'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'args'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {"enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/EnumValuesMustBeString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING';
  package Moose::Exception::EnumValuesMustBeString;$Moose::Exception::EnumValuesMustBeString::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'value'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"Enum values must be strings, not ".(defined$self->value ? "'".$self->value."'" : "undef")}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ExtendsMissingArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS';
  package Moose::Exception::ExtendsMissingArgs;$Moose::Exception::ExtendsMissingArgs::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"Must derive at least one class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/HandlesMustBeAHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF';
  package Moose::Exception::HandlesMustBeAHashRef;$Moose::Exception::HandlesMustBeAHashRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';has 'given_handles'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"The 'handles' option must be a HASH reference, not ".$self->given_handles}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IllegalInheritedOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS';
  package Moose::Exception::IllegalInheritedOptions;$Moose::Exception::IllegalInheritedOptions::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'illegal_options'=>(is=>'ro',traits=>['Array'],handles=>{_join_options=>'join',},required=>1,);sub _build_message {my$self=shift;"Illegal inherited options => (".$self->_join_options(', ').")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IllegalMethodTypeToAddMethodModifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER';
  package Moose::Exception::IllegalMethodTypeToAddMethodModifier;$Moose::Exception::IllegalMethodTypeToAddMethodModifier::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'class_or_object'=>(is=>'ro',isa=>"Any",required=>1,);has 'params'=>(is=>'ro',isa=>'ArrayRef',required=>1,);has 'modifier_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Methods passed to ".$self->modifier_name." must be provided as a list, arrayref or regex, not ".$self->params->[0]}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IncompatibleMetaclassOfSuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS';
  package Moose::Exception::IncompatibleMetaclassOfSuperclass;$Moose::Exception::IncompatibleMetaclassOfSuperclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has [qw/superclass_name superclass_meta_type class_meta_type/]=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;my$class_name=$self->class_name;my$class_meta_type=$self->class_meta_type;my$superclass_name=$self->superclass_name;my$supermeta_type=$self->superclass_meta_type;return "The metaclass of $class_name ($class_meta_type)" ." is not compatible with the metaclass of its superclass, " ."$superclass_name ($supermeta_type)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InitMetaRequiresClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS';
  package Moose::Exception::InitMetaRequiresClass;$Moose::Exception::InitMetaRequiresClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';sub _build_message {"Cannot call init_meta without specifying a for_class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InitializeTakesUnBlessedPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME';
  package Moose::Exception::InitializeTakesUnBlessedPackageName;$Moose::Exception::InitializeTakesUnBlessedPackageName::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'package_name'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {"You must pass a package name and it cannot be blessed"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InstanceBlessedIntoWrongClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS';
  package Moose::Exception::InstanceBlessedIntoWrongClass;$Moose::Exception::InstanceBlessedIntoWrongClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Class','Moose::Exception::Role::Instance';sub _build_message {my$self=shift;"Objects passed as the __INSTANCE__ parameter must already be blessed into the correct class, but ".$self->instance." is not a " .$self->class_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InstanceMustBeABlessedReference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE';
  package Moose::Exception::InstanceMustBeABlessedReference;$Moose::Exception::InstanceMustBeABlessedReference::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Class';has 'instance'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"The __INSTANCE__ parameter must be a blessed reference, not ".$self->instance}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgPassedToMooseUtilMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE';
  package Moose::Exception::InvalidArgPassedToMooseUtilMetaRole;$Moose::Exception::InvalidArgPassedToMooseUtilMetaRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'argument'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;my$error='When using Moose::Util::MetaRole, you must pass a Moose class name,' .' role name, metaclass object, or metarole object.';my$arg=$self->argument;my$found=blessed$arg ? $arg : Class::MOP::class_of($arg);my$error2;if (defined$found && blessed$found){$error2=" You passed ".$arg.", and we resolved this to a " .(blessed$found).' object.'}elsif (!defined$found){$error2=" You passed ".(defined$arg ? $arg : "undef").", and this did not resolve to a metaclass or metarole." .' Maybe you need to call Moose->init_meta to initialize the metaclass first?'}else {$error2=" You passed an undef." .' Maybe you need to call Moose->init_meta to initialize the metaclass first?'}$error.$error2}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgumentToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD';
  package Moose::Exception::InvalidArgumentToMethod;$Moose::Exception::InvalidArgumentToMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'argument'=>(is=>'ro',isa=>'Any',required=>1);has [qw(type type_of_argument method_name)]=>(is=>'ro',isa=>'Str',required=>1);has 'ordinal'=>(is=>'ro',isa=>'Str',predicate=>'is_ordinal_set');has 'argument_noun'=>(is=>'ro',isa=>'Str',default=>'argument');sub _build_message {my$self=shift;my$article=($self->type_of_argument =~ /^[aeiou]/ ? 'an ' : 'a ');my$arg_noun=$self->argument_noun;if($self->is_ordinal_set){"The ".$self->ordinal." $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument}else {"The $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgumentsToTraitAliases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES';
  package Moose::Exception::InvalidArgumentsToTraitAliases;$Moose::Exception::InvalidArgumentsToTraitAliases::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';use Scalar::Util qw(reftype);has 'alias'=>(is=>'ro',isa=>'Any',required=>1);has 'package_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$alias=$self->alias;my$reftype_alias=reftype($alias);return "$reftype_alias references are not " ."valid arguments to the 'trait_aliases' option"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidBaseTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint;$Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Could not locate the base type (".$self->type_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidHandleValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE';
  package Moose::Exception::InvalidHandleValue;$Moose::Exception::InvalidHandleValue::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';has 'handle_value'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"All values passed to handles must be strings or ARRAY references, not ".$self->handle_value}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidHasProvidedInARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE';
  package Moose::Exception::InvalidHasProvidedInARole;$Moose::Exception::InvalidHasProvidedInARole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {"Usage: has 'name' => ( key => value, ... )"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidNameForType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE';
  package Moose::Exception::InvalidNameForType;$Moose::Exception::InvalidNameForType::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;$self->name." contains invalid characters for a type name. Names can contain alphanumeric character, ':', and '.'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidRoleApplication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION';
  package Moose::Exception::InvalidRoleApplication;$Moose::Exception::InvalidRoleApplication::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'application'=>(is=>'ro',isa=>"Any",required=>1,);sub _build_message {"Role applications must be instances of Moose::Meta::Role::Application::ToClass"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeConstraint;$Moose::Exception::InvalidTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'registry_object'=>(is=>'ro',isa=>'Moose::Meta::TypeConstraint::Registry',required=>1);has 'type'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {return "No type supplied / type is not a valid type constraint"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint;$Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Could not parse type name (".$self->type_name.") correctly"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidValueForIs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS';
  package Moose::Exception::InvalidValueForIs;$Moose::Exception::InvalidValueForIs::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"I do not understand this option (is => ".$self->params->{is}.") on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IsaDoesNotDoTheRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE';
  package Moose::Exception::IsaDoesNotDoTheRole;$Moose::Exception::IsaDoesNotDoTheRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"Cannot have an isa option and a does option if the isa does not do the does on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IsaLacksDoesMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD';
  package Moose::Exception::IsaLacksDoesMethod;$Moose::Exception::IsaLacksDoesMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"Cannot have an isa option which cannot ->does() on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/LazyAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::LazyAttributeNeedsADefault;$Moose::Exception::LazyAttributeNeedsADefault::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::EitherAttributeOrAttributeName';sub _build_message {my$self=shift;"You cannot have a lazy attribute (".$self->attribute_name.") without specifying a default value for it"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY';
  package Moose::Exception::Legacy;$Moose::Exception::Legacy::VERSION='2.1213';use Moose;extends 'Moose::Exception';1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MOPAttributeNewNeedsAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME';
  package Moose::Exception::MOPAttributeNewNeedsAttributeName;$Moose::Exception::MOPAttributeNewNeedsAttributeName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must provide a name for the attribute"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MatchActionMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF';
  package Moose::Exception::MatchActionMustBeACodeRef;$Moose::Exception::MatchActionMustBeACodeRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';has 'to_match'=>(is=>'ro',isa=>'Any',required=>1,);has 'action'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;my$action=$self->action;return "Match action must be a CODE ref, not $action"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MessageParameterMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF';
  package Moose::Exception::MessageParameterMustBeCodeRef;$Moose::Exception::MessageParameterMustBeCodeRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"The 'message' parameter must be a coderef"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsAClassNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass;$Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';use Moose::Util 'find_meta';has 'metaclass'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$class=find_meta($self->class_name);$self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass." ($class). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsARoleNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass;$Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';use Moose::Util 'find_meta';has 'metaclass'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$role_name=$self->role_name;my$role=find_meta($role_name);my$metaclass=$self->metaclass;return "$role_name already has a metaclass, but it does not inherit $metaclass ($role). " ."You cannot make the same thing a role and a class. Remove either Moose or Moose::Role."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass;$Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';use Moose::Util 'find_meta';has 'metaclass'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$class=find_meta($self->class_name);$self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass." ($class)."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass;$Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {my$self=shift;"The Metaclass ".$self->class_name." must be a subclass of Moose::Meta::Class."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole;$Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';sub _build_message {my$self=shift;"The Metaclass ".$self->role_name." must be a subclass of Moose::Meta::Role."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeDerivedFromClassMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS';
  package Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass;$Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'class_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"The metaclass (".$self->class_name.") must be derived from Class::MOP::Class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED';
  package Moose::Exception::MetaclassNotLoaded;$Moose::Exception::MetaclassNotLoaded::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {my$self=shift;"The Metaclass ".$self->class_name." must be loaded. (Perhaps you forgot to 'use ".$self->class_name."'?)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassTypeIncompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE';
  package Moose::Exception::MetaclassTypeIncompatible;$Moose::Exception::MetaclassTypeIncompatible::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';use Moose::Util 'find_meta';has [qw(superclass_name metaclass_type)]=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$class_name=$self->class_name;my$superclass_name=$self->superclass_name;my$metaclass_type=$self->metaclass_type;my$metaclass_type_name=$metaclass_type;$metaclass_type_name =~ s/_(?:meta)?class$//;$metaclass_type_name =~ s/_/ /g;my$class=find_meta($class_name);my$self_metaclass_type=$class->$metaclass_type;my$super_meta=Class::MOP::get_metaclass_by_name($superclass_name);my$super_metatype=$super_meta->$metaclass_type;return "The $metaclass_type metaclass for $class_name" ." ($self_metaclass_type) is not compatible with the $metaclass_type_name" ." metaclass of its superclass, $superclass_name ($super_metatype)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectedAMetaclassObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT';
  package Moose::Exception::MethodExpectedAMetaclassObject;$Moose::Exception::MethodExpectedAMetaclassObject::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'metaclass'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"The is_needed method expected a metaclass object as its arugment"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectsFewerArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS';
  package Moose::Exception::MethodExpectsFewerArgs;$Moose::Exception::MethodExpectsFewerArgs::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1,);has 'maximum_args'=>(is=>'ro',isa=>'Int',required=>1,);sub _build_message {my$self=shift;my$max=$self->maximum_args;"Cannot call ".$self->method_name." with ".($max ? "more than $max" : 'any')." argument".($max==1 ? '' : 's')}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectsMoreArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS';
  package Moose::Exception::MethodExpectsMoreArgs;$Moose::Exception::MethodExpectsMoreArgs::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);has 'minimum_args'=>(is=>'ro',isa=>'Int',required=>1);sub _build_message {my$self=shift;"Cannot call ".$self->method_name." without at least ".$self->minimum_args." argument".($self->minimum_args==1 ? '' : 's')}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodModifierNeedsMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME';
  package Moose::Exception::MethodModifierNeedsMethodName;$Moose::Exception::MethodModifierNeedsMethodName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"You must pass in a method name"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES';
  package Moose::Exception::MethodNameConflictInRoles;$Moose::Exception::MethodNameConflictInRoles::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'conflict'=>(traits=>['Array'],is=>'ro',isa=>'ArrayRef[Moose::Meta::Role::Method::Conflicting]',handles=>{conflict_methods_count=>'count',get_method_at=>'get',get_all_methods=>'elements',},required=>1);sub _get_method_names {my$self=shift;return ($self->conflict_methods_count==1 ? "'".$self->get_method_at(0)->name."'": Moose::Util::english_list(map {q{'} .$_->name .q{'}}$self->get_all_methods))}sub _build_message {my$self=shift;my$count=$self->conflict_methods_count;my$roles=$self->get_method_at(0)->roles_as_english_list;if($count==1){"Due to a method name conflict in roles " .$roles.", the method ".$self->_get_method_names ." must be implemented or excluded by '".$self->class_name."'"}else {"Due to method name conflicts in roles " .$roles.", the methods ".$self->_get_method_names ." must be implemented or excluded by '".$self->class_name."'"}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameNotFoundInInheritanceHierarchy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY';
  package Moose::Exception::MethodNameNotFoundInInheritanceHierarchy;$Moose::Exception::MethodNameNotFoundInInheritanceHierarchy::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"The method '".$self->method_name."' was not found in the inheritance hierarchy for ".$self->class_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameNotGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN';
  package Moose::Exception::MethodNameNotGiven;$Moose::Exception::MethodNameNotGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"You must define a method name to find"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustDefineAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME';
  package Moose::Exception::MustDefineAMethodName;$Moose::Exception::MustDefineAMethodName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Instance';sub _build_message {"You must define a method name"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustDefineAnAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME';
  package Moose::Exception::MustDefineAnAttributeName;$Moose::Exception::MustDefineAnAttributeName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"You must define an attribute name"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustHaveAtLeastOneValueToEnumerate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE';
  package Moose::Exception::MustHaveAtLeastOneValueToEnumerate;$Moose::Exception::MustHaveAtLeastOneValueToEnumerate::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must have at least one value to enumerate through"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAHashOfOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS';
  package Moose::Exception::MustPassAHashOfOptions;$Moose::Exception::MustPassAHashOfOptions::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must pass a hash of options"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAMooseMetaRoleInstanceOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS';
  package Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass;$Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'role'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"You must pass a Moose::Meta::Role instance (or a subclass)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAPackageNameOrAnExistingClassMOPPackageInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE';
  package Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance;$Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {"You must pass a package name or an existing Class::MOP::Package instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassEvenNumberOfArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS';
  package Moose::Exception::MustPassEvenNumberOfArguments;$Moose::Exception::MustPassEvenNumberOfArguments::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'args'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You must pass an even number of arguments to ".$self->method_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassEvenNumberOfAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS';
  package Moose::Exception::MustPassEvenNumberOfAttributeOptions;$Moose::Exception::MustPassEvenNumberOfAttributeOptions::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'options'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {return 'You must pass an even number of attribute options'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustProvideANameForTheAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE';
  package Moose::Exception::MustProvideANameForTheAttribute;$Moose::Exception::MustProvideANameForTheAttribute::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must provide a name for the attribute"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD';
  package Moose::Exception::MustSpecifyAtleastOneMethod;$Moose::Exception::MustSpecifyAtleastOneMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';sub _build_message {"Must specify at least one method"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE';
  package Moose::Exception::MustSpecifyAtleastOneRole;$Moose::Exception::MustSpecifyAtleastOneRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';sub _build_message {"Must specify at least one role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneRoleToApplicant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT';
  package Moose::Exception::MustSpecifyAtleastOneRoleToApplicant;$Moose::Exception::MustSpecifyAtleastOneRoleToApplicant::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'applicant'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {my$self=shift;"Must specify at least one role to apply to ".$self->applicant}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAClassMOPAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAClassMOPAttributeInstance;$Moose::Exception::MustSupplyAClassMOPAttributeInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply an attribute which is a 'Class::MOP::Attribute' instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyADelegateToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD';
  package Moose::Exception::MustSupplyADelegateToMethod;$Moose::Exception::MustSupplyADelegateToMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply a delegate_to_method which is a method name or a CODE reference"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS';
  package Moose::Exception::MustSupplyAMetaclass;$Moose::Exception::MustSupplyAMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You must pass a metaclass instance if you want to inline"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAMooseMetaAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAMooseMetaAttributeInstance;$Moose::Exception::MustSupplyAMooseMetaAttributeInstance::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply an attribute which is a 'Moose::Meta::Attribute' instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAnAccessorTypeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAccessorTypeToConstructWith;$Moose::Exception::MustSupplyAnAccessorTypeToConstructWith::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply an accessor_type to construct with"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAnAttributeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAttributeToConstructWith;$Moose::Exception::MustSupplyAnAttributeToConstructWith::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply an attribute to construct with"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyArrayRefAsCurriedArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS';
  package Moose::Exception::MustSupplyArrayRefAsCurriedArguments;$Moose::Exception::MustSupplyArrayRefAsCurriedArguments::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash','Moose::Exception::Role::Class';sub _build_message {"You must supply a curried_arguments which is an ARRAY reference"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyPackageNameAndName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME';
  package Moose::Exception::MustSupplyPackageNameAndName;$Moose::Exception::MustSupplyPackageNameAndName::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You must supply the package_name and name parameters"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeedsTypeConstraintUnionForTypeCoercionUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION';
  package Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion;$Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';has 'type_coercion_union_object'=>(is=>'ro',isa=>'Moose::Meta::TypeCoercion::Union',required=>1);sub _build_message {my$self=shift;my$type_constraint=$self->type_name;return "You can only create a Moose::Meta::TypeCoercion::Union for a " ."Moose::Meta::TypeConstraint::Union, not a $type_constraint"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherAttributeNorAttributeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN';
  package Moose::Exception::NeitherAttributeNorAttributeNameIsGiven;$Moose::Exception::NeitherAttributeNorAttributeNameIsGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You need to give attribute or attribute_name or both"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherClassNorClassNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN';
  package Moose::Exception::NeitherClassNorClassNameIsGiven;$Moose::Exception::NeitherClassNorClassNameIsGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You need to give class or class_name or both"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherRoleNorRoleNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN';
  package Moose::Exception::NeitherRoleNorRoleNameIsGiven;$Moose::Exception::NeitherRoleNorRoleNameIsGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You need to give role or role_name or both"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherTypeNorTypeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN';
  package Moose::Exception::NeitherTypeNorTypeNameIsGiven;$Moose::Exception::NeitherTypeNorTypeNameIsGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You need to give type or type_name or both"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoAttributeFoundInSuperClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS';
  package Moose::Exception::NoAttributeFoundInSuperClass;$Moose::Exception::NoAttributeFoundInSuperClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"Could not find an attribute by the name of '".$self->attribute_name."' to inherit from in ".$self->class_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoBodyToInitializeInAnAbstractBaseClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS';
  package Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass;$Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'package_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"No body to initialize, " .$self->package_name." is an abstract base class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoCasesMatched.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED';
  package Moose::Exception::NoCasesMatched;$Moose::Exception::NoCasesMatched::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'to_match'=>(is=>'ro',isa=>'Any',required=>1);has 'cases_to_be_matched'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {my$self=shift;my$to_match=$self->to_match;return "No cases matched for $to_match"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoConstraintCheckForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT';
  package Moose::Exception::NoConstraintCheckForTypeConstraint;$Moose::Exception::NoConstraintCheckForTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {my$self=shift;"Could not compile type constraint '".$self->type_name."' because no constraint check"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoDestructorClassSpecified.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED';
  package Moose::Exception::NoDestructorClassSpecified;$Moose::Exception::NoDestructorClassSpecified::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::ParamsHash';sub _build_message {"The 'inline_destructor' option is present, but no destructor class was specified"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoImmutableTraitSpecifiedForClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS';
  package Moose::Exception::NoImmutableTraitSpecifiedForClass;$Moose::Exception::NoImmutableTraitSpecifiedForClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::ParamsHash';use Moose::Util 'find_meta';sub _build_message {my$self=shift;my$class=find_meta($self->class_name);"no immutable trait specified for $class"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoParentGivenToSubtype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE';
  package Moose::Exception::NoParentGivenToSubtype;$Moose::Exception::NoParentGivenToSubtype::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"A subtype cannot consist solely of a name, it must have a parent"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OnlyInstancesCanBeCloned.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED';
  package Moose::Exception::OnlyInstancesCanBeCloned;$Moose::Exception::OnlyInstancesCanBeCloned::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::ParamsHash';has 'instance'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {my$self=shift;"You can only clone instances, (".$self->instance.") is not a blessed instance"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OperatorIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED';
  package Moose::Exception::OperatorIsRequired;$Moose::Exception::OperatorIsRequired::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"operator is required"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverrideConflictInComposition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION';
  package Moose::Exception::OverrideConflictInComposition;$Moose::Exception::OverrideConflictInComposition::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'role_being_applied_name'=>(is=>'ro',isa=>'Str',required=>1);has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);has 'two_overrides_found'=>(is=>'ro',isa=>'Bool',required=>1,default=>0);sub _build_message {my$self=shift;if($self->two_overrides_found){return "Role '" .$self->role_being_applied_name ."' has encountered an 'override' method conflict " ."during composition (Two 'override' methods of the same name encountered). " ."This is fatal error."}else {return "Role '".$self->role_being_applied_name."' has encountered an 'override' method conflict "."during composition (A local method of the same name as been found). "."This is a fatal error."}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverrideConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION';
  package Moose::Exception::OverrideConflictInSummation;$Moose::Exception::OverrideConflictInSummation::VERSION='2.1213';use Moose;extends 'Moose::Exception';use Moose::Util 'find_meta';has 'role_application'=>(is=>'ro',isa=>'Moose::Meta::Role::Application::RoleSummation',required=>1);has 'role_names'=>(traits=>['Array'],is=>'bare',isa=>'ArrayRef[Str]',handles=>{role_names=>'elements',},required=>1,documentation=>"This attribute is an ArrayRef containing role names, if you want metaobjects\n"."associated with these role names, then call method roles on the exception object.\n",);has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);has 'two_overrides_found'=>(is=>'ro',isa=>'Bool',required=>1,default=>0);sub roles {my$self=shift;my@role_names=$self->role_names;my@roles=map {find_meta($_)}@role_names;return@roles}sub _build_message {my$self=shift;my@roles=$self->role_names;my$role_names=join "|",@roles;if($self->two_overrides_found){return "We have encountered an 'override' method conflict "."during composition (Two 'override' methods of the same name encountered). "."This is fatal error."}else {return "Role '$role_names' has encountered an 'override' method conflict " ."during composition (A local method of the same name has been found). This " ."is a fatal error." }}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackageDoesNotUseMooseExporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER';
  package Moose::Exception::PackageDoesNotUseMooseExporter;$Moose::Exception::PackageDoesNotUseMooseExporter::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'package'=>(is=>'ro',isa=>'Str',required=>1);has 'is_loaded'=>(is=>'ro',isa=>'Bool',required=>1);sub _build_message {my$self=shift;my$package=$self->package;return "Package in also ($package) does not seem to " ."use Moose::Exporter" .($self->is_loaded ? "" : " (is it loaded?)")}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackageNameAndNameParamsNotGivenToWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP';
  package Moose::Exception::PackageNameAndNameParamsNotGivenToWrap;$Moose::Exception::PackageNameAndNameParamsNotGivenToWrap::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'code'=>(is=>'ro',isa=>'CodeRef',required=>1);has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"You must supply the package_name and name parameters"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackagesAndModulesAreNotCachable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE';
  package Moose::Exception::PackagesAndModulesAreNotCachable;$Moose::Exception::PackagesAndModulesAreNotCachable::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::ParamsHash';has 'is_module'=>(is=>'ro',isa=>'Bool',required=>1);sub _build_message {my$self=shift;my$is_module=$self->is_module;if($is_module){return "Modules are not cacheable"}else {return "Packages are not cacheable"}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ParameterIsNotSubtypeOfParent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT';
  package Moose::Exception::ParameterIsNotSubtypeOfParent;$Moose::Exception::ParameterIsNotSubtypeOfParent::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';use Moose::Util::TypeConstraints qw/find_type_constraint/;has 'type_parameter'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$type_parameter=$self->type_parameter;my$type=find_type_constraint($self->type_name);my$parent=$type->parent->type_parameter;return "$type_parameter is not a subtype of $parent"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ReferencesAreNotAllowedAsDefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT';
  package Moose::Exception::ReferencesAreNotAllowedAsDefault;$Moose::Exception::ReferencesAreNotAllowedAsDefault::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"References are not allowed as default values, you must wrap the default of '".$self->attribute_name."' in a CODE reference (ex: sub { [] } and not [])"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredAttributeLacksInitialization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION';
  package Moose::Exception::RequiredAttributeLacksInitialization;$Moose::Exception::RequiredAttributeLacksInitialization::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {"A required attribute must have either 'init_arg', 'builder', or 'default'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::RequiredAttributeNeedsADefault;$Moose::Exception::RequiredAttributeNeedsADefault::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"You cannot have a required attribute (".$self->attribute_name.") without a default, builder, or an init_arg"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredMethodsImportedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS';
  package Moose::Exception::RequiredMethodsImportedByClass;$Moose::Exception::RequiredMethodsImportedByClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Role';has 'missing_methods'=>(traits=>['Array'],is=>'ro',isa=>'ArrayRef[Moose::Meta::Role::Method::Required]',handles=>{method_count=>'count',get_method_at=>'get',get_all_methods=>'elements',},required=>1);has 'imported_method'=>(is=>'ro',isa=>'Moose::Meta::Role::Method::Required',required=>1);sub _build_message {my$self=shift;my$noun=$self->method_count==1 ? 'method' : 'methods';my$list=Moose::Util::english_list(map {q{'} .$_ .q{'}}$self->get_all_methods);my ($class,$role,$method)=($self->class_name,$self->role_name,$self->imported_method);my ($class_quoted,$role_quoted)=("'".$class."'","'".$role."'");"$role_quoted requires the $noun $list " ."to be implemented by $class_quoted. " ."If you imported functions intending to use them as " ."methods, you need to explicitly mark them as such, via " ."$class->meta->add_method($method" ." => \\&$method)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredMethodsNotImplementedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS';
  package Moose::Exception::RequiredMethodsNotImplementedByClass;$Moose::Exception::RequiredMethodsNotImplementedByClass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class','Moose::Exception::Role::Role';has 'missing_methods'=>(traits=>['Array'],is=>'ro',isa=>'ArrayRef[Moose::Meta::Role::Method::Required]',handles=>{method_count=>'count',get_method_at=>'get',get_all_methods=>'elements',},required=>1);sub _build_message {my$self=shift;my$noun=$self->method_count==1 ? 'method' : 'methods';my$list=Moose::Util::english_list(map {q{'} .$_ .q{'}}$self->get_all_methods);my ($role_name,$class_name)=($self->role_name,$self->class_name);return "'$role_name' requires the $noun $list " ."to be implemented by '$class_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE';
  package Moose::Exception::Role::Attribute;$Moose::Exception::Role::Attribute::VERSION='2.1213';use Moose::Role;has 'attribute'=>(is=>'ro',isa=>'Class::MOP::Attribute',predicate=>'is_attribute_set');1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/AttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME';
  package Moose::Exception::Role::AttributeName;$Moose::Exception::Role::AttributeName::VERSION='2.1213';use Moose::Role;has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS';
  package Moose::Exception::Role::Class;$Moose::Exception::Role::Class::VERSION='2.1213';use Moose::Role;has 'class_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching metaclass instance:\n"."    my \$metaclass_instance = Moose::Util::find_meta( \$exception->class_name );\n",);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/EitherAttributeOrAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME';
  package Moose::Exception::Role::EitherAttributeOrAttributeName;$Moose::Exception::Role::EitherAttributeOrAttributeName::VERSION='2.1213';use Moose::Util 'throw_exception';use Moose::Role;has 'attribute_name'=>(is=>'ro',isa=>'Str',lazy_build=>1);has 'attribute'=>(is=>'ro',isa=>'Class::MOP::Attribute',predicate=>'has_attribute');has 'params'=>(is=>'ro',isa=>'HashRef',predicate=>'has_params',);sub _build_attribute_name {my$self=shift;if(!$self->has_attribute){throw_exception("NeitherAttributeNorAttributeNameIsGiven")}return$self->attribute->name}after "BUILD"=>sub {my$self=$_[0];if($self->has_attribute_name && $self->has_attribute && ($self->attribute->name ne $self->attribute_name)){throw_exception(AttributeNamesDoNotMatch=>attribute_name=>$self->attribute_name,attribute=>$self->attribute)}};1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE';
  package Moose::Exception::Role::Instance;$Moose::Exception::Role::Instance::VERSION='2.1213';use Moose::Role;has 'instance'=>(is=>'ro',isa=>'Object',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/InstanceClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCECLASS';
  package Moose::Exception::Role::InstanceClass;$Moose::Exception::Role::InstanceClass::VERSION='2.1213';use Moose::Role;has 'instance_class'=>(is=>'ro',isa=>'Str',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCECLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/InvalidAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS';
  package Moose::Exception::Role::InvalidAttributeOptions;$Moose::Exception::Role::InvalidAttributeOptions::VERSION='2.1213';use Moose::Role;with 'Moose::Exception::Role::ParamsHash';has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD';
  package Moose::Exception::Role::Method;$Moose::Exception::Role::Method::VERSION='2.1213';use Moose::Role;has 'method'=>(is=>'ro',isa=>'Moose::Meta::Method',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/ParamsHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH';
  package Moose::Exception::Role::ParamsHash;$Moose::Exception::Role::ParamsHash::VERSION='2.1213';use Moose::Role;has 'params'=>(is=>'ro',isa=>'HashRef',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE';
  package Moose::Exception::Role::Role;$Moose::Exception::Role::Role::VERSION='2.1213';use Moose::Role;has 'role_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching metaclass instance:\n"."    my \$metaclass_instance = Moose::Util::find_meta( \$exception->role_name );\n",);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/RoleForCreate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE';
  package Moose::Exception::Role::RoleForCreate;$Moose::Exception::Role::RoleForCreate::VERSION='2.1213';use Moose::Role;with 'Moose::Exception::Role::ParamsHash';has 'attribute_class'=>(is=>'ro',isa=>'Str',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/RoleForCreateMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS';
  package Moose::Exception::Role::RoleForCreateMOPClass;$Moose::Exception::Role::RoleForCreateMOPClass::VERSION='2.1213';use Moose::Role;with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1,);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT';
  package Moose::Exception::Role::TypeConstraint;$Moose::Exception::Role::TypeConstraint::VERSION='2.1213';use Moose::Role;has 'type_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n"."    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",);1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE';
  package Moose::Exception::RoleDoesTheExcludedRole;$Moose::Exception::RoleDoesTheExcludedRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'excluded_role_name'=>(is=>'ro',isa=>'Str',required=>1);has 'second_role_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;my$role_name=$self->role_name;my$excluded_role_name=$self->excluded_role_name;return "The role $role_name does the excluded role '$excluded_role_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleExclusionConflict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT';
  package Moose::Exception::RoleExclusionConflict;$Moose::Exception::RoleExclusionConflict::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'roles'=>(is=>'ro',isa=>'ArrayRef',required=>1,);sub _build_message {my$self=shift;my@roles_array=@{$self->roles};my$role_noun="Role".(@roles_array==1 ? '' : 's');my$all_roles=join(', ',@roles_array);my$verb="exclude".(@roles_array==1 ? 's' : '');my$role_name=$self->role_name;return "Conflict detected: $role_noun $all_roles $verb role '$role_name'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleNameRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED';
  package Moose::Exception::RoleNameRequired;$Moose::Exception::RoleNameRequired::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';sub _build_message {"You must supply a role name to look for"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleNameRequiredForMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE';
  package Moose::Exception::RoleNameRequiredForMooseMetaRole;$Moose::Exception::RoleNameRequiredForMooseMetaRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';sub _build_message {"You must supply a role name to look for"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportAugment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT';
  package Moose::Exception::RolesDoNotSupportAugment;$Moose::Exception::RolesDoNotSupportAugment::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"Roles cannot support 'augment'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportExtends.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS';
  package Moose::Exception::RolesDoNotSupportExtends;$Moose::Exception::RolesDoNotSupportExtends::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"Roles do not support 'extends' (you can use 'with' to specialize a role)"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportInner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER';
  package Moose::Exception::RolesDoNotSupportInner;$Moose::Exception::RolesDoNotSupportInner::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"Roles cannot support 'inner'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportRegexReferencesForMethodModifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS';
  package Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers;$Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Role';has 'modifier_type'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Roles do not currently support regex references for ".$self->modifier_type." method modifiers"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesInCreateTakesAnArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF';
  package Moose::Exception::RolesInCreateTakesAnArrayRef;$Moose::Exception::RolesInCreateTakesAnArrayRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';sub _build_message {my$self=shift;"You must pass an ARRAY ref of roles"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesListMustBeInstancesOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE';
  package Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole;$Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'class'=>(is=>'ro',isa=>'Str',required=>1);has 'role'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;"The list of roles must be instances of Moose::Meta::Role, not ".$self->role}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/SingleParamsToNewMustBeHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF';
  package Moose::Exception::SingleParamsToNewMustBeHashRef;$Moose::Exception::SingleParamsToNewMustBeHashRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"Single parameters to new() must be a HASH ref"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TriggerMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF';
  package Moose::Exception::TriggerMustBeACodeRef;$Moose::Exception::TriggerMustBeACodeRef::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::InvalidAttributeOptions';sub _build_message {my$self=shift;"Trigger must be a CODE ref on attribute (".$self->attribute_name.")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeConstraintCannotBeUsedForAParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE';
  package Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType;$Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';has 'parent_type_name'=>(is=>'ro',isa=>'Str',required=>1,documentation=>"This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n"."    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->parent_type_name );\n",);sub _build_message {my$self=shift;my$type_name=$self->type_name;my$parent_type_name=$self->parent_type_name;"The $type_name constraint cannot be used, because " ."$parent_type_name doesn't subtype or coerce from a parameterizable type."}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeConstraintIsAlreadyCreated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED';
  package Moose::Exception::TypeConstraintIsAlreadyCreated;$Moose::Exception::TypeConstraintIsAlreadyCreated::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';use Moose::Util::TypeConstraints 'find_type_constraint';has 'package_defined_in'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;my$type_name=$self->type_name;my$type=find_type_constraint($type_name);my$type_package_defined_in=$type->_package_defined_in;my$package_defined_in=$self->package_defined_in;return "The type constraint '$type_name' has already been created in $type_package_defined_in and cannot be created again in $package_defined_in"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeParameterMustBeMooseMetaType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE';
  package Moose::Exception::TypeParameterMustBeMooseMetaType;$Moose::Exception::TypeParameterMustBeMooseMetaType::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::TypeConstraint';sub _build_message {"The type parameter must be a Moose meta type"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToCanonicalizeHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES';
  package Moose::Exception::UnableToCanonicalizeHandles;$Moose::Exception::UnableToCanonicalizeHandles::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'handles'=>(is=>'ro',isa=>'Any',required=>1,);sub _build_message {my$self=shift;"Unable to canonicalize the 'handles' option with ".$self->handles}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToCanonicalizeNonRolePackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE';
  package Moose::Exception::UnableToCanonicalizeNonRolePackage;$Moose::Exception::UnableToCanonicalizeNonRolePackage::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'handles'=>(is=>'ro',isa=>'Str',required=>1,);sub _build_message {my$self=shift;"Unable to canonicalize the 'handles' option with ".$self->handles." because its metaclass is not a Moose::Meta::Role"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToRecognizeDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS';
  package Moose::Exception::UnableToRecognizeDelegateMetaclass;$Moose::Exception::UnableToRecognizeDelegateMetaclass::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'delegate_metaclass'=>(is=>'ro',isa=>'Any',required=>1);sub _build_message {my$self=shift;my$meta=$self->delegate_metaclass;return "Unable to recognize the delegate metaclass '$meta'"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UndefinedHashKeysPassedToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD';
  package Moose::Exception::UndefinedHashKeysPassedToMethod;$Moose::Exception::UndefinedHashKeysPassedToMethod::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'hash_keys'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'method_name'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"Hash keys passed to ".$self->method_name." must be defined"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnionCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs;$Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs::VERSION='2.1213';use Moose;extends 'Moose::Exception';has 'array'=>(is=>'ro',isa=>'ArrayRef',required=>1);has 'args'=>(is=>'ro',isa=>'ArrayRef',required=>1);sub _build_message {"union called with an array reference and additional arguments"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnionTakesAtleastTwoTypeNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES';
  package Moose::Exception::UnionTakesAtleastTwoTypeNames;$Moose::Exception::UnionTakesAtleastTwoTypeNames::VERSION='2.1213';use Moose;extends 'Moose::Exception';sub _build_message {"You must pass in at least 2 type names to make a union"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ValidationFailedForInlineTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForInlineTypeConstraint;$Moose::Exception::ValidationFailedForInlineTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Class';has 'type_constraint_message'=>(is=>'ro',isa=>'Str',required=>1);has 'attribute_name'=>(is=>'ro',isa=>'Str',required=>1);has 'value'=>(is=>'ro',isa=>'Any',required=>1);has 'new_member'=>(is=>'ro',isa=>'Bool',default=>0,predicate=>'is_a_new_member');sub _build_message {my$self=shift;my$line1;if($self->new_member){$line1="A new member value for ".$self->attribute_name." does not pass its type constraint because: "}else {$line1="Attribute (".$self->attribute_name.") does not pass the type constraint because: "}return$line1 .$self->type_constraint_message}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ValidationFailedForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForTypeConstraint;$Moose::Exception::ValidationFailedForTypeConstraint::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::Attribute';has 'value'=>(is=>'ro',isa=>'Any',required=>1,);has 'type'=>(is=>'ro',isa=>Moose::Util::TypeConstraints->duck_type(["get_message","name"]),required=>1);sub _build_message {my$self=shift;my$error_message=$self->type->get_message($self->value);if($self->is_attribute_set){my$attribute_name=$self->attribute->name;return "Attribute ($attribute_name) does not pass the type constraint because: $error_message"}return$error_message}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/WrapTakesACodeRefToBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS';
  package Moose::Exception::WrapTakesACodeRefToBless;$Moose::Exception::WrapTakesACodeRefToBless::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has 'code'=>(is=>'ro',isa=>'Any',required=>1);has 'class'=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"You must supply a CODE reference to bless, not (" .($self->code ? $self->code : 'undef').")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/WrongTypeConstraintGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN';
  package Moose::Exception::WrongTypeConstraintGiven;$Moose::Exception::WrongTypeConstraintGiven::VERSION='2.1213';use Moose;extends 'Moose::Exception';with 'Moose::Exception::Role::ParamsHash';has [qw/required_type given_type attribute_name/]=>(is=>'ro',isa=>'Str',required=>1);sub _build_message {my$self=shift;"The type constraint for ".$self->attribute_name." must be a subtype of " .$self->required_type." but it's a ".$self->given_type}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXPORTER';
  package Moose::Exporter;$Moose::Exporter::VERSION='2.1213';use strict;use warnings;use Class::Load qw(is_class_loaded);use Class::MOP;use List::MoreUtils qw(first_index uniq);use Moose::Util::MetaRole;use Scalar::Util 1.11 qw(reftype);use Sub::Exporter 0.980;use Sub::Name qw(subname);use Moose::Util 'throw_exception';my%EXPORT_SPEC;sub setup_import_methods {my ($class,%args)=@_;$args{exporting_package}||=caller();$class->build_import_methods(%args,install=>[qw(import unimport init_meta)])}sub build_import_methods {my ($class,%args)=@_;my$exporting_package=$args{exporting_package}||=caller();my$meta_lookup=$args{meta_lookup}|| sub {Class::MOP::class_of(shift)};$EXPORT_SPEC{$exporting_package}=\%args;my@exports_from=$class->_follow_also($exporting_package);my$export_recorder={};my$is_reexport={};my$exports=$class->_make_sub_exporter_params([$exporting_package,@exports_from ],$export_recorder,$is_reexport,$args{meta_lookup},);my$exporter=$class->_make_exporter($exports,$is_reexport,$meta_lookup,);my%methods;$methods{import}=$class->_make_import_sub($exporting_package,$exporter,\@exports_from,$is_reexport,$meta_lookup,);$methods{unimport}=$class->_make_unimport_sub($exporting_package,$exports,$export_recorder,$is_reexport,$meta_lookup,);$methods{init_meta}=$class->_make_init_meta($exporting_package,\%args,$meta_lookup,);my$package=Class::MOP::Package->initialize($exporting_package);for my$to_install (@{$args{install}|| []}){my$symbol='&' .$to_install;next unless$methods{$to_install}&&!$package->has_package_symbol($symbol);$package->add_package_symbol($symbol,subname($exporting_package .'::' .$to_install,$methods{$to_install}))}return ($methods{import},$methods{unimport},$methods{init_meta})}sub _make_exporter {my ($class,$exports,$is_reexport,$meta_lookup)=@_;return Sub::Exporter::build_exporter({exports=>$exports,groups=>{default=>[':all']},installer=>sub {my ($arg,$to_export)=@_;my$meta=$meta_lookup->($arg->{into});goto&Sub::Exporter::default_installer unless$meta;my@filtered_to_export;my%installed;for (my$i=0;$i < @{$to_export};$i += 2){my ($as,$cv)=@{$to_export}[$i,$i + 1];next if!ref($as)&& $meta->has_package_symbol('&' .$as)&& $meta->get_package_symbol('&' .$as)==$cv;push@filtered_to_export,$as,$cv;$installed{$as}=1 unless ref$as}Sub::Exporter::default_installer($arg,\@filtered_to_export);for my$name (keys %{$is_reexport}){no strict 'refs';no warnings 'once';next unless exists$installed{$name};_flag_as_reexport(\*{join q{::},$arg->{into},$name})}},})}sub _follow_also {my$class=shift;my$exporting_package=shift;_die_if_cycle_found_in_also_list_for_package($exporting_package);return uniq(_follow_also_real($exporting_package))}sub _follow_also_real {my$exporting_package=shift;my@also=_also_list_for_package($exporting_package);return map {$_,_follow_also_real($_)}@also}sub _also_list_for_package {my$package=shift;if (!exists$EXPORT_SPEC{$package}){my$loaded=is_class_loaded($package);throw_exception(PackageDoesNotUseMooseExporter=>package=>$package,is_loaded=>$loaded)}my$also=$EXPORT_SPEC{$package}{also};return unless defined$also;return ref$also ? @$also : $also}sub _die_if_cycle_found_in_also_list_for_package {my$package=shift;_die_if_also_list_cycles_back_to_existing_stack([_also_list_for_package($package)],[$package],)}sub _die_if_also_list_cycles_back_to_existing_stack {my ($also_list,$existing_stack)=@_;return unless @$also_list && @$existing_stack;for my$also_member (@$also_list){for my$stack_member (@$existing_stack){next unless$also_member eq $stack_member;throw_exception(CircularReferenceInAlso=>also_parameter=>$also_member,stack=>$existing_stack)}_die_if_also_list_cycles_back_to_existing_stack([_also_list_for_package($also_member)],[$also_member,@$existing_stack ],)}}sub _parse_trait_aliases {my$class=shift;my ($package,$aliases)=@_;my@ret;for my$alias (@$aliases){my$name;if (ref($alias)){reftype($alias)eq 'ARRAY' or throw_exception(InvalidArgumentsToTraitAliases=>class_name=>$class,package_name=>$package,alias=>$alias);($alias,$name)=@$alias}else {($name=$alias)=~ s/.*:://}push@ret,subname "${package}::${name}"=>sub () {$alias}}return@ret}sub _make_sub_exporter_params {my$class=shift;my$packages=shift;my$export_recorder=shift;my$is_reexport=shift;my$meta_lookup_override=shift;my%exports;my$current_meta_lookup;for my$package (@{$packages}){my$args=$EXPORT_SPEC{$package}or die "The $package package does not use Moose::Exporter\n";$current_meta_lookup=$meta_lookup_override || $args->{meta_lookup};$meta_lookup_override=$current_meta_lookup;my$meta_lookup=$current_meta_lookup || sub {Class::MOP::class_of(shift)};for my$name (@{$args->{with_meta}}){my$sub=$class->_sub_from_package($package,$name)or next;my$fq_name=$package .'::' .$name;$exports{$name}=$class->_make_wrapped_sub_with_meta($fq_name,$sub,$export_recorder,$meta_lookup,)unless exists$exports{$name}}for my$name (@{$args->{with_caller}}){my$sub=$class->_sub_from_package($package,$name)or next;my$fq_name=$package .'::' .$name;$exports{$name}=$class->_make_wrapped_sub($fq_name,$sub,$export_recorder,)unless exists$exports{$name}}my@extra_exports=$class->_parse_trait_aliases($package,$args->{trait_aliases},);for my$name (@{$args->{as_is}},@extra_exports){my ($sub,$coderef_name);if (ref$name){$sub=$name;my$coderef_pkg;($coderef_pkg,$coderef_name)=Class::MOP::get_code_info($name);if ($coderef_pkg ne $package){$is_reexport->{$coderef_name}=1}}else {$sub=$class->_sub_from_package($package,$name)or next;$coderef_name=$name}$export_recorder->{$sub}=1;$exports{$coderef_name}=sub {$sub}unless exists$exports{$coderef_name}}}return \%exports}sub _sub_from_package {my$sclass=shift;my$package=shift;my$name=shift;my$sub=do {no strict 'refs';\&{$package .'::' .$name}};return$sub if defined &$sub;Carp::cluck "Trying to export undefined sub ${package}::${name}";return}our$CALLER;sub _make_wrapped_sub {my$self=shift;my$fq_name=shift;my$sub=shift;my$export_recorder=shift;return sub {my$caller=$CALLER;my$wrapper=$self->_curry_wrapper($sub,$fq_name,$caller);my$sub=subname($fq_name=>$wrapper);$export_recorder->{$sub}=1;return$sub}}sub _make_wrapped_sub_with_meta {my$self=shift;my$fq_name=shift;my$sub=shift;my$export_recorder=shift;my$meta_lookup=shift;return sub {my$caller=$CALLER;my$wrapper=$self->_late_curry_wrapper($sub,$fq_name,$meta_lookup=>$caller);my$sub=subname($fq_name=>$wrapper);$export_recorder->{$sub}=1;return$sub}}sub _curry_wrapper {my$class=shift;my$sub=shift;my$fq_name=shift;my@extra=@_;my$wrapper=sub {$sub->(@extra,@_)};if (my$proto=prototype$sub){&Scalar::Util::set_prototype($wrapper,$proto)}return$wrapper}sub _late_curry_wrapper {my$class=shift;my$sub=shift;my$fq_name=shift;my$extra=shift;my@ex_args=@_;my$wrapper=sub {my@curry=($extra->(@ex_args));return$sub->(@curry,@_)};if (my$proto=prototype$sub){&Scalar::Util::set_prototype($wrapper,$proto)}return$wrapper}sub _make_import_sub {shift;my$exporting_package=shift;my$exporter=shift;my$exports_from=shift;my$is_reexport=shift;my$meta_lookup=shift;return sub {my$traits;($traits,@_)=_strip_traits(@_);my$metaclass;($metaclass,@_)=_strip_metaclass(@_);$metaclass =Moose::Util::resolve_metaclass_alias('Class'=>$metaclass)if defined$metaclass && length$metaclass;my$meta_name;($meta_name,@_)=_strip_meta_name(@_);my$class=$exporting_package;$CALLER=_get_caller(@_);strict->import;warnings->import;my$did_init_meta;for my$c (grep {$_->can('init_meta')}$class,@{$exports_from}){local$CALLER=$CALLER;$c->init_meta(for_class=>$CALLER,metaclass=>$metaclass,meta_name=>$meta_name,);$did_init_meta=1}{local$CALLER=$CALLER;_apply_metaroles($CALLER,[$class,@$exports_from],$meta_lookup)}if ($did_init_meta && @{$traits}){local$CALLER=$CALLER;_apply_meta_traits($CALLER,$traits,$meta_lookup)}elsif (@{$traits}){throw_exception(ClassDoesNotHaveInitMeta=>class_name=>$class,traits=>$traits)}my (undef,@args)=@_;my$extra=shift@args if ref$args[0]eq 'HASH';$extra ||={};if (!$extra->{into}){$extra->{into_level}||=0;$extra->{into_level}++}$class->$exporter($extra,@args)}}sub _strip_traits {my$idx=first_index {($_ || '')eq '-traits'}@_;return ([],@_)unless$idx >= 0 && $#_ >= $idx + 1;my$traits=$_[$idx + 1 ];splice @_,$idx,2;$traits=[$traits]unless ref$traits;return ($traits,@_)}sub _strip_metaclass {my$idx=first_index {($_ || '')eq '-metaclass'}@_;return (undef,@_)unless$idx >= 0 && $#_ >= $idx + 1;my$metaclass=$_[$idx + 1 ];splice @_,$idx,2;return ($metaclass,@_)}sub _strip_meta_name {my$idx=first_index {($_ || '')eq '-meta_name'}@_;return ('meta',@_)unless$idx >= 0 && $#_ >= $idx + 1;my$meta_name=$_[$idx + 1 ];splice @_,$idx,2;return ($meta_name,@_)}sub _apply_metaroles {my ($class,$exports_from,$meta_lookup)=@_;my$metaroles=_collect_metaroles($exports_from);my$base_class_roles=delete$metaroles->{base_class_roles};my$meta=$meta_lookup->($class);return unless$meta;Moose::Util::MetaRole::apply_metaroles(for=>$meta,%$metaroles,)if keys %$metaroles;Moose::Util::MetaRole::apply_base_class_roles(for=>$meta,roles=>$base_class_roles,)if$meta->isa('Class::MOP::Class')&& $base_class_roles && @$base_class_roles}sub _collect_metaroles {my ($exports_from)=@_;my@old_style_role_types=map {"${_}_roles"}qw(metaclass attribute_metaclass method_metaclass wrapped_method_metaclass instance_metaclass constructor_class destructor_class error_class);my%class_metaroles;my%role_metaroles;my@base_class_roles;my%old_style_roles;for my$exporter (@$exports_from){my$data=$EXPORT_SPEC{$exporter};if (exists$data->{class_metaroles}){for my$type (keys %{$data->{class_metaroles}}){push @{$class_metaroles{$type}||=[]},@{$data->{class_metaroles}{$type}}}}if (exists$data->{role_metaroles}){for my$type (keys %{$data->{role_metaroles}}){push @{$role_metaroles{$type}||=[]},@{$data->{role_metaroles}{$type}}}}if (exists$data->{base_class_roles}){push@base_class_roles,@{$data->{base_class_roles}}}for my$type (@old_style_role_types){if (exists$data->{$type}){push @{$old_style_roles{$type}||=[]},@{$data->{$type}}}}}return {(keys(%class_metaroles)? (class_metaroles=>\%class_metaroles): ()),(keys(%role_metaroles)? (role_metaroles=>\%role_metaroles): ()),(@base_class_roles ? (base_class_roles=>\@base_class_roles): ()),%old_style_roles,}}sub _apply_meta_traits {my ($class,$traits,$meta_lookup)=@_;return unless @{$traits};my$meta=$meta_lookup->($class);my$type=$meta->isa('Moose::Meta::Role')? 'Role' : $meta->isa('Class::MOP::Class')? 'Class' : confess('Cannot determine metaclass type for ' .'trait application. Meta isa ' .ref$meta);my@resolved_traits=map {ref $_ ? $_ : Moose::Util::resolve_metatrait_alias($type=>$_)}@$traits;return unless@resolved_traits;my%args=(for=>$class);if ($meta->isa('Moose::Meta::Role')){$args{role_metaroles}={role=>\@resolved_traits }}else {$args{class_metaroles}={class=>\@resolved_traits }}Moose::Util::MetaRole::apply_metaroles(%args)}sub _get_caller {my$offset=1;return (ref $_[1]&& defined $_[1]->{into})? $_[1]->{into}: (ref $_[1]&& defined $_[1]->{into_level})? caller($offset + $_[1]->{into_level}): caller($offset)}sub _make_unimport_sub {shift;my$exporting_package=shift;my$exports=shift;my$export_recorder=shift;my$is_reexport=shift;my$meta_lookup=shift;return sub {my$caller=scalar caller();Moose::Exporter->_remove_keywords($caller,[keys %{$exports}],$export_recorder,$is_reexport,)}}sub _remove_keywords {shift;my$package=shift;my$keywords=shift;my$recorded_exports=shift;my$is_reexport=shift;no strict 'refs';for my$name (@{$keywords}){if (defined &{$package .'::' .$name}){my$sub=\&{$package .'::' .$name};next unless$recorded_exports->{$sub};if ($is_reexport->{$name}){no strict 'refs';next unless _export_is_flagged(\*{join q{::}=>$package,$name})}delete ${$package .'::'}{$name}}}}sub _make_init_meta {shift;my$class=shift;my$args=shift;my$meta_lookup=shift;my%old_style_roles;for my$role (map {"${_}_roles"}qw(metaclass attribute_metaclass method_metaclass wrapped_method_metaclass instance_metaclass constructor_class destructor_class error_class)){$old_style_roles{$role}=$args->{$role}if exists$args->{$role}}my%base_class_roles;%base_class_roles=(roles=>$args->{base_class_roles})if exists$args->{base_class_roles};my%new_style_roles=map {$_=>$args->{$_}}grep {exists$args->{$_}}qw(class_metaroles role_metaroles);return unless%new_style_roles || %old_style_roles || %base_class_roles;return sub {shift;my%opts=@_;$meta_lookup->($opts{for_class})}}sub import {strict->import;warnings->import}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXPORTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE';
  use strict;use warnings;package Moose::Meta::Attribute;$Moose::Meta::Attribute::VERSION='2.1213';use B ();use Scalar::Util 'blessed','weaken';use List::MoreUtils 'any';use Try::Tiny;use overload ();use Moose::Deprecated;use Moose::Meta::Method::Accessor;use Moose::Meta::Method::Delegation;use Moose::Util 'throw_exception';use Moose::Util::TypeConstraints ();use Class::MOP::MiniTrait;use parent 'Class::MOP::Attribute','Moose::Meta::Mixin::AttributeCore';use Carp 'confess';Class::MOP::MiniTrait::apply(__PACKAGE__,'Moose::Meta::Object::Trait');__PACKAGE__->meta->add_attribute('traits'=>(reader=>'applied_traits',predicate=>'has_applied_traits',Class::MOP::_definition_context(),));sub does {my ($self,$role_name)=@_;my$name=try {Moose::Util::resolve_metatrait_alias(Attribute=>$role_name)};return 0 if!defined($name);return$self->Moose::Object::does($name)}sub _inline_throw_exception {my ($self,$exception_type,$throw_args)=@_;return 'die Module::Runtime::use_module("Moose::Exception::' .$exception_type .'")->new(' .($throw_args || '').')'}sub new {my ($class,$name,%options)=@_;$class->_process_options($name,\%options)unless$options{__hack_no_process_options};delete$options{__hack_no_process_options};my%attrs=(map {$_=>1}grep {defined}map {$_->init_arg()}$class->meta()->get_all_attributes());my@bad=sort grep {!$attrs{$_}}keys%options;if (@bad){my$s=@bad > 1 ? 's' : '';my$list=join "', '",@bad;my$package=$options{definition_context}{package};my$context=$options{definition_context}{context}|| 'attribute constructor';my$type=$options{definition_context}{type}|| 'class';my$location='';if (defined($package)){$location=" in ";$location .= "$type " if$type;$location .= $package}Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location"}return$class->SUPER::new($name,%options)}sub interpolate_class_and_new {my$class=shift;my$name=shift;throw_exception(MustPassEvenNumberOfAttributeOptions=>attribute_name=>$name,options=>\@_)if @_ % 2==1;my%args=@_;my ($new_class,@traits)=$class->interpolate_class(\%args);$new_class->new($name,%args,(scalar(@traits)? (traits=>\@traits): ()))}sub interpolate_class {my ($class,$options)=@_;$class=ref($class)|| $class;if (my$metaclass_name=delete$options->{metaclass}){my$new_class=Moose::Util::resolve_metaclass_alias(Attribute=>$metaclass_name);if ($class ne $new_class){if ($new_class->can("interpolate_class")){return$new_class->interpolate_class($options)}else {$class=$new_class}}}my@traits;if (my$traits=$options->{traits}){my$i=0;my$has_foreign_options=0;while ($i < @$traits){my$trait=$traits->[$i++];next if ref($trait);$trait=Moose::Util::resolve_metatrait_alias(Attribute=>$trait)|| $trait;next if$class->does($trait);push@traits,$trait;if ($traits->[$i]&& ref($traits->[$i])){$has_foreign_options=1 if any {$_ ne '-alias' && $_ ne '-excludes'}keys %{$traits->[$i]};push@traits,$traits->[$i++]}}if (@traits){my%options=(superclasses=>[$class ],roles=>[@traits ],);if ($has_foreign_options){$options{weaken}=0}else {$options{cache}=1}my$anon_class=Moose::Meta::Class->create_anon_class(%options);$class=$anon_class->name}}return (wantarray ? ($class,@traits): $class)}sub illegal_options_for_inheritance {qw(reader writer accessor clearer predicate)}sub clone_and_inherit_options {my ($self,%options)=@_;my@illegal_options=$self->can('illegal_options_for_inheritance')? $self->illegal_options_for_inheritance : ();my@found_illegal_options=grep {exists$options{$_}&& exists$self->{$_}? $_ : undef}@illegal_options;(scalar@found_illegal_options==0)|| throw_exception(IllegalInheritedOptions=>illegal_options=>\@found_illegal_options,params=>\%options);$self->_process_isa_option($self->name,\%options);$self->_process_does_option($self->name,\%options);if ($self->can('interpolate_class')){($options{metaclass},my@traits)=$self->interpolate_class(\%options);my%seen;my@all_traits=grep {$seen{$_}++}@{$self->applied_traits || []},@traits;$options{traits}=\@all_traits if@all_traits}$self->_process_lazy_build_option($self->name,\%options)if$self->can('_process_lazy_build_option');$self->clone(%options)}sub clone {my ($self,%params)=@_;my$class=delete$params{metaclass}|| ref$self;my (@init,@non_init);for my$attr (grep {$_->has_value($self)}Class::MOP::class_of($self)->get_all_attributes){push @{$attr->has_init_arg ? \@init : \@non_init},$attr}my%new_params=((map {$_->init_arg=>$_->get_value($self)}@init),%params);my$name=delete$new_params{name};my$clone=$class->new($name,%new_params,__hack_no_process_options=>1);for my$attr (@non_init){$attr->set_value($clone,$attr->get_value($self))}return$clone}sub _process_options {my ($class,$name,$options)=@_;$class->_process_is_option($name,$options);$class->_process_isa_option($name,$options);$class->_process_does_option($name,$options);$class->_process_coerce_option($name,$options);$class->_process_trigger_option($name,$options);$class->_process_auto_deref_option($name,$options);$class->_process_lazy_build_option($name,$options);$class->_process_lazy_option($name,$options);$class->_process_required_option($name,$options)}sub _process_is_option {my ($class,$name,$options)=@_;return unless$options->{is};if ($options->{is}eq 'ro'){throw_exception("AccessorMustReadWrite"=>attribute_name=>$name,params=>$options,)if exists$options->{accessor};$options->{reader}||=$name}elsif ($options->{is}eq 'rw'){if ($options->{writer}){$options->{reader}||=$name}else {$options->{accessor}||=$name}}elsif ($options->{is}eq 'bare'){return}else {throw_exception(InvalidValueForIs=>attribute_name=>$name,params=>$options,)}}sub _process_isa_option {my ($class,$name,$options)=@_;return unless exists$options->{isa};if (exists$options->{does}){if (try {$options->{isa}->can('does')}){($options->{isa}->does($options->{does}))|| throw_exception(IsaDoesNotDoTheRole=>attribute_name=>$name,params=>$options,)}else {throw_exception(IsaLacksDoesMethod=>attribute_name=>$name,params=>$options,)}}if (blessed($options->{isa})&& $options->{isa}->isa('Moose::Meta::TypeConstraint')){$options->{type_constraint}=$options->{isa}}elsif (blessed($options->{isa})&& $options->{isa}->can('does')&& $options->{isa}->does('Specio::Constraint::Role::Interface')){$options->{type_constraint}=$options->{isa}}else {$options->{type_constraint}=Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($options->{isa},{package_defined_in=>$options->{definition_context}->{package}})}}sub _process_does_option {my ($class,$name,$options)=@_;return unless exists$options->{does}&&!exists$options->{isa};if (blessed($options->{does})&& $options->{does}->isa('Moose::Meta::TypeConstraint')){$options->{type_constraint}=$options->{does}}else {$options->{type_constraint}=Moose::Util::TypeConstraints::find_or_create_does_type_constraint($options->{does},{package_defined_in=>$options->{definition_context}->{package}})}}sub _process_coerce_option {my ($class,$name,$options)=@_;return unless$options->{coerce};(exists$options->{type_constraint})|| throw_exception(CoercionNeedsTypeConstraint=>attribute_name=>$name,params=>$options,);throw_exception(CannotCoerceAWeakRef=>attribute_name=>$name,params=>$options,)if$options->{weak_ref};unless ($options->{type_constraint}->has_coercion){my$type=$options->{type_constraint}->name;throw_exception(CannotCoerceAttributeWhichHasNoCoercion=>attribute_name=>$name,type_name=>$type,params=>$options)}}sub _process_trigger_option {my ($class,$name,$options)=@_;return unless exists$options->{trigger};('CODE' eq ref$options->{trigger})|| throw_exception(TriggerMustBeACodeRef=>attribute_name=>$name,params=>$options,)}sub _process_auto_deref_option {my ($class,$name,$options)=@_;return unless$options->{auto_deref};(exists$options->{type_constraint})|| throw_exception(CannotAutoDerefWithoutIsa=>attribute_name=>$name,params=>$options,);($options->{type_constraint}->is_a_type_of('ArrayRef')|| $options->{type_constraint}->is_a_type_of('HashRef'))|| throw_exception(AutoDeRefNeedsArrayRefOrHashRef=>attribute_name=>$name,params=>$options,)}sub _process_lazy_build_option {my ($class,$name,$options)=@_;return unless$options->{lazy_build};throw_exception(CannotUseLazyBuildAndDefaultSimultaneously=>attribute_name=>$name,params=>$options,)if exists$options->{default};$options->{lazy}=1;$options->{builder}||="_build_${name}";if ($name =~ /^_/){$options->{clearer}||="_clear${name}";$options->{predicate}||="_has${name}"}else {$options->{clearer}||="clear_${name}";$options->{predicate}||="has_${name}"}}sub _process_lazy_option {my ($class,$name,$options)=@_;return unless$options->{lazy};(exists$options->{default}|| defined$options->{builder})|| throw_exception(LazyAttributeNeedsADefault=>params=>$options,attribute_name=>$name,)}sub _process_required_option {my ($class,$name,$options)=@_;if ($options->{required}&&!((!exists$options->{init_arg}|| defined$options->{init_arg})|| exists$options->{default}|| defined$options->{builder})){throw_exception(RequiredAttributeNeedsADefault=>params=>$options,attribute_name=>$name,)}}sub initialize_instance_slot {my ($self,$meta_instance,$instance,$params)=@_;my$init_arg=$self->init_arg();my$val;my$value_is_set;if (defined($init_arg)and exists$params->{$init_arg}){$val=$params->{$init_arg};$value_is_set=1}else {return if$self->is_lazy;my$class_name=blessed($instance);throw_exception(AttributeIsRequired=>attribute_name=>$self->name,class_name=>$class_name,params=>$params,)if$self->is_required &&!$self->has_default &&!$self->has_builder;if ($self->has_default){$val=$self->default($instance);$value_is_set=1}elsif ($self->has_builder){$val=$self->_call_builder($instance);$value_is_set=1}}return unless$value_is_set;$val=$self->_coerce_and_verify($val,$instance);$self->set_initial_value($instance,$val);if (ref$val && $self->is_weak_ref){$self->_weaken_value($instance)}}sub _call_builder {my ($self,$instance)=@_;my$builder=$self->builder();return$instance->$builder()if$instance->can($self->builder);throw_exception(BuilderDoesNotExist=>instance=>$instance,attribute=>$self,)}sub _make_initializer_writer_callback {my$self=shift;my ($meta_instance,$instance,$slot_name)=@_;my$old_callback=$self->SUPER::_make_initializer_writer_callback(@_);return sub {$old_callback->($self->_coerce_and_verify($_[0],$instance))}}sub set_value {my ($self,$instance,@args)=@_;my$value=$args[0];my$attr_name=quotemeta($self->name);my$class_name=blessed($instance);if ($self->is_required and not @args){throw_exception(AttributeIsRequired=>attribute_name=>$self->name,class_name=>$class_name,)}$value=$self->_coerce_and_verify($value,$instance);my@old;if ($self->has_trigger && $self->has_value($instance)){@old=$self->get_value($instance,'for trigger')}$self->SUPER::set_value($instance,$value);if (ref$value && $self->is_weak_ref){$self->_weaken_value($instance)}if ($self->has_trigger){$self->trigger->($instance,$value,@old)}}sub _inline_set_value {my$self=shift;my ($instance,$value,$tc,$coercion,$message,$for_constructor)=@_;my$old='@old';my$copy='$val';$tc ||='$type_constraint';$coercion ||='$type_coercion';$message ||='$type_message';my@code;if ($self->_writer_value_needs_copy){push@code,$self->_inline_copy_value($value,$copy);$value=$copy}push@code,$self->_inline_check_required unless$for_constructor;push@code,$self->_inline_tc_code($value,$tc,$coercion,$message);push@code,$self->_inline_get_old_value_for_trigger($instance,$old)unless$for_constructor;push@code,($self->SUPER::_inline_set_value($instance,$value),$self->_inline_weaken_value($instance,$value),);push@code,$self->_inline_trigger($instance,$value,$old)unless$for_constructor;return@code}sub _writer_value_needs_copy {my$self=shift;return$self->should_coerce}sub _inline_copy_value {my$self=shift;my ($value,$copy)=@_;return 'my ' .$copy .' = ' .$value .';'}sub _inline_check_required {my$self=shift;return unless$self->is_required;my$attr_name=quotemeta($self->name);return ('if (@_ < 2) {',$self->_inline_throw_exception(AttributeIsRequired=>'attribute_name      => "'.$attr_name.'",'.'class_name          => $class_name').';','}',)}sub _inline_tc_code {my$self=shift;my ($value,$tc,$coercion,$message,$is_lazy)=@_;return ($self->_inline_check_coercion($value,$tc,$coercion,$is_lazy,),$self->_inline_check_constraint($value,$tc,$message,$is_lazy,),)}sub _inline_check_coercion {my$self=shift;my ($value,$tc,$coercion)=@_;return unless$self->should_coerce && $self->type_constraint->has_coercion;if ($self->type_constraint->can_be_inlined){return ('if (! (' .$self->type_constraint->_inline_check($value).')) {',$value .' = ' .$coercion .'->(' .$value .');','}',)}else {return ('if (!' .$tc .'->(' .$value .')) {',$value .' = ' .$coercion .'->(' .$value .');','}',)}}sub _inline_check_constraint {my$self=shift;my ($value,$tc,$message)=@_;return unless$self->has_type_constraint;my$attr_name=quotemeta($self->name);if ($self->type_constraint->can_be_inlined){return ('if (! (' .$self->type_constraint->_inline_check($value).')) {','my $msg = do { local $_ = ' .$value .'; ' .$message .'->(' .$value .');' .'};'.$self->_inline_throw_exception(ValidationFailedForInlineTypeConstraint=>'type_constraint_message => $msg , '.'class_name              => $class_name, '.'attribute_name          => "'.$attr_name.'",'.'value                   => '.$value).';','}',)}else {return ('if (!' .$tc .'->(' .$value .')) {','my $msg = do { local $_ = ' .$value .'; ' .$message .'->(' .$value .');' .'};'.$self->_inline_throw_exception(ValidationFailedForInlineTypeConstraint=>'type_constraint_message => $msg , '.'class_name              => $class_name, '.'attribute_name          => "'.$attr_name.'",'.'value                   => '.$value).';','}',)}}sub _inline_get_old_value_for_trigger {my$self=shift;my ($instance,$old)=@_;return unless$self->has_trigger;return ('my ' .$old .' = ' .$self->_inline_instance_has($instance),'? ' .$self->_inline_instance_get($instance),': ();',)}sub _inline_weaken_value {my$self=shift;my ($instance,$value)=@_;return unless$self->is_weak_ref;my$mi=$self->associated_class->get_meta_instance;return ($mi->inline_weaken_slot_value($instance,$self->name),'if ref ' .$value .';',)}sub _inline_trigger {my$self=shift;my ($instance,$value,$old)=@_;return unless$self->has_trigger;return '$trigger->(' .$instance .', ' .$value .', ' .$old .');'}sub _eval_environment {my$self=shift;my$env={};$env->{'$trigger'}=\($self->trigger)if$self->has_trigger;$env->{'$attr_default'}=\($self->default)if$self->has_default;if ($self->has_type_constraint){my$tc_obj=$self->type_constraint;$env->{'$type_constraint'}=\($tc_obj->_compiled_type_constraint)unless$tc_obj->can_be_inlined;$env->{'$type_coercion'}=\($tc_obj->coercion->_compiled_type_coercion)if$tc_obj->has_coercion;$env->{'$type_message'}=\($tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message);$env={%$env,%{$tc_obj->inline_environment}}}$env->{'$class_name'}=\($self->associated_class->name);$env->{'$attr'}=\$self if$self->has_initializer && $self->is_lazy;$env->{'$meta'}=\($self->associated_class);return$env}sub _weaken_value {my ($self,$instance)=@_;my$meta_instance=Class::MOP::Class->initialize(blessed($instance))->get_meta_instance;$meta_instance->weaken_slot_value($instance,$self->name)}sub get_value {my ($self,$instance,$for_trigger)=@_;if ($self->is_lazy){unless ($self->has_value($instance)){my$value;if ($self->has_default){$value=$self->default($instance)}elsif ($self->has_builder){$value=$self->_call_builder($instance)}$value=$self->_coerce_and_verify($value,$instance);$self->set_initial_value($instance,$value);if (ref$value && $self->is_weak_ref){$self->_weaken_value($instance)}}}if ($self->should_auto_deref &&!$for_trigger){my$type_constraint=$self->type_constraint;if ($type_constraint->is_a_type_of('ArrayRef')){my$rv=$self->SUPER::get_value($instance);return unless defined$rv;return wantarray ? @{$rv}: $rv}elsif ($type_constraint->is_a_type_of('HashRef')){my$rv=$self->SUPER::get_value($instance);return unless defined$rv;return wantarray ? %{$rv}: $rv}else {throw_exception(CannotAutoDereferenceTypeConstraint=>type_name=>$type_constraint->name,instance=>$instance,attribute=>$self)}}else {return$self->SUPER::get_value($instance)}}sub _inline_get_value {my$self=shift;my ($instance,$tc,$coercion,$message)=@_;my$slot_access=$self->_inline_instance_get($instance);$tc ||='$type_constraint';$coercion ||='$type_coercion';$message ||='$type_message';return ($self->_inline_check_lazy($instance,$tc,$coercion,$message),$self->_inline_return_auto_deref($slot_access),)}sub _inline_check_lazy {my$self=shift;my ($instance,$tc,$coercion,$message)=@_;return unless$self->is_lazy;my$slot_exists=$self->_inline_instance_has($instance);return ('if (!' .$slot_exists .') {',$self->_inline_init_from_default($instance,'$default',$tc,$coercion,$message,'lazy'),'}',)}sub _inline_init_from_default {my$self=shift;my ($instance,$default,$tc,$coercion,$message,$for_lazy)=@_;if (!($self->has_default || $self->has_builder)){throw_exception(LazyAttributeNeedsADefault=>attribute=>$self)}return ($self->_inline_generate_default($instance,$default),$self->has_type_constraint ? ($self->_inline_check_coercion($default,$tc,$coercion,$for_lazy),$self->_inline_check_constraint($default,$tc,$message,$for_lazy)): (),$self->_inline_init_slot($instance,$default),$self->_inline_weaken_value($instance,$default),)}sub _inline_generate_default {my$self=shift;my ($instance,$default)=@_;if ($self->has_default){my$source='my ' .$default .' = $attr_default';$source .= '->(' .$instance .')' if$self->is_default_a_coderef;return$source .';'}elsif ($self->has_builder){my$builder=B::perlstring($self->builder);my$builder_str=quotemeta($self->builder);my$attr_name_str=quotemeta($self->name);return ('my ' .$default .';','if (my $builder = ' .$instance .'->can(' .$builder .')) {',$default .' = ' .$instance .'->$builder;','}','else {','my $class = ref(' .$instance .') || ' .$instance .';',$self->_inline_throw_exception(BuilderMethodNotSupportedForInlineAttribute=>'class_name     => $class,'.'attribute_name => "'.$attr_name_str.'",'.'instance       => '.$instance.','.'builder        => "'.$builder_str.'"').';','}',)}else {confess("Can't generate a default for " .$self->name ." since no default or builder was specified")}}sub _inline_init_slot {my$self=shift;my ($inv,$value)=@_;if ($self->has_initializer){return '$attr->set_initial_value(' .$inv .', ' .$value .');'}else {return$self->_inline_instance_set($inv,$value).';'}}sub _inline_return_auto_deref {my$self=shift;return 'return ' .$self->_auto_deref(@_).';'}sub _auto_deref {my$self=shift;my ($ref_value)=@_;return$ref_value unless$self->should_auto_deref;my$type_constraint=$self->type_constraint;my$sigil;if ($type_constraint->is_a_type_of('ArrayRef')){$sigil='@'}elsif ($type_constraint->is_a_type_of('HashRef')){$sigil='%'}else {confess('Can not auto de-reference the type constraint \'' .$type_constraint->name .'\'')}return 'wantarray ' .'? ' .$sigil .'{ (' .$ref_value .') || return } ' .': (' .$ref_value .')'}sub accessor_metaclass {'Moose::Meta::Method::Accessor'}sub install_accessors {my$self=shift;$self->SUPER::install_accessors(@_);$self->install_delegation if$self->has_handles;return}sub _check_associated_methods {my$self=shift;unless (@{$self->associated_methods}|| ($self->_is_metadata || '')eq 'bare'){Carp::cluck('Attribute (' .$self->name .') of class ' .$self->associated_class->name .' has no associated methods' .' (did you mean to provide an "is" argument?)' ."\n")}}sub _process_accessors {my$self=shift;my ($type,$accessor,$generate_as_inline_methods)=@_;$accessor=(keys %$accessor)[0]if (ref($accessor)|| '')eq 'HASH';my$method=$self->associated_class->get_method($accessor);if ($method && $method->isa('Class::MOP::Method::Accessor')&& $method->associated_attribute->name ne $self->name){my$other_attr_name=$method->associated_attribute->name;my$name=$self->name;Carp::cluck("You are overwriting an accessor ($accessor) for the $other_attr_name attribute" ." with a new accessor method for the $name attribute")}if ($method &&!$method->is_stub &&!$method->isa('Class::MOP::Method::Accessor')&& (!$self->definition_context || $method->package_name eq $self->definition_context->{package})){Carp::cluck("You are overwriting a locally defined method ($accessor) with " ."an accessor")}if (!$self->associated_class->has_method($accessor)&& $self->associated_class->has_package_symbol('&' .$accessor)){Carp::cluck("You are overwriting a locally defined function ($accessor) with " ."an accessor")}$self->SUPER::_process_accessors(@_)}sub remove_accessors {my$self=shift;$self->SUPER::remove_accessors(@_);$self->remove_delegation if$self->has_handles;return}sub install_delegation {my$self=shift;my%handles=$self->_canonicalize_handles;my$associated_class=$self->associated_class;my$class_name=$associated_class->name;for my$handle (sort keys%handles){my$method_to_call=$handles{$handle};my$name="${class_name}::${handle}";if (my$method=$associated_class->get_method($handle)){throw_exception(CannotDelegateLocalMethodIsPresent=>attribute=>$self,method=>$method,)unless$method->is_stub}next if$class_name->isa("Moose::Object")and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);my$method=$self->_make_delegation_method($handle,$method_to_call);$self->associated_class->add_method($method->name,$method);$self->associate_method($method)}}sub remove_delegation {my$self=shift;my%handles=$self->_canonicalize_handles;my$associated_class=$self->associated_class;for my$handle (keys%handles){next unless any {$handle eq $_}map {$_->name}@{$self->associated_methods};$self->associated_class->remove_method($handle)}}sub _canonicalize_handles {my$self=shift;my$handles=$self->handles;if (my$handle_type=ref($handles)){if ($handle_type eq 'HASH'){return %{$handles}}elsif ($handle_type eq 'ARRAY'){return map {$_=>$_}@{$handles}}elsif ($handle_type eq 'Regexp'){($self->has_type_constraint)|| throw_exception(CannotDelegateWithoutIsa=>attribute=>$self);return map {($_=>$_)}grep {/$handles/}$self->_get_delegate_method_list}elsif ($handle_type eq 'CODE'){return$handles->($self,$self->_find_delegate_metaclass)}elsif (blessed($handles)&& $handles->isa('Moose::Meta::TypeConstraint::DuckType')){return map {$_=>$_}@{$handles->methods}}elsif (blessed($handles)&& $handles->isa('Moose::Meta::TypeConstraint::Role')){$handles=$handles->role}else {throw_exception(UnableToCanonicalizeHandles=>attribute=>$self,handles=>$handles)}}Moose::Util::_load_user_class($handles);my$role_meta=Class::MOP::class_of($handles);(blessed$role_meta && $role_meta->isa('Moose::Meta::Role'))|| throw_exception(UnableToCanonicalizeNonRolePackage=>attribute=>$self,handles=>$handles);return map {$_=>$_}map {$_->name}grep {!$_->isa('Class::MOP::Method::Meta')}($role_meta->_get_local_methods,$role_meta->get_required_method_list,)}sub _get_delegate_method_list {my$self=shift;my$meta=$self->_find_delegate_metaclass;if ($meta->isa('Class::MOP::Class')){return map {$_->name}grep {$_->package_name ne 'Moose::Object' &&!$_->isa('Class::MOP::Method::Meta')}$meta->get_all_methods}elsif ($meta->isa('Moose::Meta::Role')){return$meta->get_method_list}else {throw_exception(UnableToRecognizeDelegateMetaclass=>attribute=>$self,delegate_metaclass=>$meta)}}sub _find_delegate_metaclass {my$self=shift;my$class=$self->_isa_metadata;my$role=$self->_does_metadata;if ($class){unless ($self->type_constraint->isa("Moose::Meta::TypeConstraint::Class")){throw_exception(DelegationToATypeWhichIsNotAClass=>attribute=>$self)}unless (Moose::Util::_is_package_loaded($class)){throw_exception(DelegationToAClassWhichIsNotLoaded=>attribute=>$self,class_name=>$class)}return Class::MOP::Class->initialize($class)}elsif ($role){unless (Moose::Util::_is_package_loaded($role)){throw_exception(DelegationToARoleWhichIsNotLoaded=>attribute=>$self,role_name=>$role)}return Class::MOP::class_of($role)}else {throw_exception(CannotFindDelegateMetaclass=>attribute=>$self)}}sub delegation_metaclass {'Moose::Meta::Method::Delegation'}sub _make_delegation_method {my ($self,$handle_name,$method_to_call)=@_;my@curried_arguments;($method_to_call,@curried_arguments)=@$method_to_call if 'ARRAY' eq ref($method_to_call);return$self->delegation_metaclass->new(name=>$handle_name,package_name=>$self->associated_class->name,attribute=>$self,delegate_to_method=>$method_to_call,curried_arguments=>\@curried_arguments,)}sub _coerce_and_verify {my$self=shift;my$val=shift;my$instance=shift;return$val unless$self->has_type_constraint;$val=$self->type_constraint->coerce($val)if$self->should_coerce && $self->type_constraint->has_coercion;$self->verify_against_type_constraint($val,instance=>$instance);return$val}sub verify_against_type_constraint {my$self=shift;my$val=shift;return 1 if!$self->has_type_constraint;my$type_constraint=$self->type_constraint;$type_constraint->check($val)|| throw_exception(ValidationFailedForTypeConstraint=>type=>$type_constraint,value=>$val,attribute=>$self,)}package Moose::Meta::Attribute::Custom::Moose;$Moose::Meta::Attribute::Custom::Moose::VERSION='2.1213';sub register_implementation {'Moose::Meta::Attribute'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE';
  use strict;use warnings;package Moose::Meta::Attribute::Native;$Moose::Meta::Attribute::Native::VERSION='2.1213';use Module::Runtime 'require_module';my@trait_names=qw(Bool Counter Number String Array Hash Code);for my$trait_name (@trait_names){my$trait_class="Moose::Meta::Attribute::Native::Trait::$trait_name";my$meta=Class::MOP::Class->initialize("Moose::Meta::Attribute::Custom::Trait::$trait_name");if ($meta->find_method_by_name('register_implementation')){my$class=$meta->name->register_implementation;die "An implementation for $trait_name already exists " ."(found '$class' when trying to register '$trait_class')"}$meta->add_method(register_implementation=>sub {require_module($trait_class);return$trait_class})}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT';
  package Moose::Meta::Attribute::Native::Trait;$Moose::Meta::Attribute::Native::Trait::VERSION='2.1213';use Moose::Role;use Module::Runtime 'require_module';use List::MoreUtils qw(any uniq);use Moose::Deprecated;use Moose::Util;use Moose::Util::TypeConstraints;use Moose::Util 'throw_exception';requires '_helper_type';before '_process_options'=>sub {my ($self,$name,$options)=@_;$self->_check_helper_type($options,$name)};sub _check_helper_type {my ($self,$options,$name)=@_;my$type=$self->_helper_type;$options->{isa}=$type unless exists$options->{isa};my$isa;my$isa_name;if (blessed($options->{isa})&& $options->{isa}->can('does')&& $options->{isa}->does('Specio::Constraint::Role::Interface')){$isa=$options->{isa};require Specio::Library::Builtins;return if$isa->is_a_type_of(Specio::Library::Builtins::t($type));$isa_name=$isa->name()|| $isa->description()}else {$isa=Moose::Util::TypeConstraints::find_or_create_type_constraint($options->{isa});return if$isa->is_a_type_of($type);$isa_name=$isa->name()}throw_exception(WrongTypeConstraintGiven=>required_type=>$type,given_type=>$isa_name,attribute_name=>$name,params=>$options)}before 'install_accessors'=>sub {(shift)->_check_handles_values};sub _check_handles_values {my$self=shift;my%handles=$self->_canonicalize_handles;for my$original_method (values%handles){my$name=$original_method->[0];my$accessor_class=$self->_native_accessor_class_for($name);($accessor_class && $accessor_class->can('new'))|| confess "$name is an unsupported method type - $accessor_class"}}around '_canonicalize_handles'=>sub {shift;my$self=shift;my$handles=$self->handles;return unless$handles;unless ('HASH' eq ref$handles){throw_exception(HandlesMustBeAHashRef=>instance=>$self,given_handles=>$handles)}return map {$_=>$self->_canonicalize_handles_value($handles->{$_})}keys %$handles};sub _canonicalize_handles_value {my$self=shift;my$value=shift;if (ref$value && 'ARRAY' ne ref$value){throw_exception(InvalidHandleValue=>instance=>$self,handle_value=>$value)}return ref$value ? $value : [$value]}around '_make_delegation_method'=>sub {my$next=shift;my ($self,$handle_name,$method_to_call)=@_;my ($name,@curried_args)=@$method_to_call;my$accessor_class=$self->_native_accessor_class_for($name);die "Cannot find an accessor class for $name" unless$accessor_class && $accessor_class->can('new');return$accessor_class->new(name=>$handle_name,package_name=>$self->associated_class->name,delegate_to_method=>$name,attribute=>$self,is_inline=>1,curried_arguments=>\@curried_args,root_types=>[$self->_root_types ],)};sub _root_types {return $_[0]->_helper_type}sub _native_accessor_class_for {my ($self,$suffix)=@_;my$role ='Moose::Meta::Method::Accessor::Native::' .$self->_native_type .'::' .$suffix;require_module($role);return Moose::Meta::Class->create_anon_class(superclasses=>[$self->accessor_metaclass,$self->delegation_metaclass ],roles=>[$role],cache=>1,)->name}sub _build_native_type {my$self=shift;for my$role_name (map {$_->name}$self->meta->calculate_all_roles){return $1 if$role_name =~ /::Native::Trait::(\w+)$/}throw_exception(CannotCalculateNativeType=>instance=>$self)}has '_native_type'=>(is=>'ro',isa=>'Str',lazy=>1,builder=>'_build_native_type',);no Moose::Role;no Moose::Util::TypeConstraints;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY';
  package Moose::Meta::Attribute::Native::Trait::Array;$Moose::Meta::Attribute::Native::Trait::Array::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'ArrayRef'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL';
  package Moose::Meta::Attribute::Native::Trait::Bool;$Moose::Meta::Attribute::Native::Trait::Bool::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'Bool'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE';
  package Moose::Meta::Attribute::Native::Trait::Code;$Moose::Meta::Attribute::Native::Trait::Code::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'CodeRef'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER';
  package Moose::Meta::Attribute::Native::Trait::Counter;$Moose::Meta::Attribute::Native::Trait::Counter::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'Num'}sub _root_types {'Num','Int'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH';
  package Moose::Meta::Attribute::Native::Trait::Hash;$Moose::Meta::Attribute::Native::Trait::Hash::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'HashRef'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER';
  package Moose::Meta::Attribute::Native::Trait::Number;$Moose::Meta::Attribute::Native::Trait::Number::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'Num'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING';
  package Moose::Meta::Attribute::Native::Trait::String;$Moose::Meta::Attribute::Native::Trait::String::VERSION='2.1213';use Moose::Role;with 'Moose::Meta::Attribute::Native::Trait';sub _helper_type {'Str'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS';
  package Moose::Meta::Class;$Moose::Meta::Class::VERSION='2.1213';use strict;use warnings;use Class::MOP;use Carp qw(confess);use Data::OptList;use List::Util qw(first);use List::MoreUtils qw(any all uniq first_index);use Scalar::Util 'blessed';use Moose::Meta::Method::Overridden;use Moose::Meta::Method::Augmented;use Moose::Meta::Class::Immutable::Trait;use Moose::Meta::Method::Constructor;use Moose::Meta::Method::Destructor;use Moose::Meta::Method::Meta;use Moose::Util 'throw_exception';use Class::MOP::MiniTrait;use parent 'Class::MOP::Class';Class::MOP::MiniTrait::apply(__PACKAGE__,'Moose::Meta::Object::Trait');__PACKAGE__->meta->add_attribute('roles'=>(reader=>'roles',default=>sub {[]},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('role_applications'=>(reader=>'_get_role_applications',default=>sub {[]},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute(Class::MOP::Attribute->new('immutable_trait'=>(accessor=>"immutable_trait",default=>'Moose::Meta::Class::Immutable::Trait',Class::MOP::_definition_context(),)));__PACKAGE__->meta->add_attribute('constructor_class'=>(accessor=>'constructor_class',default=>'Moose::Meta::Method::Constructor',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('destructor_class'=>(accessor=>'destructor_class',default=>'Moose::Meta::Method::Destructor',Class::MOP::_definition_context(),));sub initialize {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2;my%opts=@args;my$package=delete$opts{package};return Class::MOP::get_metaclass_by_name($package)|| $class->SUPER::initialize($package,'attribute_metaclass'=>'Moose::Meta::Attribute','method_metaclass'=>'Moose::Meta::Method','instance_metaclass'=>'Moose::Meta::Instance',%opts,)}sub create {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2==1;my%options=@args;(ref$options{roles}eq 'ARRAY')|| throw_exception(RolesInCreateTakesAnArrayRef=>params=>\%options)if exists$options{roles};my$package=delete$options{package};my$roles=delete$options{roles};my$new_meta=$class->SUPER::create($package,%options);if ($roles){Moose::Util::apply_all_roles($new_meta,@$roles)}return$new_meta}sub _meta_method_class {'Moose::Meta::Method::Meta'}sub _anon_package_prefix {'Moose::Meta::Class::__ANON__::SERIAL::'}sub _anon_cache_key {my$class=shift;my%options=@_;my$superclass_key=join('|',map {$_->[0]}@{Data::OptList::mkopt($options{superclasses}|| [])});my$roles=Data::OptList::mkopt(($options{roles}|| []),{moniker=>'role',val_test=>sub {ref($_[0])eq 'HASH'},});my@role_keys;for my$role_spec (@$roles){my ($role,$params)=@$role_spec;$params={%$params }if$params;my$key=blessed($role)? $role->name : $role;if ($params && %$params){my$alias=delete$params->{'-alias'}|| delete$params->{'alias'}|| {};my$excludes=delete$params->{'-excludes'}|| delete$params->{'excludes'}|| [];$excludes=[$excludes]unless ref($excludes)eq 'ARRAY';if (%$params){warn "Roles with parameters cannot be cached. Consider " ."applying the parameters before calling " ."create_anon_class, or using 'weaken => 0' instead";return}my$alias_key=join('%',map {$_=>$alias->{$_}}sort keys %$alias);my$excludes_key=join('%',sort @$excludes);$key .= '<' .join('+','a',$alias_key,'e',$excludes_key).'>'}push@role_keys,$key}my$role_key=join('|',sort@role_keys);return join('=',$superclass_key,$role_key)}sub reinitialize {my$self=shift;my$pkg=shift;my$meta=blessed$pkg ? $pkg : Class::MOP::class_of($pkg);my%existing_classes;if ($meta){%existing_classes=map {$_=>$meta->$_()}qw(attribute_metaclass method_metaclass wrapped_method_metaclass instance_metaclass constructor_class destructor_class)}return$self->SUPER::reinitialize($pkg,%existing_classes,@_,)}sub add_role {my ($self,$role)=@_;(blessed($role)&& $role->isa('Moose::Meta::Role'))|| throw_exception(AddRoleTakesAMooseMetaRoleInstance=>role_to_be_added=>$role,class_name=>$self->name,);push @{$self->roles}=>$role}sub role_applications {my ($self)=@_;return @{$self->_get_role_applications}}sub add_role_application {my ($self,$application)=@_;(blessed($application)&& $application->isa('Moose::Meta::Role::Application::ToClass'))|| throw_exception(InvalidRoleApplication=>class_name=>$self->name,application=>$application,);push @{$self->_get_role_applications}=>$application}sub calculate_all_roles {my$self=shift;my%seen;grep {!$seen{$_->name}++}map {$_->calculate_all_roles}@{$self->roles}}sub _roles_with_inheritance {my$self=shift;my%seen;grep {!$seen{$_->name}++}map {Class::MOP::class_of($_)->can('roles')? @{Class::MOP::class_of($_)->roles}: ()}$self->linearized_isa}sub calculate_all_roles_with_inheritance {my$self=shift;my%seen;grep {!$seen{$_->name}++}map {Class::MOP::class_of($_)->can('calculate_all_roles')? Class::MOP::class_of($_)->calculate_all_roles : ()}$self->linearized_isa}sub does_role {my ($self,$role_name)=@_;(defined$role_name)|| throw_exception(RoleNameRequired=>class_name=>$self->name);for my$class ($self->class_precedence_list){my$meta=Class::MOP::class_of($class);next unless$meta && $meta->can('roles');for my$role (@{$meta->roles}){return 1 if$role->does_role($role_name)}}return 0}sub excludes_role {my ($self,$role_name)=@_;(defined$role_name)|| throw_exception(RoleNameRequired=>class_name=>$self->name);for my$class ($self->class_precedence_list){my$meta=Class::MOP::class_of($class);next unless$meta && $meta->can('roles');for my$role (@{$meta->roles}){return 1 if$role->excludes_role($role_name)}}return 0}sub new_object {my$self=shift;my$params=@_==1 ? $_[0]: {@_};my$object=$self->SUPER::new_object($params);$self->_call_all_triggers($object,$params);$object->BUILDALL($params)if$object->can('BUILDALL');return$object}sub _call_all_triggers {my ($self,$object,$params)=@_;for my$attr ($self->get_all_attributes()){next unless$attr->can('has_trigger')&& $attr->has_trigger;my$init_arg=$attr->init_arg;next unless defined$init_arg;next unless exists$params->{$init_arg};$attr->trigger->($object,($attr->should_coerce ? $attr->get_read_method_ref->($object): $params->{$init_arg}),)}}sub _generate_fallback_constructor {my$self=shift;my ($class)=@_;return$class .'->Moose::Object::new(@_)'}sub _inline_params {my$self=shift;my ($params,$class)=@_;return ('my ' .$params .' = ',$self->_inline_BUILDARGS($class,'@_'),';',)}sub _inline_BUILDARGS {my$self=shift;my ($class,$args)=@_;my$buildargs=$self->find_method_by_name("BUILDARGS");if ($args eq '@_' && (!$buildargs or $buildargs->body==\&Moose::Object::BUILDARGS)){return ('do {','my $params;','if (scalar @_ == 1) {','if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',$self->_inline_throw_exception('SingleParamsToNewMustBeHashRef').';','}','$params = { %{ $_[0] } };','}','elsif (@_ % 2) {','Carp::carp(','"The new() method for ' .$class .' expects a ' .'hash reference or a key/value list. You passed an ' .'odd number of arguments"',');','$params = {@_, undef};','}','else {','$params = {@_};','}','$params;','}',)}else {return$class .'->BUILDARGS(' .$args .')'}}sub _inline_slot_initializer {my$self=shift;my ($attr,$idx)=@_;return ('## ' .$attr->name,$self->_inline_check_required_attr($attr),$self->SUPER::_inline_slot_initializer(@_),)}sub _inline_check_required_attr {my$self=shift;my ($attr)=@_;return unless defined$attr->init_arg;return unless$attr->can('is_required')&& $attr->is_required;return if$attr->has_default || $attr->has_builder;return ('if (!exists $params->{\'' .$attr->init_arg .'\'}) {',$self->_inline_throw_exception(AttributeIsRequired=>'params         => $params, '.'class_name     => $class_name, '.'attribute_name => "'.quotemeta($attr->name).'"').';','}',)}sub _inline_init_attr_from_constructor {my$self=shift;my ($attr,$idx)=@_;my@initial_value=$attr->_inline_set_value('$instance','$params->{\'' .$attr->init_arg .'\'}','$type_constraint_bodies[' .$idx .']','$type_coercions[' .$idx .']','$type_constraint_messages[' .$idx .']','for constructor',);push@initial_value,('$attrs->[' .$idx .']->set_initial_value(','$instance,',$attr->_inline_instance_get('$instance'),');',)if$attr->has_initializer;return@initial_value}sub _inline_init_attr_from_default {my$self=shift;my ($attr,$idx)=@_;return if$attr->can('is_lazy')&& $attr->is_lazy;my$default=$self->_inline_default_value($attr,$idx);return unless$default;my@initial_value=('my $default = ' .$default .';',$attr->_inline_set_value('$instance','$default','$type_constraint_bodies[' .$idx .']','$type_coercions[' .$idx .']','$type_constraint_messages[' .$idx .']','for constructor',),);push@initial_value,('$attrs->[' .$idx .']->set_initial_value(','$instance,',$attr->_inline_instance_get('$instance'),');',)if$attr->has_initializer;return@initial_value}sub _inline_extra_init {my$self=shift;return ($self->_inline_triggers,$self->_inline_BUILDALL,)}sub _inline_triggers {my$self=shift;my@trigger_calls;my@attrs=sort {$a->name cmp $b->name}$self->get_all_attributes;for my$i (0 .. $#attrs){my$attr=$attrs[$i];next unless$attr->can('has_trigger')&& $attr->has_trigger;my$init_arg=$attr->init_arg;next unless defined$init_arg;push@trigger_calls,'if (exists $params->{\'' .$init_arg .'\'}) {','$triggers->[' .$i .']->(','$instance,',$attr->_inline_instance_get('$instance').',',');','}'}return@trigger_calls}sub _inline_BUILDALL {my$self=shift;my@methods=reverse$self->find_all_methods_by_name('BUILD');my@BUILD_calls;for my$method (@methods){push@BUILD_calls,'$instance->' .$method->{class}.'::BUILD($params);'}return@BUILD_calls}sub _eval_environment {my$self=shift;my@attrs=sort {$a->name cmp $b->name}$self->get_all_attributes;my$triggers=[map {$_->can('has_trigger')&& $_->has_trigger ? $_->trigger : undef}@attrs ];my@type_constraints=map {$_->can('type_constraint')? $_->type_constraint : undef}@attrs;my@type_constraint_bodies=map {defined $_ ? $_->_compiled_type_constraint : undef}@type_constraints;my@type_coercions=map {defined $_ && $_->has_coercion ? $_->coercion->_compiled_type_coercion : undef}@type_constraints;my@type_constraint_messages=map {defined $_ ? ($_->has_message ? $_->message : $_->_default_message): undef}@type_constraints;return {%{$self->SUPER::_eval_environment},((any {defined && $_->has_initializer}@attrs)? ('$attrs'=>\[@attrs]): ()),'$triggers'=>\$triggers,'@type_coercions'=>\@type_coercions,'@type_constraint_bodies'=>\@type_constraint_bodies,'@type_constraint_messages'=>\@type_constraint_messages,(map {defined($_)? %{$_->inline_environment}: ()}@type_constraints),'$meta'=>\$self,'$class_name'=>\($self->name),}}sub superclasses {my$self=shift;my$supers=Data::OptList::mkopt(\@_);for my$super (@{$supers}){my ($name,$opts)=@{$super};Moose::Util::_load_user_class($name,$opts);my$meta=Class::MOP::class_of($name);throw_exception(CanExtendOnlyClasses=>role_name=>$meta->name)if$meta && $meta->isa('Moose::Meta::Role')}return$self->SUPER::superclasses(map {$_->[0]}@{$supers})}sub add_attribute {my$self=shift;my$attr=(blessed $_[0]&& $_[0]->isa('Class::MOP::Attribute')? $_[0]: $self->_process_attribute(@_));$self->SUPER::add_attribute($attr);if ($attr->can('_check_associated_methods')){$attr->_check_associated_methods}return$attr}sub add_override_method_modifier {my ($self,$name,$method,$_super_package)=@_;my$existing_method=$self->get_method($name);(!$existing_method)|| throw_exception(CannotOverrideLocalMethodIsPresent=>class_name=>$self->name,method=>$existing_method,);$self->add_method($name=>Moose::Meta::Method::Overridden->new(method=>$method,class=>$self,package=>$_super_package,name=>$name,))}sub add_augment_method_modifier {my ($self,$name,$method)=@_;my$existing_method=$self->get_method($name);throw_exception(CannotAugmentIfLocalMethodPresent=>class_name=>$self->name,method=>$existing_method,)if($existing_method);$self->add_method($name=>Moose::Meta::Method::Augmented->new(method=>$method,class=>$self,name=>$name,))}sub _find_next_method_by_name_which_is_not_overridden {my ($self,$name)=@_;for my$method ($self->find_all_methods_by_name($name)){return$method->{code}if blessed($method->{code})&&!$method->{code}->isa('Moose::Meta::Method::Overridden')}return undef}sub _base_metaclasses {my$self=shift;my%metaclasses=$self->SUPER::_base_metaclasses;for my$class (keys%metaclasses){$metaclasses{$class}=~ s/^Class::MOP/Moose::Meta/}return (%metaclasses,)}sub _fix_class_metaclass_incompatibility {my$self=shift;my ($super_meta)=@_;$self->SUPER::_fix_class_metaclass_incompatibility(@_);if ($self->_class_metaclass_can_be_made_compatible($super_meta)){($self->is_pristine)|| throw_exception(CannotFixMetaclassCompatibility=>class=>$self,superclass=>$super_meta);my$super_meta_name=$super_meta->_real_ref_name;my$class_meta_subclass_meta_name=Moose::Util::_reconcile_roles_for_metaclass(blessed($self),$super_meta_name);my$new_self=$class_meta_subclass_meta_name->reinitialize($self->name,);$self->_replace_self($new_self,$class_meta_subclass_meta_name)}}sub _fix_single_metaclass_incompatibility {my$self=shift;my ($metaclass_type,$super_meta)=@_;$self->SUPER::_fix_single_metaclass_incompatibility(@_);if ($self->_single_metaclass_can_be_made_compatible($super_meta,$metaclass_type)){($self->is_pristine)|| throw_exception(CannotFixMetaclassCompatibility=>class=>$self,superclass=>$super_meta,metaclass_type=>$metaclass_type);my$super_meta_name=$super_meta->_real_ref_name;my$class_specific_meta_subclass_meta_name=Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type,$super_meta->$metaclass_type);my$new_self=$super_meta->reinitialize($self->name,$metaclass_type=>$class_specific_meta_subclass_meta_name,);$self->_replace_self($new_self,$super_meta_name)}}sub _replace_self {my$self=shift;my ($new_self,$new_class)=@_;%$self=%$new_self;bless$self,$new_class;my$weaken=Class::MOP::metaclass_is_weak($self->name);Class::MOP::store_metaclass_by_name($self->name,$self);Class::MOP::weaken_metaclass($self->name)if$weaken}sub _process_attribute {my ($self,$name,@args)=@_;@args=%{$args[0]}if scalar@args==1 && ref($args[0])eq 'HASH';if (($name || '')=~ /^\+(.*)/){return$self->_process_inherited_attribute($1,@args)}else {return$self->_process_new_attribute($name,@args)}}sub _process_new_attribute {my ($self,$name,@args)=@_;$self->attribute_metaclass->interpolate_class_and_new($name,@args)}sub _process_inherited_attribute {my ($self,$attr_name,%options)=@_;my$inherited_attr=$self->find_attribute_by_name($attr_name);(defined$inherited_attr)|| throw_exception(NoAttributeFoundInSuperClass=>class_name=>$self->name,attribute_name=>$attr_name,params=>\%options);if ($inherited_attr->isa('Moose::Meta::Attribute')){return$inherited_attr->clone_and_inherit_options(%options)}else {return$inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options)}}sub _restore_metaobjects_from {my$self=shift;my ($old_meta)=@_;$self->SUPER::_restore_metaobjects_from($old_meta);for my$role (@{$old_meta->roles}){$self->add_role($role)}for my$application (@{$old_meta->_get_role_applications}){$application->class($self);$self->add_role_application ($application)}}sub _immutable_options {my ($self,@args)=@_;$self->SUPER::_immutable_options(inline_destructor=>1,inline_accessors=>0,@args,)}sub _fixup_attributes_after_rebless {my$self=shift;my ($instance,$rebless_from,%params)=@_;$self->SUPER::_fixup_attributes_after_rebless($instance,$rebless_from,%params);$self->_call_all_triggers($instance,\%params)}our$error_level;sub _inline_throw_exception {my ($self,$exception_type,$throw_args)=@_;return 'die Module::Runtime::use_module("Moose::Exception::' .$exception_type .'")->new(' .($throw_args || '').')'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT';
  package Moose::Meta::Class::Immutable::Trait;$Moose::Meta::Class::Immutable::Trait::VERSION='2.1213';use strict;use warnings;use Class::MOP;use Scalar::Util qw(blessed);use parent 'Class::MOP::Class::Immutable::Trait';use Moose::Util 'throw_exception';sub add_role {$_[1]->_immutable_cannot_call}sub calculate_all_roles {my$orig=shift;my$self=shift;@{$self->{__immutable}{calculate_all_roles}||=[$self->$orig ]}}sub calculate_all_roles_with_inheritance {my$orig=shift;my$self=shift;@{$self->{__immutable}{calculate_all_roles_with_inheritance}||=[$self->$orig ]}}sub does_role {shift;my$self=shift;my$role=shift;(defined$role)|| throw_exception(RoleNameRequired=>class_name=>$self->name);$self->{__immutable}{does_role}||={map {$_->name=>1}$self->calculate_all_roles_with_inheritance };my$name=blessed$role ? $role->name : $role;return$self->{__immutable}{does_role}{$name}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_INSTANCE';
  package Moose::Meta::Instance;$Moose::Meta::Instance::VERSION='2.1213';use strict;use warnings;use Class::MOP::MiniTrait;use parent 'Class::MOP::Instance';Class::MOP::MiniTrait::apply(__PACKAGE__,'Moose::Meta::Object::Trait');1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD';
  package Moose::Meta::Method;$Moose::Meta::Method::VERSION='2.1213';use strict;use warnings;use Class::MOP::MiniTrait;use parent 'Class::MOP::Method';Class::MOP::MiniTrait::apply(__PACKAGE__,'Moose::Meta::Object::Trait');1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR';
  package Moose::Meta::Method::Accessor;$Moose::Meta::Method::Accessor::VERSION='2.1213';use strict;use warnings;use Try::Tiny;use parent 'Moose::Meta::Method','Class::MOP::Method::Accessor';use Moose::Util 'throw_exception';sub new {goto&Class::MOP::Method::Accessor::new}sub _new {goto&Class::MOP::Method::Accessor::_new}sub _error_thrower {my$self=shift;return$self->associated_attribute if ref($self)&& defined($self->associated_attribute);return$self->SUPER::_error_thrower}sub _compile_code {my$self=shift;my@args=@_;try {$self->SUPER::_compile_code(@args)}catch {throw_exception(CouldNotCreateWriter=>attribute=>$self->associated_attribute,error=>$_,instance=>$self)}}sub _eval_environment {my$self=shift;return$self->associated_attribute->_eval_environment}sub _instance_is_inlinable {my$self=shift;return$self->associated_attribute->associated_class->instance_metaclass->is_inlinable}sub _generate_reader_method {my$self=shift;$self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_): $self->SUPER::_generate_reader_method(@_)}sub _generate_writer_method {my$self=shift;$self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_): $self->SUPER::_generate_writer_method(@_)}sub _generate_accessor_method {my$self=shift;$self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_): $self->SUPER::_generate_accessor_method(@_)}sub _generate_predicate_method {my$self=shift;$self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_): $self->SUPER::_generate_predicate_method(@_)}sub _generate_clearer_method {my$self=shift;$self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_): $self->SUPER::_generate_clearer_method(@_)}sub _writer_value_needs_copy {shift->associated_attribute->_writer_value_needs_copy(@_)}sub _inline_tc_code {shift->associated_attribute->_inline_tc_code(@_)}sub _inline_check_coercion {shift->associated_attribute->_inline_check_coercion(@_)}sub _inline_check_constraint {shift->associated_attribute->_inline_check_constraint(@_)}sub _inline_check_lazy {shift->associated_attribute->_inline_check_lazy(@_)}sub _inline_store_value {shift->associated_attribute->_inline_instance_set(@_).';'}sub _inline_get_old_value_for_trigger {shift->associated_attribute->_inline_get_old_value_for_trigger(@_)}sub _inline_trigger {shift->associated_attribute->_inline_trigger(@_)}sub _get_value {shift->associated_attribute->_inline_instance_get(@_)}sub _has_value {shift->associated_attribute->_inline_instance_has(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE';
  package Moose::Meta::Method::Accessor::Native;$Moose::Meta::Method::Accessor::Native::VERSION='2.1213';use strict;use warnings;use Carp qw(confess);use Scalar::Util qw(blessed weaken);use Moose::Role;use Moose::Util 'throw_exception';around new=>sub {my$orig=shift;my$class=shift;my%options=@_;$options{curried_arguments}=[]unless exists$options{curried_arguments};throw_exception(MustSupplyArrayRefAsCurriedArguments=>params=>\%options,class_name=>$class)unless$options{curried_arguments}&& ref($options{curried_arguments})eq 'ARRAY';my$attr_context=$options{attribute}->definition_context;my$desc='native delegation method ';$desc .= $options{attribute}->associated_class->name;$desc .= '::' .$options{name};$desc .= " ($options{delegate_to_method})";$desc .= " of attribute " .$options{attribute}->name;$options{definition_context}={%{$attr_context || {}},description=>$desc,};$options{accessor_type}='native';return$class->$orig(%options)};sub _new {my$class=shift;my$options=@_==1 ? $_[0]: {@_};return bless$options,$class}sub root_types {(shift)->{'root_types'}}sub _initialize_body {my$self=shift;$self->{'body'}=$self->_compile_code([$self->_generate_method]);return}sub _inline_curried_arguments {my$self=shift;return unless @{$self->curried_arguments};return 'unshift @_, @curried;'}sub _inline_check_argument_count {my$self=shift;my@code;if (my$min=$self->_minimum_arguments){push@code,('if (@_ < ' .$min .') {',$self->_inline_throw_exception(MethodExpectsMoreArgs=>'method_name           => "'.$self->delegate_to_method.'",'."minimum_args          => ".$min,).';','}',)}if (defined(my$max=$self->_maximum_arguments)){push@code,('if (@_ > ' .$max .') {',$self->_inline_throw_exception(MethodExpectsFewerArgs=>'method_name            => "'.$self->delegate_to_method.'",'.'maximum_args           => '.$max,).';','}',)}return@code}sub _inline_return_value {my$self=shift;my ($slot_access,$for_writer)=@_;return 'return ' .$self->_return_value($slot_access,$for_writer).';'}sub _minimum_arguments {0}sub _maximum_arguments {undef}override _get_value=>sub {my$self=shift;my ($instance)=@_;return$self->_slot_access_can_be_inlined ? super(): $instance .'->$reader'};override _inline_store_value=>sub {my$self=shift;my ($instance,$value)=@_;return$self->_slot_access_can_be_inlined ? super(): $instance .'->$writer(' .$value .');'};override _eval_environment=>sub {my$self=shift;my$env=super();$env->{'@curried'}=$self->curried_arguments;return$env if$self->_slot_access_can_be_inlined;my$reader=$self->associated_attribute->get_read_method_ref;$reader=$reader->body if blessed$reader;$env->{'$reader'}=\$reader;my$writer=$self->associated_attribute->get_write_method_ref;$writer=$writer->body if blessed$writer;$env->{'$writer'}=\$writer;return$env};sub _slot_access_can_be_inlined {my$self=shift;return$self->is_inline && $self->_instance_is_inlinable}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY';
  package Moose::Meta::Method::Accessor::Native::Array;$Moose::Meta::Method::Accessor::Native::Array::VERSION='2.1213';use strict;use warnings;use Moose::Role;use Scalar::Util qw(looks_like_number);sub _inline_check_var_is_valid_index {my$self=shift;my ($var)=@_;return ('if (!defined(' .$var .') || ' .$var .' !~ /^-?\d+$/) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => '.$var.','.'method_name             => "'.$self->delegate_to_method.'",'.'type_of_argument        => "integer",'.'type                    => "Int",'.'argument_noun           => "index"',).';','}',)}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER';
  package Moose::Meta::Method::Accessor::Native::Array::Writer;$Moose::Meta::Method::Accessor::Native::Array::Writer::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer','Moose::Meta::Method::Accessor::Native::Array','Moose::Meta::Method::Accessor::Native::Collection';sub _inline_coerce_new_values {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_)}sub _new_members {'@_'}sub _copy_old_value {my$self=shift;my ($slot_access)=@_;return '[ @{(' .$slot_access .')} ]'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Array::accessor;$Moose::Meta::Method::Accessor::Native::Array::accessor::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::set','Moose::Meta::Method::Accessor::Native::Array::get';sub _inline_process_arguments {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_process_arguments(@_)}sub _inline_check_arguments {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_check_arguments(@_)}sub _return_value {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Array::get::_return_value(@_)}sub _generate_method {my$self=shift;my$inv='$self';my$slot_access=$self->_get_value($inv);return ('sub {','my ' .$inv .' = shift;',$self->_inline_curried_arguments,$self->_inline_check_lazy($inv,'$type_constraint','$type_coercion','$type_message'),'if (@_ == 1) {',$self->_inline_check_var_is_valid_index('$_[0]'),$self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),'}','else {',$self->_inline_writer_core($inv,$slot_access),'}','}',)}sub _minimum_arguments {1}sub _maximum_arguments {2}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Array::clear;$Moose::Meta::Method::Accessor::Native::Array::clear::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _maximum_arguments {0}sub _adds_members {0}sub _potential_value {'[]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = [];'}sub _return_value {''}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT';
  package Moose::Meta::Method::Accessor::Native::Array::count;$Moose::Meta::Method::Accessor::Native::Array::count::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'scalar @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE';
  package Moose::Meta::Method::Accessor::Native::Array::delete;$Moose::Meta::Method::Accessor::Native::Array::delete::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return$self->_inline_check_var_is_valid_index('$_[0]')}sub _adds_members {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my @potential = @{ (' .$slot_access .') }; ' .'@return = splice @potential, $_[0], 1; ' .'\@potential; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@return = splice @{ (' .$slot_access .') }, $_[0], 1;'}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$return[0]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Array::elements;$Moose::Meta::Method::Accessor::Native::Array::elements::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return '@{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST';
  package Moose::Meta::Method::Accessor::Native::Array::first;$Moose::Meta::Method::Accessor::Native::Array::first::VERSION='2.1213';use strict;use warnings;use List::Util ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "first",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return '&List::Util::first($_[0], @{ (' .$slot_access .') })'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first_index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX';
  package Moose::Meta::Method::Accessor::Native::Array::first_index;$Moose::Meta::Method::Accessor::Native::Array::first_index::VERSION='2.1213';use strict;use warnings;use List::MoreUtils ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "first_index",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return '&List::MoreUtils::first_index($_[0], @{ (' .$slot_access .') })'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET';
  package Moose::Meta::Method::Accessor::Native::Array::get;$Moose::Meta::Method::Accessor::Native::Array::get::VERSION='2.1213';use strict;use warnings;use Class::MOP::MiniTrait;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader','Moose::Meta::Method::Accessor::Native::Array';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return$self->_inline_check_var_is_valid_index('$_[0]')}sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .'->[ $_[0] ]'}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP';
  package Moose::Meta::Method::Accessor::Native::Array::grep;$Moose::Meta::Method::Accessor::Native::Array::grep::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "grep",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'grep { $_[0]->() } @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/insert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT';
  package Moose::Meta::Method::Accessor::Native::Array::insert;$Moose::Meta::Method::Accessor::Native::Array::insert::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _minimum_arguments {2}sub _maximum_arguments {2}sub _adds_members {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my @potential = @{ (' .$slot_access .') }; ' .'splice @potential, $_[0], 0, $_[1]; ' .'\@potential; ' .'})'}sub _inline_coerce_new_values {my$self=shift;return unless$self->associated_attribute->should_coerce;return unless$self->_tc_member_type_can_coerce;return '@_ = ($_[0], $member_coercion->($_[1]));'};sub _new_members {'$_[1]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return 'splice @{ (' .$slot_access .') }, $_[0], 0, $_[1];'}sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .'->[ $_[0] ]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Array::is_empty;$Moose::Meta::Method::Accessor::Native::Array::is_empty::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return '@{ (' .$slot_access .') } ? 0 : 1'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/join.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN';
  package Moose::Meta::Method::Accessor::Native::Array::join;$Moose::Meta::Method::Accessor::Native::Array::join::VERSION='2.1213';use strict;use warnings;use Moose::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Moose::Util::_STRINGLIKE0($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "join",'.'type_of_argument        => "string",'.'type                    => "Str",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'join $_[0], @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP';
  package Moose::Meta::Method::Accessor::Native::Array::map;$Moose::Meta::Method::Accessor::Native::Array::map::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "map",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'map { $_[0]->() } @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/natatime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME';
  package Moose::Meta::Method::Accessor::Native::Array::natatime;$Moose::Meta::Method::Accessor::Native::Array::natatime::VERSION='2.1213';use strict;use warnings;use List::MoreUtils ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {2}sub _inline_check_arguments {my$self=shift;return ('if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "natatime",'.'type_of_argument        => "integer",'.'type                    => "Int",'.'argument_noun           => "n value"',).';','}','if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[1],'.'method_name             => "natatime",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",'.'ordinal                 => "second"',).';','}',)}sub _inline_return_value {my$self=shift;my ($slot_access)=@_;return ('my $iter = List::MoreUtils::natatime($_[0], @{ (' .$slot_access .') });','if ($_[1]) {','while (my @vals = $iter->()) {','$_[1]->(@vals);','}','}','else {','return $iter;','}',)}sub _return_value {}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP';
  package Moose::Meta::Method::Accessor::Native::Array::pop;$Moose::Meta::Method::Accessor::Native::Array::pop::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _maximum_arguments {0}sub _adds_members {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '[ @{ (' .$slot_access .') } > 1 ' .'? @{ (' .$slot_access .') }[0..$#{ (' .$slot_access .') } - 1] ' .': () ]'}sub _inline_capture_return_value {my$self=shift;my ($slot_access)=@_;return 'my $old = ' .$slot_access .'->[-1];'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return 'pop @{ (' .$slot_access .') };'}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$old'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/push.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH';
  package Moose::Meta::Method::Accessor::Native::Array::push;$Moose::Meta::Method::Accessor::Native::Array::push::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _adds_members {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '[ @{ (' .$slot_access .') }, @_ ]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return 'push @{ (' .$slot_access .') }, @_;'}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'scalar @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/reduce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE';
  package Moose::Meta::Method::Accessor::Native::Array::reduce;$Moose::Meta::Method::Accessor::Native::Array::reduce::VERSION='2.1213';use strict;use warnings;use List::Util ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "reduce",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET';
  package Moose::Meta::Method::Accessor::Native::Array::set;$Moose::Meta::Method::Accessor::Native::Array::set::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _minimum_arguments {2}sub _maximum_arguments {2}sub _inline_check_arguments {my$self=shift;return$self->_inline_check_var_is_valid_index('$_[0]')}sub _adds_members {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my @potential = @{ (' .$slot_access .') }; ' .'$potential[$_[0]] = $_[1]; ' .'\@potential; ' .'})'}sub _inline_coerce_new_values {my$self=shift;return unless$self->associated_attribute->should_coerce;return unless$self->_tc_member_type_can_coerce;return '@_ = ($_[0], $member_coercion->($_[1]));'};sub _new_members {'$_[1]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .'->[$_[0]] = $_[1];'}sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .'->[$_[0]]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;$Moose::Meta::Method::Accessor::Native::Array::shallow_clone::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {0}sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return '[ @{ (' .$slot_access .') } ]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::shift;$Moose::Meta::Method::Accessor::Native::Array::shift::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _maximum_arguments {0}sub _adds_members {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '[ @{ (' .$slot_access .') } > 1 ' .'? @{ (' .$slot_access .') }[1..$#{ (' .$slot_access .') }] ' .': () ]'}sub _inline_capture_return_value {my$self=shift;my ($slot_access)=@_;return 'my $old = ' .$slot_access .'->[0];'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return 'shift @{ (' .$slot_access .') };'}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$old'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shuffle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE';
  package Moose::Meta::Method::Accessor::Native::Array::shuffle;$Moose::Meta::Method::Accessor::Native::Array::shuffle::VERSION='2.1213';use strict;use warnings;use List::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'List::Util::shuffle @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT';
  package Moose::Meta::Method::Accessor::Native::Array::sort;$Moose::Meta::Method::Accessor::Native::Array::sort::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (@_ && !Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "sort",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$_[0] ' .'? sort { $_[0]->($a, $b) } @{ (' .$slot_access .') } ' .': sort @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort_in_place.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE';
  package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;$Moose::Meta::Method::Accessor::Native::Array::sort_in_place::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (@_ && !Params::Util::_CODELIKE($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "sort_in_place",'.'type_of_argument        => "code reference",'.'type                    => "CodeRef",',).';','}',)}sub _adds_members {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '[ $_[0] ' .'? sort { $_[0]->($a, $b) } @{ (' .$slot_access .') } ' .': sort @{ (' .$slot_access .') } ]'}sub _return_value {''}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/splice.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE';
  package Moose::Meta::Method::Accessor::Native::Array::splice;$Moose::Meta::Method::Accessor::Native::Array::splice::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _minimum_arguments {1}sub _adds_members {1}sub _inline_process_arguments {return ('my $idx = shift;','my $len = @_ ? shift : undef;',)}sub _inline_check_arguments {my$self=shift;return ($self->_inline_check_var_is_valid_index('$idx'),'if (defined($len) && $len !~ /^-?\d+$/) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $len,'.'method_name             => "splice",'.'type_of_argument        => "integer",'.'type                    => "Int",'.'argument_noun           => "length argument"',).';','}',)}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my @potential = @{ (' .$slot_access .') }; ' .'@return = defined $len ' .'? (splice @potential, $idx, $len, @_) ' .': (splice @potential, $idx); ' .'\@potential;' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return ('@return = defined $len','? (splice @{ (' .$slot_access .') }, $idx, $len, @_)',': (splice @{ (' .$slot_access .') }, $idx);',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'wantarray ? @return : $return[-1]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/uniq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ';
  package Moose::Meta::Method::Accessor::Native::Array::uniq;$Moose::Meta::Method::Accessor::Native::Array::uniq::VERSION='2.1213';use strict;use warnings;use List::MoreUtils ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'List::MoreUtils::uniq @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/unshift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::unshift;$Moose::Meta::Method::Accessor::Native::Array::unshift::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Array::Writer';sub _adds_members {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '[ @_, @{ (' .$slot_access .') } ]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return 'unshift @{ (' .$slot_access .') }, @_;'}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'scalar @{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/not.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT';
  package Moose::Meta::Method::Accessor::Native::Bool::not;$Moose::Meta::Method::Accessor::Native::Bool::not::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return '!' .$slot_access}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET';
  package Moose::Meta::Method::Accessor::Native::Bool::set;$Moose::Meta::Method::Accessor::Native::Bool::set::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {1}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = 1;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/toggle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE';
  package Moose::Meta::Method::Accessor::Native::Bool::toggle;$Moose::Meta::Method::Accessor::Native::Bool::toggle::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' ? 0 : 1'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = ' .$slot_access .' ? 0 : 1;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/unset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET';
  package Moose::Meta::Method::Accessor::Native::Bool::unset;$Moose::Meta::Method::Accessor::Native::Bool::unset::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {0}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = 0;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE';
  package Moose::Meta::Method::Accessor::Native::Code::execute;$Moose::Meta::Method::Accessor::Native::Code::execute::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .'->(@_)'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute_method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD';
  package Moose::Meta::Method::Accessor::Native::Code::execute_method;$Moose::Meta::Method::Accessor::Native::Code::execute_method::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .'->($self, @_)'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION';
  package Moose::Meta::Method::Accessor::Native::Collection;$Moose::Meta::Method::Accessor::Native::Collection::VERSION='2.1213';use strict;use warnings;use Moose::Role;requires qw(_adds_members);sub _inline_coerce_new_values {my$self=shift;return unless$self->associated_attribute->should_coerce;return unless$self->_tc_member_type_can_coerce;return ('(' .$self->_new_members .') = map { $member_coercion->($_) }',$self->_new_members .';',)}sub _tc_member_type_can_coerce {my$self=shift;my$member_tc=$self->_tc_member_type;return$member_tc && $member_tc->has_coercion}sub _tc_member_type {my$self=shift;my$tc=$self->associated_attribute->type_constraint;while ($tc){return$tc->type_parameter if$tc->can('type_parameter');$tc=$tc->parent}return}sub _writer_value_needs_copy {my$self=shift;return$self->_constraint_must_be_checked &&!$self->_check_new_members_only}sub _inline_tc_code {my$self=shift;my ($value,$tc,$coercion,$message,$is_lazy)=@_;return unless$self->_constraint_must_be_checked;if ($self->_check_new_members_only){return unless$self->_adds_members;return$self->_inline_check_member_constraint($self->_new_members)}else {return ($self->_inline_check_coercion($value,$tc,$coercion,$is_lazy),$self->_inline_check_constraint($value,$tc,$message,$is_lazy),)}}sub _check_new_members_only {my$self=shift;my$attr=$self->associated_attribute;my$tc=$attr->type_constraint;return 0 if$attr->should_coerce && $tc->has_coercion;return 1 if$self->_is_root_type($tc->parent)&& ($tc->isa('Moose::Meta::TypeConstraint::Parameterized')|| $tc->isa('Specio::Constraint::Parameterized'));return 0}sub _inline_check_member_constraint {my$self=shift;my ($new_value)=@_;my$attr_name=$self->associated_attribute->name;my$check =$self->_tc_member_type->can_be_inlined ? '! (' .$self->_tc_member_type->_inline_check('$new_val').')' : ' !$member_tc->($new_val) ';return ('for my $new_val (' .$new_value .') {',"if ($check) {",'my $msg = do { local $_ = $new_val; $member_message->($new_val) };'.$self->_inline_throw_exception(ValidationFailedForInlineTypeConstraint=>"attribute_name          => '".$attr_name."',".'type_constraint_message => $msg,'.'class_name              => $class_name,'.'value                   => $new_val,'.'new_member              => 1',).';','}','}',)}sub _inline_get_old_value_for_trigger {my$self=shift;my ($instance,$old)=@_;my$attr=$self->associated_attribute;return unless$attr->has_trigger;return ('my ' .$old .' = ' .$self->_has_value($instance),'? ' .$self->_copy_old_value($self->_get_value($instance)),': ();',)}around _eval_environment=>sub {my$orig=shift;my$self=shift;my$env=$self->$orig(@_);my$member_tc=$self->_tc_member_type;return$env unless$member_tc;$env->{'$member_tc'}=\($member_tc->_compiled_type_constraint);$env->{'$member_coercion'}=\($member_tc->coercion->_compiled_type_coercion)if$member_tc->has_coercion;$env->{'$member_message'}=\($member_tc->has_message ? $member_tc->message : $member_tc->_default_message);my$tc_env=$member_tc->inline_environment();$env={%{$env},%{$tc_env}};return$env};no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER';
  package Moose::Meta::Method::Accessor::Native::Counter::Writer;$Moose::Meta::Method::Accessor::Native::Counter::Writer::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _constraint_must_be_checked {my$self=shift;my$attr=$self->associated_attribute;return$attr->has_type_constraint && ($attr->type_constraint->name =~ /^(?:Num|Int)$/ || ($attr->should_coerce && $attr->type_constraint->has_coercion))}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/dec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC';
  package Moose::Meta::Method::Accessor::Native::Counter::dec;$Moose::Meta::Method::Accessor::Native::Counter::dec::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {0}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' - (defined $_[0] ? $_[0] : 1)'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' -= defined $_[0] ? $_[0] : 1;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC';
  package Moose::Meta::Method::Accessor::Native::Counter::inc;$Moose::Meta::Method::Accessor::Native::Counter::inc::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {0}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' + (defined $_[0] ? $_[0] : 1)'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' += defined $_[0] ? $_[0] : 1;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/reset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET';
  package Moose::Meta::Method::Accessor::Native::Counter::reset;$Moose::Meta::Method::Accessor::Native::Counter::reset::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;my$attr=$self->associated_attribute;return '(do { ' .join(' ',$attr->_inline_generate_default('$self','$default_for_reset')).' ' .'$default_for_reset; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = ' .$self->_potential_value .';'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET';
  package Moose::Meta::Method::Accessor::Native::Counter::set;$Moose::Meta::Method::Accessor::Native::Counter::set::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {'$_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH';
  package Moose::Meta::Method::Accessor::Native::Hash;$Moose::Meta::Method::Accessor::Native::Hash::VERSION='2.1213';use strict;use warnings;use Moose::Role;sub _inline_check_var_is_valid_key {my$self=shift;my ($var)=@_;return ('if (!defined(' .$var .')) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => '.$var.','.'method_name             => "'.$self->delegate_to_method.'",'.'type_of_argument        => "defined value",'.'type                    => "Defined",'.'argument_noun           => "key"',).';','}',)}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER';
  package Moose::Meta::Method::Accessor::Native::Hash::Writer;$Moose::Meta::Method::Accessor::Native::Hash::Writer::VERSION='2.1213';use strict;use warnings;use Class::MOP::MiniTrait;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer','Moose::Meta::Method::Accessor::Native::Hash','Moose::Meta::Method::Accessor::Native::Collection';sub _inline_coerce_new_values {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_)}sub _new_values {'@values'}sub _copy_old_value {my$self=shift;my ($slot_access)=@_;return '{ %{ (' .$slot_access .') } }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Hash::accessor;$Moose::Meta::Method::Accessor::Native::Hash::accessor::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Hash::set','Moose::Meta::Method::Accessor::Native::Hash::get';sub _inline_process_arguments {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_process_arguments(@_)}sub _inline_check_argument_count {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_argument_count(@_)}sub _inline_check_arguments {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_arguments(@_)}sub _return_value {my$self=shift;$self->Moose::Meta::Method::Accessor::Native::Hash::set::_return_value(@_)}sub _generate_method {my$self=shift;my$inv='$self';my$slot_access=$self->_get_value($inv);return ('sub {','my ' .$inv .' = shift;',$self->_inline_curried_arguments,$self->_inline_check_lazy($inv,'$type_constraint','$type_coercion','$type_message'),'if (@_ == 1) {',$self->_inline_check_var_is_valid_key('$_[0]'),$slot_access .'->{$_[0]}','}','else {',$self->_inline_writer_core($inv,$slot_access),'}','}',)}sub _minimum_arguments {1}sub _maximum_arguments {2}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Hash::clear;$Moose::Meta::Method::Accessor::Native::Hash::clear::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';sub _maximum_arguments {0}sub _adds_members {0}sub _potential_value {'{}'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = {};'}sub _return_value {''}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT';
  package Moose::Meta::Method::Accessor::Native::Hash::count;$Moose::Meta::Method::Accessor::Native::Hash::count::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'scalar keys %{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/defined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED';
  package Moose::Meta::Method::Accessor::Native::Hash::defined;$Moose::Meta::Method::Accessor::Native::Hash::defined::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader','Moose::Meta::Method::Accessor::Native::Hash';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return$self->_inline_check_var_is_valid_key('$_[0]')}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'defined ' .$slot_access .'->{ $_[0] }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE';
  package Moose::Meta::Method::Accessor::Native::Hash::delete;$Moose::Meta::Method::Accessor::Native::Hash::delete::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';sub _adds_members {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my %potential = %{ (' .$slot_access .') }; ' .'@return = delete @potential{@_}; ' .'\%potential; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@return = delete @{ (' .$slot_access .') }{@_};'}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'wantarray ? @return : $return[-1]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Hash::elements;$Moose::Meta::Method::Accessor::Native::Hash::elements::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'map { $_, ' .$slot_access .'->{$_} } ' .'keys %{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/exists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS';
  package Moose::Meta::Method::Accessor::Native::Hash::exists;$Moose::Meta::Method::Accessor::Native::Hash::exists::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader','Moose::Meta::Method::Accessor::Native::Hash';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return$self->_inline_check_var_is_valid_key('$_[0]')}sub _return_value {my$self=shift;my ($slot_access)=shift;return 'exists ' .$slot_access .'->{ $_[0] }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET';
  package Moose::Meta::Method::Accessor::Native::Hash::get;$Moose::Meta::Method::Accessor::Native::Hash::get::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader','Moose::Meta::Method::Accessor::Native::Hash';sub _minimum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('for (@_) {',$self->_inline_check_var_is_valid_key('$_'),'}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return '@_ > 1 ' .'? @{ (' .$slot_access .') }{@_} ' .': ' .$slot_access .'->{$_[0]}'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Hash::is_empty;$Moose::Meta::Method::Accessor::Native::Hash::is_empty::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'scalar keys %{ (' .$slot_access .') } ? 0 : 1'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS';
  package Moose::Meta::Method::Accessor::Native::Hash::keys;$Moose::Meta::Method::Accessor::Native::Hash::keys::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'keys %{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/kv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV';
  package Moose::Meta::Method::Accessor::Native::Hash::kv;$Moose::Meta::Method::Accessor::Native::Hash::kv::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'map { [ $_, ' .$slot_access .'->{$_} ] } ' .'keys %{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET';
  package Moose::Meta::Method::Accessor::Native::Hash::set;$Moose::Meta::Method::Accessor::Native::Hash::set::VERSION='2.1213';use strict;use warnings;use List::MoreUtils ();use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';sub _minimum_arguments {2}sub _maximum_arguments {undef}around _inline_check_argument_count=>sub {my$orig=shift;my$self=shift;return ($self->$orig(@_),'if (@_ % 2) {',$self->_inline_throw_exception(MustPassEvenNumberOfArguments=>"method_name => '".$self->delegate_to_method."',".'args        => \@_',).';','}',)};sub _inline_process_arguments {my$self=shift;return ('my @keys_idx = grep { ! ($_ % 2) } 0..$#_;','my @values_idx = grep { $_ % 2 } 0..$#_;',)}sub _inline_check_arguments {my$self=shift;return ('for (@keys_idx) {','if (!defined($_[$_])) {',$self->_inline_throw_exception(UndefinedHashKeysPassedToMethod=>'hash_keys                       => \@keys_idx,'."method_name                     => '".$self->delegate_to_method."'",).';','}','}',)}sub _adds_members {1}sub _inline_coerce_new_values {my$self=shift;return unless$self->associated_attribute->should_coerce;return unless$self->_tc_member_type_can_coerce;return ('my $iter = List::MoreUtils::natatime(2, @_);','@_ = ();','while (my ($key, $val) = $iter->()) {','push @_, $key, $member_coercion->($val);','}',)};sub _potential_value {my$self=shift;my ($slot_access)=@_;return '{ %{ (' .$slot_access .') }, @_ }'}sub _new_members {'@_[ @values_idx ]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@{ (' .$slot_access .') }{ @_[@keys_idx] } = @_[@values_idx];'}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'wantarray ' .'? @{ (' .$slot_access .') }{ @_[@keys_idx] } ' .': ' .$slot_access .'->{ $_[$keys_idx[0]] }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;$Moose::Meta::Method::Accessor::Native::Hash::shallow_clone::VERSION='2.1213';use strict;use warnings;use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {0}sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return '{ %{ (' .$slot_access .') } }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES';
  package Moose::Meta::Method::Accessor::Native::Hash::values;$Moose::Meta::Method::Accessor::Native::Hash::values::VERSION='2.1213';use strict;use warnings;use Scalar::Util qw(looks_like_number);use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'values %{ (' .$slot_access .') }'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/abs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS';
  package Moose::Meta::Method::Accessor::Native::Number::abs;$Moose::Meta::Method::Accessor::Native::Number::abs::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return 'abs(' .$slot_access .')'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = abs(' .$slot_access .');'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/add.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD';
  package Moose::Meta::Method::Accessor::Native::Number::add;$Moose::Meta::Method::Accessor::Native::Number::add::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' + $_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' += $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/div.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV';
  package Moose::Meta::Method::Accessor::Native::Number::div;$Moose::Meta::Method::Accessor::Native::Number::div::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' / $_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' /= $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD';
  package Moose::Meta::Method::Accessor::Native::Number::mod;$Moose::Meta::Method::Accessor::Native::Number::mod::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' % $_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' %= $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mul.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL';
  package Moose::Meta::Method::Accessor::Native::Number::mul;$Moose::Meta::Method::Accessor::Native::Number::mul::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' * $_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' *= $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET';
  package Moose::Meta::Method::Accessor::Native::Number::set;$Moose::Meta::Method::Accessor::Native::Number::set::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {'$_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB';
  package Moose::Meta::Method::Accessor::Native::Number::sub;$Moose::Meta::Method::Accessor::Native::Number::sub::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' - $_[0]'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' -= $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER';
  package Moose::Meta::Method::Accessor::Native::Reader;$Moose::Meta::Method::Accessor::Native::Reader::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native';requires '_return_value';sub _generate_method {my$self=shift;my$inv='$self';my$slot_access=$self->_get_value($inv);return ('sub {','my ' .$inv .' = shift;',$self->_inline_curried_arguments,$self->_inline_reader_core($inv,$slot_access,@_),'}',)}sub _inline_reader_core {my$self=shift;my ($inv,$slot_access,@extra)=@_;return ($self->_inline_check_argument_count,$self->_inline_process_arguments($inv,$slot_access),$self->_inline_check_arguments,$self->_inline_check_lazy($inv,'$type_constraint','$type_coercion','$type_message'),$self->_inline_return_value($slot_access),)}sub _inline_process_arguments {return}sub _inline_check_arguments {return}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/append.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND';
  package Moose::Meta::Method::Accessor::Native::String::append;$Moose::Meta::Method::Accessor::Native::String::append::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '( ' .$slot_access .' . $_[0] )'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' .= $_[0];'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/chomp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP';
  package Moose::Meta::Method::Accessor::Native::String::chomp;$Moose::Meta::Method::Accessor::Native::String::chomp::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my $val = ' .$slot_access .'; ' .'@return = chomp $val; ' .'$val ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@return = chomp ' .$slot_access .';'}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$return[0]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/chop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP';
  package Moose::Meta::Method::Accessor::Native::String::chop;$Moose::Meta::Method::Accessor::Native::String::chop::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my $val = ' .$slot_access .'; ' .'@return = chop $val; ' .'$val; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@return = chop ' .$slot_access .';'}sub _return_value {my$self=shift;my ($slot_access)=@_;return '$return[0]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR';
  package Moose::Meta::Method::Accessor::Native::String::clear;$Moose::Meta::Method::Accessor::Native::String::clear::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {'""'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = "";'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC';
  package Moose::Meta::Method::Accessor::Native::String::inc;$Moose::Meta::Method::Accessor::Native::String::inc::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _maximum_arguments {0}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my $val = ' .$slot_access .'; ' .'$val++; ' .'$val; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .'++;'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/length.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH';
  package Moose::Meta::Method::Accessor::Native::String::length;$Moose::Meta::Method::Accessor::Native::String::length::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _maximum_arguments {0}sub _return_value {my$self=shift;my ($slot_access)=@_;return 'length ' .$slot_access}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH';
  package Moose::Meta::Method::Accessor::Native::String::match;$Moose::Meta::Method::Accessor::Native::String::match::VERSION='2.1213';use strict;use warnings;use Moose::Util ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _inline_check_arguments {my$self=shift;return ('if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'type                    => "Str|RegexpRef",'.'type_of_argument        => "string or regexp reference",'.'method_name             => "match"',).';','}',)}sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access .' =~ $_[0]'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/prepend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND';
  package Moose::Meta::Method::Accessor::Native::String::prepend;$Moose::Meta::Method::Accessor::Native::String::prepend::VERSION='2.1213';use strict;use warnings;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {1}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '$_[0] . ' .$slot_access}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return$slot_access .' = $_[0] . ' .$slot_access .';'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/replace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE';
  package Moose::Meta::Method::Accessor::Native::String::replace;$Moose::Meta::Method::Accessor::Native::String::replace::VERSION='2.1213';use strict;use warnings;use Moose::Util ();use Params::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Writer';sub _minimum_arguments {1}sub _maximum_arguments {2}sub _inline_check_arguments {my$self=shift;return ('if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[0],'.'method_name             => "replace",'.'ordinal                 => "first",'.'type_of_argument        => "string or regexp reference",'.'type                    => "Str|RegexpRef"',).';','}','if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $_[1],'.'method_name             => "replace",'.'ordinal                 => "second",'.'type_of_argument        => "string or code reference",'.'type                    => "Str|CodeRef"',).';','}',)}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my $val = ' .$slot_access .'; ' .'ref $_[1] ' .'? $val =~ s/$_[0]/$_[1]->()/e ' .': $val =~ s/$_[0]/$_[1]/; ' .'$val; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return ('ref $_[1]','? ' .$slot_access .' =~ s/$_[0]/$_[1]->()/e',': ' .$slot_access .' =~ s/$_[0]/$_[1]/;',)}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/substr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR';
  package Moose::Meta::Method::Accessor::Native::String::substr;$Moose::Meta::Method::Accessor::Native::String::substr::VERSION='2.1213';use strict;use warnings;use Moose::Util ();use Moose::Role;with 'Moose::Meta::Method::Accessor::Native::Reader','Moose::Meta::Method::Accessor::Native::Writer';sub _generate_method {my$self=shift;my$inv='$self';my$slot_access=$self->_get_value($inv);return ('sub {','my ' .$inv .' = shift;',$self->_inline_curried_arguments,'if (@_ == 1 || @_ == 2) {',$self->_inline_reader_core($inv,$slot_access),'}','elsif (@_ == 3) {',$self->_inline_writer_core($inv,$slot_access),'}','else {',$self->_inline_check_argument_count,'}','}',)}sub _minimum_arguments {1}sub _maximum_arguments {3}sub _inline_process_arguments {my$self=shift;my ($inv,$slot_access)=@_;return ('my $offset = shift;','my $length = @_ ? shift : length ' .$slot_access .';','my $replacement = shift;',)}sub _inline_check_arguments {my$self=shift;my ($for_writer)=@_;my@code=('if ($offset !~ /^-?\d+$/) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $offset,'.'ordinal                 => "first",'.'type_of_argument        => "integer",'.'method_name             => "substr",'.'type                    => "Int"',).';','}','if ($length !~ /^-?\d+$/) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $length,'.'ordinal                 => "second",'.'type_of_argument        => "integer",'.'method_name             => "substr",'.'type                    => "Int"',).';','}',);if ($for_writer){push@code,('if (!Moose::Util::_STRINGLIKE0($replacement)) {',$self->_inline_throw_exception(InvalidArgumentToMethod=>'argument                => $replacement,'.'ordinal                 => "third",'.'type_of_argument        => "string",'.'method_name             => "substr",'.'type                    => "Str"',).';','}',)}return@code}sub _potential_value {my$self=shift;my ($slot_access)=@_;return '(do { ' .'my $potential = ' .$slot_access .'; ' .'@return = substr $potential, $offset, $length, $replacement; ' .'$potential; ' .'})'}sub _inline_optimized_set_new_value {my$self=shift;my ($inv,$new,$slot_access)=@_;return '@return = substr ' .$slot_access .', ' .'$offset, $length, $replacement;'}sub _return_value {my$self=shift;my ($slot_access,$for_writer)=@_;return '$return[0]' if$for_writer;return 'substr ' .$slot_access .', $offset, $length'}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER';
  package Moose::Meta::Method::Accessor::Native::Writer;$Moose::Meta::Method::Accessor::Native::Writer::VERSION='2.1213';use strict;use warnings;use List::MoreUtils qw(any);use Moose::Util;use Moose::Role;with 'Moose::Meta::Method::Accessor::Native';requires '_potential_value';sub _generate_method {my$self=shift;my$inv='$self';my$slot_access=$self->_get_value($inv);return ('sub {','my ' .$inv .' = shift;',$self->_inline_curried_arguments,$self->_inline_writer_core($inv,$slot_access),'}',)}sub _inline_writer_core {my$self=shift;my ($inv,$slot_access)=@_;my$potential=$self->_potential_value($slot_access);my$old='@old';my@code;push@code,($self->_inline_check_argument_count,$self->_inline_process_arguments($inv,$slot_access),$self->_inline_check_arguments('for writer'),$self->_inline_check_lazy($inv,'$type_constraint','$type_coercion','$type_message'),);if ($self->_return_value($slot_access)){push@code,'my @return;'}push@code,($self->_inline_coerce_new_values,$self->_inline_copy_native_value(\$potential),$self->_inline_tc_code($potential,'$type_constraint','$type_coercion','$type_message'),$self->_inline_get_old_value_for_trigger($inv,$old),$self->_inline_capture_return_value($slot_access),$self->_inline_set_new_value($inv,$potential,$slot_access),$self->_inline_trigger($inv,$slot_access,$old),$self->_inline_return_value($slot_access,'for writer'),);return@code}sub _inline_process_arguments {return}sub _inline_check_arguments {return}sub _inline_coerce_new_values {return}sub _writer_value_needs_copy {my$self=shift;return$self->_constraint_must_be_checked}sub _constraint_must_be_checked {my$self=shift;my$attr=$self->associated_attribute;return$attr->has_type_constraint && (!$self->_is_root_type($attr->type_constraint)|| ($attr->should_coerce && $attr->type_constraint->has_coercion))}sub _is_root_type {my$self=shift;my$type=shift;if (blessed($type)&& $type->can('does')&& $type->does('Specio::Constraint::Role::Interface')){require Specio::Library::Builtins;return any {$type->is_same_type_as(Specio::Library::Builtins::t($_))}@{$self->root_types}}else {my$name=$type->name;return any {$name eq $_}@{$self->root_types}}}sub _inline_copy_native_value {my$self=shift;my ($potential_ref)=@_;return unless$self->_writer_value_needs_copy;my$code='my $potential = ' .${$potential_ref}.';';${$potential_ref}='$potential';return$code}around _inline_tc_code=>sub {my$orig=shift;my$self=shift;my ($value,$tc,$coercion,$message,$for_lazy)=@_;return unless$for_lazy || $self->_constraint_must_be_checked;return$self->$orig(@_)};around _inline_check_constraint=>sub {my$orig=shift;my$self=shift;my ($value,$tc,$message,$for_lazy)=@_;return unless$for_lazy || $self->_constraint_must_be_checked;return$self->$orig(@_)};sub _inline_capture_return_value {return}sub _inline_set_new_value {my$self=shift;return$self->_inline_store_value(@_)if$self->_writer_value_needs_copy ||!$self->_slot_access_can_be_inlined ||!$self->_get_is_lvalue;return$self->_inline_optimized_set_new_value(@_)}sub _get_is_lvalue {my$self=shift;return$self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue}sub _inline_optimized_set_new_value {my$self=shift;return$self->_inline_store_value(@_)}sub _return_value {my$self=shift;my ($slot_access)=@_;return$slot_access}no Moose::Role;1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Augmented.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED';
  package Moose::Meta::Method::Augmented;$Moose::Meta::Method::Augmented::VERSION='2.1213';use strict;use warnings;use parent 'Moose::Meta::Method';use Moose::Util 'throw_exception';sub new {my ($class,%args)=@_;my$name=$args{name};my$meta=$args{class};my$super=$meta->find_next_method_by_name($name);(defined$super)|| throw_exception(CannotAugmentNoSuperMethod=>params=>\%args,class=>$class,method_name=>$name);my$_super_package=$super->package_name;if ($super->isa('Moose::Meta::Method::Overridden')){my$real_super=$meta->_find_next_method_by_name_which_is_not_overridden($name);$_super_package=$real_super->package_name}my$super_body=$super->body;my$method=$args{method};my$body=sub {local$Moose::INNER_ARGS{$_super_package}=[@_ ];local$Moose::INNER_BODY{$_super_package}=$method;$super_body->(@_)};$class->wrap($body,package_name=>$meta->name,name=>$name)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR';
  package Moose::Meta::Method::Constructor;$Moose::Meta::Method::Constructor::VERSION='2.1213';use strict;use warnings;use Carp ();use List::MoreUtils 'any';use Scalar::Util 'blessed','weaken','looks_like_number','refaddr';use Try::Tiny;use parent 'Moose::Meta::Method','Class::MOP::Method::Constructor';use Moose::Util 'throw_exception';sub new {my$class=shift;my%options=@_;my$meta=$options{metaclass};(ref$options{options}eq 'HASH')|| throw_exception(MustPassAHashOfOptions=>params=>\%options,class=>$class);($options{package_name}&& $options{name})|| throw_exception(MustSupplyPackageNameAndName=>params=>\%options,class=>$class);my$self=bless {'body'=>undef,'package_name'=>$options{package_name},'name'=>$options{name},'options'=>$options{options},'associated_metaclass'=>$meta,'definition_context'=>$options{definition_context},'_expected_method_class'=>$options{_expected_method_class}|| 'Moose::Object',}=>$class;weaken($self->{'associated_metaclass'});$self->_initialize_body;return$self}sub _initialize_body {my$self=shift;$self->{'body'}=$self->_generate_constructor_method_inline}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Delegation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION';
  package Moose::Meta::Method::Delegation;$Moose::Meta::Method::Delegation::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed','weaken';use parent 'Moose::Meta::Method','Class::MOP::Method::Generated';use Moose::Util 'throw_exception';sub new {my$class=shift;my%options=@_;(exists$options{attribute})|| throw_exception(MustSupplyAnAttributeToConstructWith=>params=>\%options,class=>$class);(blessed($options{attribute})&& $options{attribute}->isa('Moose::Meta::Attribute'))|| throw_exception(MustSupplyAMooseMetaAttributeInstance=>params=>\%options,class=>$class);($options{package_name}&& $options{name})|| throw_exception(MustSupplyPackageNameAndName=>params=>\%options,class=>$class);($options{delegate_to_method}&& (!ref$options{delegate_to_method})|| ('CODE' eq ref$options{delegate_to_method}))|| throw_exception(MustSupplyADelegateToMethod=>params=>\%options,class=>$class);exists$options{curried_arguments}|| ($options{curried_arguments}=[]);($options{curried_arguments}&& ('ARRAY' eq ref$options{curried_arguments}))|| throw_exception(MustSupplyArrayRefAsCurriedArguments=>params=>\%options,class_name=>$class);my$self=$class->_new(\%options);weaken($self->{'attribute'});$self->_initialize_body;return$self}sub _new {my$class=shift;my$options=@_==1 ? $_[0]: {@_};return bless$options,$class}sub curried_arguments {(shift)->{'curried_arguments'}}sub associated_attribute {(shift)->{'attribute'}}sub delegate_to_method {(shift)->{'delegate_to_method'}}sub _initialize_body {my$self=shift;my$method_to_call=$self->delegate_to_method;return$self->{body}=$method_to_call if ref$method_to_call;my$accessor=$self->_get_delegate_accessor;my$handle_name=$self->name;$self->{body}=sub {my$instance=shift;my$proxy=$instance->$accessor();if(!defined$proxy){throw_exception(AttributeValueIsNotDefined=>method=>$self,instance=>$instance,attribute=>$self->associated_attribute,)}elsif(ref($proxy)&&!blessed($proxy)){throw_exception(AttributeValueIsNotAnObject=>method=>$self,instance=>$instance,attribute=>$self->associated_attribute,given_value=>$proxy)}unshift @_,@{$self->curried_arguments};$proxy->$method_to_call(@_)}}sub _get_delegate_accessor {my$self=shift;my$attr=$self->associated_attribute;my$accessor=$attr->has_read_method ? $attr->get_read_method : $attr->get_read_method_ref;$accessor=$accessor->body if Scalar::Util::blessed$accessor;return$accessor}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Destructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR';
  package Moose::Meta::Method::Destructor;$Moose::Meta::Method::Destructor::VERSION='2.1213';use strict;use warnings;use Devel::GlobalDestruction ();use Scalar::Util 'blessed','weaken';use Try::Tiny;use parent 'Moose::Meta::Method','Class::MOP::Method::Inlined';use Moose::Util 'throw_exception';sub new {my$class=shift;my%options=@_;(ref$options{options}eq 'HASH')|| throw_exception(MustPassAHashOfOptions=>params=>\%options,class=>$class);($options{package_name}&& $options{name})|| throw_exception(MustSupplyPackageNameAndName=>params=>\%options,class=>$class);my$self=bless {'body'=>undef,'package_name'=>$options{package_name},'name'=>$options{name},'options'=>$options{options},'definition_context'=>$options{definition_context},'associated_metaclass'=>$options{metaclass},}=>$class;weaken($self->{'associated_metaclass'});$self->_initialize_body;return$self}sub options {(shift)->{'options'}}sub is_needed {my$self=shift;my$metaclass=shift;(blessed$metaclass && $metaclass->isa('Class::MOP::Class'))|| throw_exception(MethodExpectedAMetaclassObject=>metaclass=>$metaclass,class=>$self);return$metaclass->find_method_by_name("DEMOLISHALL")}sub _initialize_body {my$self=shift;my$class=$self->associated_metaclass->name;my@source=('sub {','my $self = shift;','return ' .$self->_generate_fallback_destructor('$self'),'if Scalar::Util::blessed($self) ne \'' .$class .'\';',$self->_generate_DEMOLISHALL('$self'),'return;','}',);warn join("\n",@source)if$self->options->{debug};my$code=try {$self->_compile_code(source=>\@source)}catch {my$source=join("\n",@source);throw_exception(CouldNotEvalDestructor=>method_destructor_object=>$self,source=>$source,error=>$_)};$self->{'body'}=$code}sub _generate_fallback_destructor {my$self=shift;my ($inv)=@_;return$inv .'->Moose::Object::DESTROY(@_)'}sub _generate_DEMOLISHALL {my$self=shift;my ($inv)=@_;my@methods=$self->associated_metaclass->find_all_methods_by_name('DEMOLISH');return unless@methods;return ('local $?;','my $igd = Devel::GlobalDestruction::in_global_destruction;','Try::Tiny::try {',(map {$inv .'->' .$_->{class}.'::DEMOLISH($igd);'}@methods),'}','Try::Tiny::catch {','die $_;','};',)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_META';
  package Moose::Meta::Method::Meta;$Moose::Meta::Method::Meta::VERSION='2.1213';use strict;use warnings;use parent 'Moose::Meta::Method','Class::MOP::Method::Meta';sub _is_caller_mop_internal {my$self=shift;my ($caller)=@_;return 1 if$caller =~ /^Moose(?:::|$)/;return$self->SUPER::_is_caller_mop_internal($caller)}sub wrap {my$class=shift;return$class->Class::MOP::Method::Meta::wrap(@_)}sub _make_compatible_with {my$self=shift;return$self->Class::MOP::Method::Meta::_make_compatible_with(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_META

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Overridden.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN';
  package Moose::Meta::Method::Overridden;$Moose::Meta::Method::Overridden::VERSION='2.1213';use strict;use warnings;use parent 'Moose::Meta::Method';use Moose::Util 'throw_exception';sub new {my ($class,%args)=@_;my$super_package=$args{package}|| $args{class}->name;my$name=$args{name};my$super=$args{class}->find_next_method_by_name($name);(defined$super)|| throw_exception(CannotOverrideNoSuperMethod=>class=>$class,params=>\%args,method_name=>$name);my$super_body=$super->body;my$method=$args{method};my$body=sub {local$Moose::SUPER_PACKAGE=$super_package;local@Moose::SUPER_ARGS=@_;local$Moose::SUPER_BODY=$super_body;return$method->(@_)};$class->wrap($body,package_name=>$args{class}->name,name=>$name)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE';
  package Moose::Meta::Mixin::AttributeCore;$Moose::Meta::Mixin::AttributeCore::VERSION='2.1213';use strict;use warnings;use parent 'Class::MOP::Mixin::AttributeCore';__PACKAGE__->meta->add_attribute('isa'=>(reader=>'_isa_metadata',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('does'=>(reader=>'_does_metadata',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('is'=>(reader=>'_is_metadata',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('required'=>(reader=>'is_required',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('lazy'=>(reader=>'is_lazy',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('lazy_build'=>(reader=>'is_lazy_build',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('coerce'=>(reader=>'should_coerce',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('weak_ref'=>(reader=>'is_weak_ref',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('auto_deref'=>(reader=>'should_auto_deref',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('type_constraint'=>(reader=>'type_constraint',predicate=>'has_type_constraint',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('trigger'=>(reader=>'trigger',predicate=>'has_trigger',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('handles'=>(reader=>'handles',writer=>'_set_handles',predicate=>'has_handles',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('documentation'=>(reader=>'documentation',predicate=>'has_documentation',Class::MOP::_definition_context(),));1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Object/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT';
  package Moose::Meta::Object::Trait;$Moose::Meta::Object::Trait::VERSION='2.1213';use Scalar::Util qw(blessed);sub _get_compatible_metaclass {my$orig=shift;my$self=shift;return$self->$orig(@_)|| $self->_get_compatible_metaclass_by_role_reconciliation(@_)}sub _get_compatible_metaclass_by_role_reconciliation {my$self=shift;my ($other_name)=@_;my$meta_name=blessed($self)? $self->_real_ref_name : $self;return unless Moose::Util::_classes_differ_by_roles_only($meta_name,$other_name);return Moose::Util::_reconcile_roles_for_metaclass($meta_name,$other_name)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE';
  package Moose::Meta::Role;$Moose::Meta::Role::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use Devel::GlobalDestruction 'in_global_destruction';use Moose::Meta::Class;use Moose::Meta::Role::Attribute;use Moose::Meta::Role::Method;use Moose::Meta::Role::Method::Required;use Moose::Meta::Role::Method::Conflicting;use Moose::Meta::Method::Meta;use Moose::Util qw/throw_exception/;use Class::MOP::MiniTrait;use parent 'Class::MOP::Module','Class::MOP::Mixin::HasAttributes','Class::MOP::Mixin::HasMethods';Class::MOP::MiniTrait::apply(__PACKAGE__,'Moose::Meta::Object::Trait');my$META=__PACKAGE__->meta;for my$action ({name=>'excluded_roles_map',attr_reader=>'get_excluded_roles_map',methods=>{add=>'add_excluded_roles',get_keys=>'get_excluded_roles_list',existence=>'excludes_role',}},{name=>'required_methods',attr_reader=>'get_required_methods_map',methods=>{remove=>'remove_required_methods',get_values=>'get_required_method_list',existence=>'requires_method',}},){my$attr_reader=$action->{attr_reader};my$methods=$action->{methods};$META->add_attribute($action->{name}=>(reader=>$attr_reader,default=>sub {{}},Class::MOP::_definition_context(),));$META->add_method($methods->{add}=>sub {my ($self,@values)=@_;$self->$attr_reader->{$_}=undef foreach@values})if exists$methods->{add};$META->add_method($methods->{get_keys}=>sub {my ($self)=@_;keys %{$self->$attr_reader}})if exists$methods->{get_keys};$META->add_method($methods->{get_values}=>sub {my ($self)=@_;values %{$self->$attr_reader}})if exists$methods->{get_values};$META->add_method($methods->{get}=>sub {my ($self,$name)=@_;$self->$attr_reader->{$name}})if exists$methods->{get};$META->add_method($methods->{existence}=>sub {my ($self,$name)=@_;exists$self->$attr_reader->{$name}? 1 : 0})if exists$methods->{existence};$META->add_method($methods->{remove}=>sub {my ($self,@values)=@_;delete$self->$attr_reader->{$_}foreach@values})if exists$methods->{remove}}$META->add_attribute('method_metaclass',reader=>'method_metaclass',default=>'Moose::Meta::Role::Method',Class::MOP::_definition_context(),);$META->add_attribute('required_method_metaclass',reader=>'required_method_metaclass',default=>'Moose::Meta::Role::Method::Required',Class::MOP::_definition_context(),);$META->add_attribute('conflicting_method_metaclass',reader=>'conflicting_method_metaclass',default=>'Moose::Meta::Role::Method::Conflicting',Class::MOP::_definition_context(),);$META->add_attribute('application_to_class_class',reader=>'application_to_class_class',default=>'Moose::Meta::Role::Application::ToClass',Class::MOP::_definition_context(),);$META->add_attribute('application_to_role_class',reader=>'application_to_role_class',default=>'Moose::Meta::Role::Application::ToRole',Class::MOP::_definition_context(),);$META->add_attribute('application_to_instance_class',reader=>'application_to_instance_class',default=>'Moose::Meta::Role::Application::ToInstance',Class::MOP::_definition_context(),);$META->add_attribute('applied_attribute_metaclass',reader=>'applied_attribute_metaclass',default=>'Moose::Meta::Attribute',Class::MOP::_definition_context(),);sub initialize {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2;my%opts=@args;my$package=delete$opts{package};return Class::MOP::get_metaclass_by_name($package)|| $class->SUPER::initialize($package,'attribute_metaclass'=>'Moose::Meta::Role::Attribute',%opts,)}sub reinitialize {my$self=shift;my$pkg=shift;my$meta=blessed$pkg ? $pkg : Class::MOP::class_of($pkg);my%existing_classes;if ($meta){%existing_classes=map {$_=>$meta->$_()}qw(attribute_metaclass method_metaclass wrapped_method_metaclass required_method_metaclass conflicting_method_metaclass application_to_class_class application_to_role_class application_to_instance_class applied_attribute_metaclass)}my%options=@_;$options{weaken}=Class::MOP::metaclass_is_weak($meta->name)if!exists$options{weaken}&& blessed($meta)&& $meta->isa('Moose::Meta::Role');my$new_meta=$self->SUPER::reinitialize($pkg,%existing_classes,%options,);$new_meta->_restore_metaobjects_from($meta)if$meta && $meta->isa('Moose::Meta::Role');return$new_meta}sub _restore_metaobjects_from {my$self=shift;my ($old_meta)=@_;$self->_restore_metamethods_from($old_meta);$self->_restore_metaattributes_from($old_meta);for my$role (@{$old_meta->get_roles}){$self->add_role($role)}}sub add_attribute {my$self=shift;if (blessed $_[0]&&!$_[0]->isa('Moose::Meta::Role::Attribute')){my$class=ref $_[0];throw_exception(CannotAddAsAnAttributeToARole=>role_name=>$self->name,attribute_class=>$class,)}elsif (!blessed($_[0])&& defined($_[0])&& $_[0]=~ /^\+(.*)/){throw_exception(AttributeExtensionIsNotSupportedInRoles=>attribute_name=>$_[0],role_name=>$self->name,)}return$self->SUPER::add_attribute(@_)}sub _attach_attribute {my ($self,$attribute)=@_;$attribute->attach_to_role($self)}sub add_required_methods {my$self=shift;for (@_){my$method=$_;if (!blessed($method)){$method=$self->required_method_metaclass->new(name=>$method,)}$self->get_required_methods_map->{$method->name}=$method}}sub add_conflicting_method {my$self=shift;my$method;if (@_==1 && blessed($_[0])){$method=shift}else {$method=$self->conflicting_method_metaclass->new(@_)}$self->add_required_methods($method)}for my$modifier_type (qw[before around after]){my$attr_reader="get_${modifier_type}_method_modifiers_map";$META->add_attribute("${modifier_type}_method_modifiers"=>(reader=>$attr_reader,default=>sub {{}},Class::MOP::_definition_context(),));$META->add_method("get_${modifier_type}_method_modifiers"=>sub {my ($self,$method_name)=@_;my$mm=$self->$attr_reader->{$method_name};$mm ? @$mm : ()});$META->add_method("has_${modifier_type}_method_modifiers"=>sub {my ($self,$method_name)=@_;(exists$self->$attr_reader->{$method_name})? 1 : 0});$META->add_method("add_${modifier_type}_method_modifier"=>sub {my ($self,$method_name,$method)=@_;$self->$attr_reader->{$method_name}=[]unless exists$self->$attr_reader->{$method_name};my$modifiers=$self->$attr_reader->{$method_name};for my$modifier (@{$modifiers}){return if$modifier==$method}push @{$modifiers}=>$method})}$META->add_attribute('override_method_modifiers'=>(reader=>'get_override_method_modifiers_map',default=>sub {{}},Class::MOP::_definition_context(),));sub add_override_method_modifier {my ($self,$method_name,$method)=@_;(!$self->has_method($method_name))|| throw_exception(CannotOverrideALocalMethod=>method_name=>$method_name,role_name=>$self->name,);$self->get_override_method_modifiers_map->{$method_name}=$method}sub has_override_method_modifier {my ($self,$method_name)=@_;(exists$self->get_override_method_modifiers_map->{$method_name})? 1 : 0}sub get_override_method_modifier {my ($self,$method_name)=@_;$self->get_override_method_modifiers_map->{$method_name}}sub get_method_modifier_list {my ($self,$modifier_type)=@_;my$accessor="get_${modifier_type}_method_modifiers_map";keys %{$self->$accessor}}sub _meta_method_class {'Moose::Meta::Method::Meta'}$META->add_attribute('roles'=>(reader=>'get_roles',default=>sub {[]},Class::MOP::_definition_context(),));sub add_role {my ($self,$role)=@_;(blessed($role)&& $role->isa('Moose::Meta::Role'))|| throw_exception(AddRoleToARoleTakesAMooseMetaRole=>role_to_be_added=>$role,role_name=>$self->name,);push @{$self->get_roles}=>$role;$self->reset_package_cache_flag}sub calculate_all_roles {my$self=shift;my%seen;grep {!$seen{$_->name}++}($self,map {$_->calculate_all_roles}@{$self->get_roles})}sub does_role {my ($self,$role)=@_;(defined$role)|| throw_exception(RoleNameRequiredForMooseMetaRole=>role_name=>$self->name);my$role_name=blessed$role ? $role->name : $role;return 1 if$role_name eq $self->name;for my$role (@{$self->get_roles}){return 1 if$role->does_role($role_name)}return 0}sub find_method_by_name {(shift)->get_method(@_)}sub apply {my ($self,$other,%args)=@_;(blessed($other))|| throw_exception(ApplyTakesABlessedInstance=>param=>$other,role_name=>$self->name,);my$application_class;if ($other->isa('Moose::Meta::Role')){$application_class=$self->application_to_role_class}elsif ($other->isa('Moose::Meta::Class')){$application_class=$self->application_to_class_class}else {$application_class=$self->application_to_instance_class}Moose::Util::_load_user_class($application_class);if (exists$args{'-excludes'}){$args{'-excludes'}=(ref$args{'-excludes'}eq 'ARRAY' ? $args{'-excludes'}: [$args{'-excludes'}])}return$application_class->new(%args)->apply($self,$other,\%args)}sub composition_class_roles {}sub combine {my ($class,@role_specs)=@_;require Moose::Meta::Role::Composite;my (@roles,%role_params);while (@role_specs){my ($role,$params)=@{splice@role_specs,0,1};my$requested_role =blessed$role ? $role : Class::MOP::class_of($role);my$actual_role=$requested_role->_role_for_combination($params);push@roles=>$actual_role;next unless defined$params;$role_params{$actual_role->name}=$params}my$c=Moose::Meta::Role::Composite->new(roles=>\@roles);return$c->apply_params(\%role_params)}sub _role_for_combination {my ($self,$params)=@_;return$self}sub create {my$class=shift;my@args=@_;unshift@args,'package' if@args % 2==1;my%options=@args;(ref$options{attributes}eq 'HASH')|| throw_exception(CreateTakesHashRefOfAttributes=>params=>\%options,attribute_class=>$class)if exists$options{attributes};(ref$options{methods}eq 'HASH')|| throw_exception(CreateTakesHashRefOfMethods=>params=>\%options,attribute_class=>$class)if exists$options{methods};(ref$options{roles}eq 'ARRAY')|| throw_exception(CreateTakesArrayRefOfRoles=>params=>\%options,attribute_class=>$class)if exists$options{roles};my$package=delete$options{package};my$roles=delete$options{roles};my$attributes=delete$options{attributes};my$methods=delete$options{methods};my$meta_name=exists$options{meta_name}? delete$options{meta_name}: 'meta';my$meta=$class->SUPER::create($package=>%options);$meta->_add_meta_method($meta_name)if defined$meta_name;if (defined$attributes){for my$attribute_name (keys %{$attributes}){my$attr=$attributes->{$attribute_name};$meta->add_attribute($attribute_name=>blessed$attr ? $attr : %{$attr})}}if (defined$methods){for my$method_name (keys %{$methods}){$meta->add_method($method_name,$methods->{$method_name})}}if ($roles){Moose::Util::apply_all_roles($meta,@$roles)}return$meta}sub consumers {my$self=shift;my@consumers;for my$meta (Class::MOP::get_all_metaclass_instances){next if$meta->name eq $self->name;next unless$meta->isa('Moose::Meta::Class')|| $meta->isa('Moose::Meta::Role');push@consumers,$meta->name if$meta->does_role($self->name)}return@consumers}sub _anon_package_prefix {'Moose::Meta::Role::__ANON__::SERIAL::'}sub create_anon_role {shift->create_anon(@_)}sub is_anon_role {shift->is_anon(@_)}sub _anon_cache_key {my$class=shift;my%options=@_;my$roles=Data::OptList::mkopt(($options{roles}|| []),{moniker=>'role',val_test=>sub {ref($_[0])eq 'HASH'},});my@role_keys;for my$role_spec (@$roles){my ($role,$params)=@$role_spec;$params={%$params };my$key=blessed($role)? $role->name : $role;if ($params && %$params){my$alias=delete$params->{'-alias'}|| delete$params->{'alias'}|| {};my$excludes=delete$params->{'-excludes'}|| delete$params->{'excludes'}|| [];$excludes=[$excludes]unless ref($excludes)eq 'ARRAY';if (%$params){warn "Roles with parameters cannot be cached. Consider " ."applying the parameters before calling " ."create_anon_class, or using 'weaken => 0' instead";return}my$alias_key=join('%',map {$_=>$alias->{$_}}sort keys %$alias);my$excludes_key=join('%',sort @$excludes);$key .= '<' .join('+','a',$alias_key,'e',$excludes_key).'>'}push@role_keys,$key}return join('|',sort@role_keys)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION';
  package Moose::Meta::Role::Application;$Moose::Meta::Role::Application::VERSION='2.1213';use strict;use warnings;use metaclass;use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('method_exclusions'=>(init_arg=>'-excludes',reader=>'get_method_exclusions',default=>sub {[]},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('method_aliases'=>(init_arg=>'-alias',reader=>'get_method_aliases',default=>sub {{}},Class::MOP::_definition_context(),));sub new {my ($class,%params)=@_;$class->_new(\%params)}sub is_method_excluded {my ($self,$method_name)=@_;for (@{$self->get_method_exclusions}){return 1 if $_ eq $method_name}return 0}sub is_method_aliased {my ($self,$method_name)=@_;exists$self->get_method_aliases->{$method_name}? 1 : 0}sub is_aliased_method {my ($self,$method_name)=@_;my%aliased_names=reverse %{$self->get_method_aliases};exists$aliased_names{$method_name}? 1 : 0}sub apply {my$self=shift;$self->check_role_exclusions(@_);$self->check_required_methods(@_);$self->check_required_attributes(@_);$self->apply_attributes(@_);$self->apply_methods(@_);$self->apply_override_method_modifiers(@_);$self->apply_before_method_modifiers(@_);$self->apply_around_method_modifiers(@_);$self->apply_after_method_modifiers(@_)}sub check_role_exclusions {throw_exception("CannotCallAnAbstractMethod")}sub check_required_methods {throw_exception("CannotCallAnAbstractMethod")}sub check_required_attributes {throw_exception("CannotCallAnAbstractMethod")}sub apply_attributes {throw_exception("CannotCallAnAbstractMethod")}sub apply_methods {throw_exception("CannotCallAnAbstractMethod")}sub apply_override_method_modifiers {throw_exception("CannotCallAnAbstractMethod")}sub apply_method_modifiers {throw_exception("CannotCallAnAbstractMethod")}sub apply_before_method_modifiers {(shift)->apply_method_modifiers('before'=>@_)}sub apply_around_method_modifiers {(shift)->apply_method_modifiers('around'=>@_)}sub apply_after_method_modifiers {(shift)->apply_method_modifiers('after'=>@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/RoleSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION';
  package Moose::Meta::Role::Application::RoleSummation;$Moose::Meta::Role::Application::RoleSummation::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use Moose::Meta::Role::Composite;use parent 'Moose::Meta::Role::Application';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('role_params'=>(reader=>'role_params',default=>sub {{}},Class::MOP::_definition_context(),));sub get_exclusions_for_role {my ($self,$role)=@_;$role=$role->name if blessed$role;my$excludes_key=exists$self->role_params->{$role}->{'-excludes'}? '-excludes' : 'excludes';if ($self->role_params->{$role}&& defined$self->role_params->{$role}->{$excludes_key}){if (ref$self->role_params->{$role}->{$excludes_key}eq 'ARRAY'){return$self->role_params->{$role}->{$excludes_key}}return [$self->role_params->{$role}->{$excludes_key}]}return []}sub get_method_aliases_for_role {my ($self,$role)=@_;$role=$role->name if blessed$role;my$alias_key=exists$self->role_params->{$role}->{'-alias'}? '-alias' : 'alias';if ($self->role_params->{$role}&& defined$self->role_params->{$role}->{$alias_key}){return$self->role_params->{$role}->{$alias_key}}return {}}sub is_method_excluded {my ($self,$role,$method_name)=@_;for ($self->get_exclusions_for_role($role->name)){return 1 if $_ eq $method_name}return 0}sub is_method_aliased {my ($self,$role,$method_name)=@_;exists$self->get_method_aliases_for_role($role->name)->{$method_name}? 1 : 0}sub is_aliased_method {my ($self,$role,$method_name)=@_;my%aliased_names=reverse %{$self->get_method_aliases_for_role($role->name)};exists$aliased_names{$method_name}? 1 : 0}sub check_role_exclusions {my ($self,$c)=@_;my%excluded_roles;for my$role (@{$c->get_roles}){my$name=$role->name;for my$excluded ($role->get_excluded_roles_list){push @{$excluded_roles{$excluded}},$name}}for my$role (@{$c->get_roles}){for my$excluded (keys%excluded_roles){next unless$role->does_role($excluded);my@excluding=@{$excluded_roles{$excluded}};throw_exception(RoleExclusionConflict=>roles=>\@excluding,role_name=>$excluded)}}$c->add_excluded_roles(keys%excluded_roles)}sub check_required_methods {my ($self,$c)=@_;my%all_required_methods=map {$_->name=>$_}map {$_->get_required_method_list}@{$c->get_roles};for my$role (@{$c->get_roles}){for my$required (keys%all_required_methods){delete$all_required_methods{$required}if$role->has_method($required)|| $self->is_aliased_method($role,$required)}}$c->add_required_methods(values%all_required_methods)}sub check_required_attributes {}sub apply_attributes {my ($self,$c)=@_;my@all_attributes;for my$role (@{$c->get_roles}){push@all_attributes,map {$role->get_attribute($_)}$role->get_attribute_list}my%seen;for my$attr (@all_attributes){my$name=$attr->name;if (exists$seen{$name}){next if$seen{$name}->is_same_as($attr);my$role1=$seen{$name}->associated_role->name;my$role2=$attr->associated_role->name;throw_exception(AttributeConflictInSummation=>attribute_name=>$name,role_name=>$role1,second_role_name=>$role2,)}$seen{$name}=$attr}for my$attr (@all_attributes){$c->add_attribute($attr->clone)}}sub apply_methods {my ($self,$c)=@_;my@all_methods=map {my$role=$_;my$aliases=$self->get_method_aliases_for_role($role);my%excludes=map {$_=>undef}@{$self->get_exclusions_for_role($role)};((map {exists$excludes{$_}? (): +{role=>$role,name=>$_,method=>$role->get_method($_),}}map {$_->name}grep {!$_->isa('Class::MOP::Method::Meta')}$role->_get_local_methods),(map {+{role=>$role,name=>$aliases->{$_},method=>$role->get_method($_),}}keys %$aliases))}@{$c->get_roles};my (%seen,%conflicts,%method_map);for my$method (@all_methods){next if$conflicts{$method->{name}};my$seen=$seen{$method->{name}};if ($seen){if ($seen->{method}->body!=$method->{method}->body){$c->add_conflicting_method(name=>$method->{name},roles=>[$method->{role}->name,$seen->{role}->name],);delete$method_map{$method->{name}};$conflicts{$method->{name}}=1;next}}$seen{$method->{name}}=$method;$method_map{$method->{name}}=$method->{method}}$c->add_method($_=>$method_map{$_})for keys%method_map}sub apply_override_method_modifiers {my ($self,$c)=@_;my@all_overrides=map {my$role=$_;map {+{name=>$_,method=>$role->get_override_method_modifier($_),}}$role->get_method_modifier_list('override')}@{$c->get_roles};my%seen;for my$override (@all_overrides){my@role_names=map {$_->name}@{$c->get_roles};if ($c->has_method($override->{name})){throw_exception(OverrideConflictInSummation=>role_names=>\@role_names,role_application=>$self,method_name=>$override->{name})}if (exists$seen{$override->{name}}){if ($seen{$override->{name}}!=$override->{method}){throw_exception(OverrideConflictInSummation=>role_names=>\@role_names,role_application=>$self,method_name=>$override->{name},two_overrides_found=>1)}}$seen{$override->{name}}=$override->{method}}$c->add_override_method_modifier($_->{name},$_->{method})for@all_overrides}sub apply_method_modifiers {my ($self,$modifier_type,$c)=@_;my$add="add_${modifier_type}_method_modifier";my$get="get_${modifier_type}_method_modifiers";for my$role (@{$c->get_roles}){for my$method_name ($role->get_method_modifier_list($modifier_type)){$c->$add($method_name,$_)foreach$role->$get($method_name)}}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS';
  package Moose::Meta::Role::Application::ToClass;$Moose::Meta::Role::Application::ToClass::VERSION='2.1213';use strict;use warnings;use metaclass;use List::MoreUtils 'firstval';use Moose::Util 'english_list';use Scalar::Util 'weaken','blessed';use parent 'Moose::Meta::Role::Application';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('role'=>(reader=>'role',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('class'=>(accessor=>'class',Class::MOP::_definition_context(),));sub apply {my ($self,$role,$class)=@_;weaken($self->{role}=$role);weaken($self->{class}=$class);$self->SUPER::apply($role,$class);$class->add_role($role);$class->add_role_application($self)}sub check_role_exclusions {my ($self,$role,$class)=@_;if ($class->excludes_role($role->name)){throw_exception(ConflictDetectedInCheckRoleExclusionsInToClass=>class_name=>$class->name,role_name=>$role->name,)}for my$excluded_role_name ($role->get_excluded_roles_list){if ($class->does_role($excluded_role_name)){throw_exception(ClassDoesTheExcludedRole=>role_name=>$role->name,excluded_role_name=>$excluded_role_name,class_name=>$class->name,)}}}sub check_required_methods {my ($self,$role,$class)=@_;my@missing;my@is_attr;for my$required_method ($role->get_required_method_list){my$required_method_name=$required_method->name;if (!$class->find_method_by_name($required_method_name)){next if$self->is_aliased_method($required_method_name);push@missing,$required_method}}return unless@missing;my$error='';@missing=sort {$a->name cmp $b->name}@missing;my@conflicts=grep {$_->isa('Moose::Meta::Role::Method::Conflicting')}@missing;if (@conflicts){my$conflict=$conflicts[0];my$roles=$conflict->roles_as_english_list;my@same_role_conflicts=grep {$_->roles_as_english_list eq $roles}@conflicts;throw_exception(MethodNameConflictInRoles=>conflict=>\@same_role_conflicts,class_name=>$class->name)}elsif (@missing){if (my$meth=firstval {$class->name->can($_)}@missing){throw_exception(RequiredMethodsImportedByClass=>class_name=>$class->name,role_name=>$role->name,missing_methods=>\@missing,imported_method=>$meth)}else {throw_exception(RequiredMethodsNotImplementedByClass=>class_name=>$class->name,role_name=>$role->name,missing_methods=>\@missing,)}}}sub check_required_attributes {}sub apply_attributes {my ($self,$role,$class)=@_;for my$attribute_name ($role->get_attribute_list){if ($class->has_attribute($attribute_name)&& $class->get_attribute($attribute_name)!=$role->get_attribute($attribute_name)){next}else {$class->add_attribute($role->get_attribute($attribute_name)->attribute_for_class)}}}sub apply_methods {my ($self,$role,$class)=@_;for my$method ($role->_get_local_methods){my$method_name=$method->name;next if$method->isa('Class::MOP::Method::Meta');unless ($self->is_method_excluded($method_name)){my$class_method=$class->get_method($method_name);next if$class_method && $class_method->body!=$method->body;$class->add_method($method_name,$method,)}next unless$self->is_method_aliased($method_name);my$aliased_method_name=$self->get_method_aliases->{$method_name};my$class_method=$class->get_method($aliased_method_name);if ($class_method && $class_method->body!=$method->body){throw_exception(CannotCreateMethodAliasLocalMethodIsPresentInClass=>aliased_method_name=>$aliased_method_name,method=>$method,role_name=>$role->name,class_name=>$class->name,)}$class->add_method($aliased_method_name,$method,)}$class->reset_package_cache_flag}sub apply_override_method_modifiers {my ($self,$role,$class)=@_;for my$method_name ($role->get_method_modifier_list('override')){if ($class->has_method($method_name)){next}else {my$method=$role->get_override_method_modifier($method_name);my ($package)=Class::MOP::get_code_info($method);$class->add_override_method_modifier($method_name,$method,$package)}}}sub apply_method_modifiers {my ($self,$modifier_type,$role,$class)=@_;my$add="add_${modifier_type}_method_modifier";my$get="get_${modifier_type}_method_modifiers";for my$method_name ($role->get_method_modifier_list($modifier_type)){$class->$add($method_name,$_)foreach$role->$get($method_name)}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE';
  package Moose::Meta::Role::Application::ToInstance;$Moose::Meta::Role::Application::ToInstance::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use List::MoreUtils 'all';use parent 'Moose::Meta::Role::Application';__PACKAGE__->meta->add_attribute('rebless_params'=>(reader=>'rebless_params',default=>sub {{}},Class::MOP::_definition_context(),));sub apply {my ($self,$role,$object,$args)=@_;my$obj_meta=Class::MOP::class_of($object)|| 'Moose::Meta::Class';$obj_meta='Moose::Meta::Class' unless$obj_meta->isa('Moose::Meta::Class');my$class=$obj_meta->create_anon_class(superclasses=>[blessed($object)],roles=>[$role,keys(%$args)? ($args): ()],cache=>(all {$_ eq '-alias' || $_ eq '-excludes'}keys %$args),);$class->rebless_instance($object,%{$self->rebless_params})}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE';
  package Moose::Meta::Role::Application::ToRole;$Moose::Meta::Role::Application::ToRole::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use parent 'Moose::Meta::Role::Application';use Moose::Util 'throw_exception';sub apply {my ($self,$role1,$role2)=@_;$self->SUPER::apply($role1,$role2);$role2->add_role($role1)}sub check_role_exclusions {my ($self,$role1,$role2)=@_;if ($role2->excludes_role($role1->name)){throw_exception(ConflictDetectedInCheckRoleExclusions=>role_name=>$role2->name,excluded_role_name=>$role1->name,)}for my$excluded_role_name ($role1->get_excluded_roles_list){if ($role2->does_role($excluded_role_name)){throw_exception(RoleDoesTheExcludedRole=>role_name=>$role2->name,excluded_role_name=>$excluded_role_name,second_role_name=>$role1->name,)}$role2->add_excluded_roles($excluded_role_name)}}sub check_required_methods {my ($self,$role1,$role2)=@_;for my$required_method ($role1->get_required_method_list){my$required_method_name=$required_method->name;next if$self->is_aliased_method($required_method_name);$role2->add_required_methods($required_method)unless$role2->find_method_by_name($required_method_name)}}sub check_required_attributes {}sub apply_attributes {my ($self,$role1,$role2)=@_;for my$attribute_name ($role1->get_attribute_list){if ($role2->has_attribute($attribute_name)&& $role2->get_attribute($attribute_name)!=$role1->get_attribute($attribute_name)){my$role2_name=$role2->name;throw_exception(AttributeConflictInRoles=>role_name=>$role1->name,second_role_name=>$role2->name,attribute_name=>$attribute_name)}else {$role2->add_attribute($role1->get_attribute($attribute_name)->clone)}}}sub apply_methods {my ($self,$role1,$role2)=@_;for my$method ($role1->_get_local_methods){my$method_name=$method->name;next if$method->isa('Class::MOP::Method::Meta');unless ($self->is_method_excluded($method_name)){my$role2_method=$role2->get_method($method_name);if ($role2_method && $role2_method->body!=$method->body){}else {$role2->add_method($method_name,$method,)}}next unless$self->is_method_aliased($method_name);my$aliased_method_name=$self->get_method_aliases->{$method_name};my$role2_method=$role2->get_method($aliased_method_name);if ($role2_method && $role2_method->body!=$method->body){throw_exception(CannotCreateMethodAliasLocalMethodIsPresent=>aliased_method_name=>$aliased_method_name,method=>$method,role_name=>$role2->name,role_being_applied_name=>$role1->name,)}$role2->add_method($aliased_method_name,$role1->get_method($method_name));if (!$role2->has_method($method_name)){$role2->add_required_methods($method_name)unless$self->is_method_excluded($method_name)}}}sub apply_override_method_modifiers {my ($self,$role1,$role2)=@_;for my$method_name ($role1->get_method_modifier_list('override')){if ($role2->has_method($method_name)){throw_exception(OverrideConflictInComposition=>role_name=>$role2->name,role_being_applied_name=>$role1->name,method_name=>$method_name)}else {if ($role2->has_override_method_modifier($method_name)&& $role1->get_override_method_modifier($method_name)!=$role2->get_override_method_modifier($method_name)){throw_exception(OverrideConflictInComposition=>role_name=>$role2->name,role_being_applied_name=>$role1->name,method_name=>$method_name,two_overrides_found=>1)}else {$role2->add_override_method_modifier($method_name,$role1->get_override_method_modifier($method_name))}}}}sub apply_method_modifiers {my ($self,$modifier_type,$role1,$role2)=@_;my$add="add_${modifier_type}_method_modifier";my$get="get_${modifier_type}_method_modifiers";for my$method_name ($role1->get_method_modifier_list($modifier_type)){$role2->$add($method_name,$_)foreach$role1->$get($method_name)}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE';
  package Moose::Meta::Role::Attribute;$Moose::Meta::Role::Attribute::VERSION='2.1213';use strict;use warnings;use List::MoreUtils 'all';use Scalar::Util 'blessed','weaken';use parent 'Moose::Meta::Mixin::AttributeCore','Class::MOP::Object';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('metaclass'=>(reader=>'metaclass',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('associated_role'=>(reader=>'associated_role',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('_original_role'=>(reader=>'_original_role',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('is'=>(reader=>'is',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('original_options'=>(reader=>'original_options',Class::MOP::_definition_context(),));sub new {my ($class,$name,%options)=@_;(defined$name)|| throw_exception(MustProvideANameForTheAttribute=>params=>\%options,class=>$class);my$role=delete$options{_original_role};return bless {name=>$name,original_options=>\%options,_original_role=>$role,%options,},$class}sub attach_to_role {my ($self,$role)=@_;(blessed($role)&& $role->isa('Moose::Meta::Role'))|| throw_exception(MustPassAMooseMetaRoleInstanceOrSubclass=>class=>$self,role=>$role);weaken($self->{'associated_role'}=$role)}sub original_role {my$self=shift;return$self->_original_role || $self->associated_role}sub attribute_for_class {my$self=shift;my$metaclass=$self->original_role->applied_attribute_metaclass;return$metaclass->interpolate_class_and_new($self->name=>%{$self->original_options})}sub clone {my$self=shift;my$role=$self->original_role;return (ref$self)->new($self->name,%{$self->original_options},_original_role=>$role,)}sub is_same_as {my$self=shift;my$attr=shift;my$self_options=$self->original_options;my$other_options=$attr->original_options;return 0 unless (join q{|},sort keys %{$self_options})eq (join q{|},sort keys %{$other_options});for my$key (keys %{$self_options}){return 0 if defined$self_options->{$key}&&!defined$other_options->{$key};return 0 if!defined$self_options->{$key}&& defined$other_options->{$key};next if all {!defined}$self_options->{$key},$other_options->{$key};return 0 unless$self_options->{$key}eq $other_options->{$key}}return 1}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE';
  package Moose::Meta::Role::Composite;$Moose::Meta::Role::Composite::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use Moose::Util;use parent 'Moose::Meta::Role';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('name'=>(reader=>'name',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('_methods'=>(reader=>'_method_map',default=>sub {{}},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('application_role_summation_class',reader=>'application_role_summation_class',default=>'Moose::Meta::Role::Application::RoleSummation',Class::MOP::_definition_context(),);sub new {my ($class,%params)=@_;for (@{$params{roles}}){unless ($_->isa('Moose::Meta::Role')){throw_exception(RolesListMustBeInstancesOfMooseMetaRole=>params=>\%params,role=>$_,class=>$class)}}my@composition_roles=map {$_->composition_class_roles}@{$params{roles}};if (@composition_roles){my$meta=Moose::Meta::Class->create_anon_class(superclasses=>[$class ],roles=>[@composition_roles ],cache=>1,);$class=$meta->name}$params{name}||=(join "|"=>map {$_->name}@{$params{roles}});$class->_new(\%params)}sub is_anon {0}sub add_method {my ($self,$method_name,$method)=@_;unless (defined$method_name && $method_name){throw_exception(MustDefineAMethodName=>instance=>$self)}my$body;if (blessed($method)){$body=$method->body;if ($method->package_name ne $self->name){$method=$method->clone(package_name=>$self->name,name=>$method_name)if$method->can('clone')}}else {$body=$method;$method=$self->wrap_method_body(body=>$body,name=>$method_name)}$self->_method_map->{$method_name}=$method}sub get_method_list {my$self=shift;return keys %{$self->_method_map}}sub _get_local_methods {my$self=shift;return values %{$self->_method_map}}sub has_method {my ($self,$method_name)=@_;return exists$self->_method_map->{$method_name}}sub get_method {my ($self,$method_name)=@_;return$self->_method_map->{$method_name}}sub apply_params {my ($self,$role_params)=@_;Moose::Util::_load_user_class($self->application_role_summation_class);$self->application_role_summation_class->new(role_params=>$role_params,)->apply($self);return$self}sub reinitialize {my ($class,$old_meta,@args)=@_;throw_exception(CannotInitializeMooseMetaRoleComposite=>old_meta=>$old_meta,args=>\@args,role_composite=>$class)if!blessed$old_meta ||!$old_meta->isa('Moose::Meta::Role::Composite');my%existing_classes=map {$_=>$old_meta->$_()}qw(application_role_summation_class);return$old_meta->meta->clone_object($old_meta,%existing_classes,@args)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD';
  package Moose::Meta::Role::Method;$Moose::Meta::Role::Method::VERSION='2.1213';use strict;use warnings;use parent 'Moose::Meta::Method';sub _make_compatible_with {my$self=shift;my ($other)=@_;return$self unless$other->_is_compatible_with($self->_real_ref_name);return$self->SUPER::_make_compatible_with(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method/Conflicting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING';
  package Moose::Meta::Role::Method::Conflicting;$Moose::Meta::Role::Method::Conflicting::VERSION='2.1213';use strict;use warnings;use Moose::Util;use parent 'Moose::Meta::Role::Method::Required';__PACKAGE__->meta->add_attribute('roles'=>(reader=>'roles',required=>1,Class::MOP::_definition_context(),));sub roles_as_english_list {my$self=shift;Moose::Util::english_list(map {q{'} .$_ .q{'}}@{$self->roles})}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method/Required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED';
  package Moose::Meta::Role::Method::Required;$Moose::Meta::Role::Method::Required::VERSION='2.1213';use strict;use warnings;use metaclass;use overload '""'=>sub {shift->name},fallback=>1;use parent 'Class::MOP::Object';__PACKAGE__->meta->add_attribute('name'=>(reader=>'name',required=>1,Class::MOP::_definition_context(),));sub new {shift->_new(@_)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION';
  package Moose::Meta::TypeCoercion;$Moose::Meta::TypeCoercion::VERSION='2.1213';use strict;use warnings;use metaclass;use Moose::Meta::Attribute;use Moose::Util::TypeConstraints ();use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('type_coercion_map'=>(reader=>'type_coercion_map',default=>sub {[]},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute(Moose::Meta::Attribute->new('type_constraint'=>(reader=>'type_constraint',weak_ref=>1,Class::MOP::_definition_context(),)));__PACKAGE__->meta->add_attribute('compiled_type_coercion'=>(accessor=>'_compiled_type_coercion',Class::MOP::_definition_context(),));sub new {my$class=shift;my$self=Class::MOP::class_of($class)->new_object(@_);$self->compile_type_coercion;return$self}sub compile_type_coercion {my$self=shift;my@coercion_map=@{$self->type_coercion_map};my@coercions;while (@coercion_map){my ($constraint_name,$action)=splice(@coercion_map,0,2);my$type_constraint=ref$constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);unless (defined$type_constraint){throw_exception(CouldNotFindTypeConstraintToCoerceFrom=>constraint_name=>$constraint_name,instance=>$self)}push@coercions=>[$type_constraint->_compiled_type_constraint,$action ]}$self->_compiled_type_coercion(sub {my$thing=shift;for my$coercion (@coercions){my ($constraint,$converter)=@$coercion;if ($constraint->($thing)){local $_=$thing;return$converter->($thing)}}return$thing})}sub has_coercion_for_type {my ($self,$type_name)=@_;my%coercion_map=@{$self->type_coercion_map};exists$coercion_map{$type_name}? 1 : 0}sub add_type_coercions {my ($self,@new_coercion_map)=@_;my$coercion_map=$self->type_coercion_map;my%has_coercion=@$coercion_map;while (@new_coercion_map){my ($constraint_name,$action)=splice(@new_coercion_map,0,2);if (exists$has_coercion{$constraint_name}){throw_exception(CoercionAlreadyExists=>constraint_name=>$constraint_name,instance=>$self)}push @{$coercion_map}=>($constraint_name,$action)}$self->compile_type_coercion}sub coerce {$_[0]->_compiled_type_coercion->($_[1])}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeCoercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION';
  package Moose::Meta::TypeCoercion::Union;$Moose::Meta::TypeCoercion::Union::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use parent 'Moose::Meta::TypeCoercion';use Moose::Util 'throw_exception';sub compile_type_coercion {my$self=shift;my$type_constraint=$self->type_constraint;(blessed$type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))|| throw_exception(NeedsTypeConstraintUnionForTypeCoercionUnion=>type_coercion_union_object=>$self,type_name=>$type_constraint->name);$self->_compiled_type_coercion(sub {my$value=shift;for my$type (grep {$_->has_coercion}@{$type_constraint->type_constraints}){my$temp=$type->coerce($value);return$temp if$type_constraint->check($temp)}return$value})}sub has_coercion_for_type {0}sub add_type_coercions {my$self=shift;throw_exception(CannotAddAdditionalTypeCoercionsToUnion=>type_coercion_union_object=>$self)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT';
  package Moose::Meta::TypeConstraint;$Moose::Meta::TypeConstraint::VERSION='2.1213';use strict;use warnings;use metaclass;use overload '0+'=>sub {refaddr(shift)},'""'=>sub {shift->name},bool=>sub {1},fallback=>1;use Class::Load qw(load_class);use Eval::Closure;use Scalar::Util qw(blessed refaddr);use Sub::Name qw(subname);use Try::Tiny;use base 'Class::MOP::Object';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('name'=>(reader=>'name',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('parent'=>(reader=>'parent',predicate=>'has_parent',Class::MOP::_definition_context(),));my$null_constraint=sub {1};__PACKAGE__->meta->add_attribute('constraint'=>(reader=>'constraint',writer=>'_set_constraint',default=>sub {$null_constraint},Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('message'=>(accessor=>'message',predicate=>'has_message',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('_default_message'=>(accessor=>'_default_message',Class::MOP::_definition_context(),));my$_default_message_generator=sub {my$name=shift;sub {my$value=shift;my$can_partialdump=try {require Devel::PartialDump;Devel::PartialDump->VERSION(0.14);1};if ($can_partialdump){$value=Devel::PartialDump->new->dump($value)}else {$value=(defined$value ? overload::StrVal($value): 'undef')}return "Validation failed for '" .$name ."' with value $value"}};__PACKAGE__->meta->add_attribute('coercion'=>(accessor=>'coercion',predicate=>'has_coercion',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('inlined'=>(init_arg=>'inlined',accessor=>'inlined',predicate=>'_has_inlined_type_constraint',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('inline_environment'=>(init_arg=>'inline_environment',accessor=>'_inline_environment',default=>sub {{}},Class::MOP::_definition_context(),));sub parents {my$self=shift;$self->parent}__PACKAGE__->meta->add_attribute('compiled_type_constraint'=>(accessor=>'_compiled_type_constraint',predicate=>'_has_compiled_type_constraint',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('package_defined_in'=>(accessor=>'_package_defined_in',Class::MOP::_definition_context(),));sub new {my$class=shift;my ($first,@rest)=@_;my%args=ref$first ? %$first : $first ? ($first,@rest): ();$args{name}=$args{name}? "$args{name}" : "__ANON__";if (exists$args{message}&& (!ref($args{message})|| ref($args{message})ne 'CODE')){throw_exception(MessageParameterMustBeCodeRef=>params=>\%args,class=>$class)}my$self=$class->_new(%args);$self->compile_type_constraint()unless$self->_has_compiled_type_constraint;$self->_default_message($_default_message_generator->($self->name))unless$self->has_message;return$self}sub coerce {my$self=shift;my$coercion=$self->coercion;unless ($coercion){throw_exception(CoercingWithoutCoercions=>type_name=>$self->name)}return $_[0]if$self->check($_[0]);return$coercion->coerce(@_)}sub assert_coerce {my$self=shift;my$result=$self->coerce(@_);$self->assert_valid($result);return$result}sub check {my ($self,@args)=@_;my$constraint_subref=$self->_compiled_type_constraint;return$constraint_subref->(@args)? 1 : undef}sub validate {my ($self,$value)=@_;if ($self->_compiled_type_constraint->($value)){return undef}else {$self->get_message($value)}}sub can_be_inlined {my$self=shift;if ($self->has_parent && $self->constraint==$null_constraint){return$self->parent->can_be_inlined}return$self->_has_inlined_type_constraint}sub _inline_check {my$self=shift;unless ($self->can_be_inlined){throw_exception(CannotInlineTypeConstraintCheck=>type_name=>$self->name)}if ($self->has_parent && $self->constraint==$null_constraint){return$self->parent->_inline_check(@_)}return '( do { ' .$self->inlined->($self,@_).' } )'}sub inline_environment {my$self=shift;if ($self->has_parent && $self->constraint==$null_constraint){return$self->parent->inline_environment}return$self->_inline_environment}sub assert_valid {my ($self,$value)=@_;my$error=$self->validate($value);return 1 if!defined$error;throw_exception(ValidationFailedForTypeConstraint=>type=>$self,error_message=>$error,value=>$value)}sub get_message {my ($self,$value)=@_;my$msg=$self->has_message ? $self->message : $self->_default_message;local $_=$value;return$msg->($value)}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name)or return;return 1 if$self==$other;return unless$self->constraint==$other->constraint;if ($self->has_parent){return unless$other->has_parent;return unless$self->parent->equals($other->parent)}else {return if$other->has_parent}return}sub is_a_type_of {my ($self,$type_or_name)=@_;my$type=Moose::Util::TypeConstraints::find_type_constraint($type_or_name)or return;($self->equals($type)|| $self->is_subtype_of($type))}sub is_subtype_of {my ($self,$type_or_name)=@_;my$type=Moose::Util::TypeConstraints::find_type_constraint($type_or_name)or return;my$current=$self;while (my$parent=$current->parent){return 1 if$parent->equals($type);$current=$parent}return 0}sub compile_type_constraint {my$self=shift;$self->_compiled_type_constraint($self->_actually_compile_type_constraint)}sub _actually_compile_type_constraint {my$self=shift;if ($self->can_be_inlined){return eval_closure(source=>'sub { ' .$self->_inline_check('$_[0]').' }',environment=>$self->inline_environment,)}my$check=$self->constraint;unless (defined$check){throw_exception(NoConstraintCheckForTypeConstraint=>type_name=>$self->name)}return$self->_compile_subtype($check)if$self->has_parent;return$self->_compile_type($check)}sub _compile_subtype {my ($self,$check)=@_;my@parents;for my$parent ($self->_collect_all_parents){push@parents=>$parent->constraint}@parents=grep {$_!=$null_constraint}reverse@parents;unless (@parents){return$self->_compile_type($check)}else {my@checks=@parents;push@checks,$check if$check!=$null_constraint;return subname($self->name=>sub {my (@args)=@_;local $_=$args[0];for my$check (@checks){return undef unless$check->(@args)}return 1})}}sub _compile_type {my ($self,$check)=@_;return$check if$check==$null_constraint;return subname($self->name=>sub {my (@args)=@_;local $_=$args[0];$check->(@args)})}sub _collect_all_parents {my$self=shift;my@parents;my$current=$self->parent;while (defined$current){push@parents=>$current;$current=$current->parent}return@parents}sub create_child_type {my ($self,%opts)=@_;my$class=ref$self;return$class->new(%opts,parent=>$self)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS';
  package Moose::Meta::TypeConstraint::Class;$Moose::Meta::TypeConstraint::Class::VERSION='2.1213';use strict;use warnings;use metaclass;use B;use Scalar::Util 'blessed';use Moose::Util::TypeConstraints ();use parent 'Moose::Meta::TypeConstraint';__PACKAGE__->meta->add_attribute('class'=>(reader=>'class',Class::MOP::_definition_context(),));my$inliner=sub {my$self=shift;my$val=shift;return 'Scalar::Util::blessed(' .$val .')' .' && ' .$val .'->isa(' .B::perlstring($self->class).')'};sub new {my ($class,%args)=@_;$args{parent}=Moose::Util::TypeConstraints::find_type_constraint('Object');my$class_name=$args{class};$args{constraint}=sub {$_[0]->isa($class_name)};$args{inlined}=$inliner;my$self=$class->SUPER::new(\%args);$self->compile_type_constraint();return$self}sub parents {my$self=shift;return ($self->parent,map {Moose::Util::TypeConstraints::find_type_constraint($_)|| __PACKAGE__->new(class=>$_,name=>"__ANON__")}Class::MOP::class_of($self->class)->superclasses,)}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);if (!defined($other)){if (!ref($type_or_name)){return$self->class eq $type_or_name}return}return unless$other->isa(__PACKAGE__);return$self->class eq $other->class}sub is_a_type_of {my ($self,$type_or_name)=@_;($self->equals($type_or_name)|| $self->is_subtype_of($type_or_name))}sub is_subtype_of {my ($self,$type_or_name_or_class)=@_;my$type=Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);if (not defined$type){if (not ref$type_or_name_or_class){my$class=$self->class;return 1 if$class ne $type_or_name_or_class && $class->isa($type_or_name_or_class)}return}if ($type->isa(__PACKAGE__)&& $type->class ne $self->class){return$self->class->isa($type->class)}else {$self->SUPER::is_subtype_of($type)}}sub create_child_type {my ($self,@args)=@_;return Moose::Meta::TypeConstraint->new(@args,parent=>$self)}sub get_message {my$self=shift;my ($value)=@_;if ($self->has_message){return$self->SUPER::get_message(@_)}$value=(defined$value ? overload::StrVal($value): 'undef');return "Validation failed for '" .$self->name ."' with value $value (not isa " .$self->class .")"}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/DuckType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE';
  package Moose::Meta::TypeConstraint::DuckType;$Moose::Meta::TypeConstraint::DuckType::VERSION='2.1213';use strict;use warnings;use metaclass;use B;use Scalar::Util 'blessed';use List::MoreUtils qw(all);use Moose::Util 'english_list';use Moose::Util::TypeConstraints ();use parent 'Moose::Meta::TypeConstraint';__PACKAGE__->meta->add_attribute('methods'=>(accessor=>'methods',Class::MOP::_definition_context(),));my$inliner=sub {my$self=shift;my$val=shift;return$self->parent->_inline_check($val).' && do {' ."\n" .'my $val = ' .$val .';' ."\n" .'&List::MoreUtils::all(' ."\n" .'sub { $val->can($_) },' ."\n" .join(', ',map {B::perlstring($_)}@{$self->methods}).');' ."\n" .'}'};sub new {my ($class,%args)=@_;$args{parent}=Moose::Util::TypeConstraints::find_type_constraint('Object');my@methods=@{$args{methods}};$args{constraint}=sub {my$val=$_[0];return all {$val->can($_)}@methods};$args{inlined}=$inliner;my$self=$class->SUPER::new(\%args);$self->compile_type_constraint()unless$self->_has_compiled_type_constraint;return$self}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);return unless$other->isa(__PACKAGE__);my@self_methods=sort @{$self->methods};my@other_methods=sort @{$other->methods};return unless@self_methods==@other_methods;while (@self_methods){my$method=shift@self_methods;my$other_method=shift@other_methods;return unless$method eq $other_method}return 1}sub create_child_type {my ($self,@args)=@_;return Moose::Meta::TypeConstraint->new(@args,parent=>$self)}sub get_message {my$self=shift;my ($value)=@_;if ($self->has_message){return$self->SUPER::get_message(@_)}return$self->SUPER::get_message($value)unless blessed($value);my@methods=grep {!$value->can($_)}@{$self->methods};my$class=blessed$value;$class ||=$value;return$class ." is missing methods " .english_list(map {"'$_'"}@methods)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM';
  package Moose::Meta::TypeConstraint::Enum;$Moose::Meta::TypeConstraint::Enum::VERSION='2.1213';use strict;use warnings;use metaclass;use B;use Moose::Util::TypeConstraints ();use parent 'Moose::Meta::TypeConstraint';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('values'=>(accessor=>'values',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('_inline_var_name'=>(accessor=>'_inline_var_name',Class::MOP::_definition_context(),));my$inliner=sub {my$self=shift;my$val=shift;return 'defined(' .$val .') ' .'&& !ref(' .$val .') ' .'&& $' .$self->_inline_var_name .'{' .$val .'}'};my$var_suffix=0;sub new {my ($class,%args)=@_;$args{parent}=Moose::Util::TypeConstraints::find_type_constraint('Str');$args{inlined}=$inliner;if (scalar @{$args{values}}< 1){throw_exception(MustHaveAtLeastOneValueToEnumerate=>params=>\%args,class=>$class)}for (@{$args{values}}){if (!defined($_)){throw_exception(EnumValuesMustBeString=>params=>\%args,class=>$class,value=>$_)}elsif (ref($_)){throw_exception(EnumValuesMustBeString=>params=>\%args,class=>$class,value=>$_)}}my%values=map {$_=>1}@{$args{values}};$args{constraint}=sub {$values{$_[0]}};my$var_name='enums' .$var_suffix++;;$args{_inline_var_name}=$var_name;$args{inline_environment}={'%' .$var_name=>\%values };my$self=$class->SUPER::new(\%args);$self->compile_type_constraint()unless$self->_has_compiled_type_constraint;return$self}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);return unless$other->isa(__PACKAGE__);my@self_values=sort @{$self->values};my@other_values=sort @{$other->values};return unless@self_values==@other_values;while (@self_values){my$value=shift@self_values;my$other_value=shift@other_values;return unless$value eq $other_value}return 1}sub constraint {my$self=shift;my%values=map {$_=>undef}@{$self->values};return sub {exists$values{$_[0]}}}sub create_child_type {my ($self,@args)=@_;return Moose::Meta::TypeConstraint->new(@args,parent=>$self)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Parameterizable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE';
  package Moose::Meta::TypeConstraint::Parameterizable;$Moose::Meta::TypeConstraint::Parameterizable::VERSION='2.1213';use strict;use warnings;use metaclass;use parent 'Moose::Meta::TypeConstraint';use Moose::Meta::TypeConstraint::Parameterized;use Moose::Util::TypeConstraints ();use Moose::Util 'throw_exception';use Carp 'confess';__PACKAGE__->meta->add_attribute('constraint_generator'=>(accessor=>'constraint_generator',predicate=>'has_constraint_generator',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('inline_generator'=>(accessor=>'inline_generator',predicate=>'has_inline_generator',Class::MOP::_definition_context(),));sub generate_constraint_for {my ($self,$type)=@_;return unless$self->has_constraint_generator;return$self->constraint_generator->($type->type_parameter)if$type->is_subtype_of($self->name);return$self->_can_coerce_constraint_from($type)if$self->has_coercion && $self->coercion->has_coercion_for_type($type->parent->name);return}sub _can_coerce_constraint_from {my ($self,$type)=@_;my$coercion=$self->coercion;my$constraint=$self->constraint_generator->($type->type_parameter);return sub {local $_=$coercion->coerce($_);$constraint->(@_)}}sub generate_inline_for {my ($self,$type,$val)=@_;throw_exception(CannotGenerateInlineConstraint=>parameterizable_type_object_name=>$self->name,type_name=>$type->name,value=>$val,)unless$self->has_inline_generator;return '( do { ' .$self->inline_generator->($self,$type,$val).' } )'}sub _parse_type_parameter {my ($self,$type_parameter)=@_;return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter)}sub parameterize {my ($self,$type_parameter)=@_;my$contained_tc=$self->_parse_type_parameter($type_parameter);if(my$parent=$self->parent){if($parent->can('type_parameter')){unless ($contained_tc->is_a_type_of($parent->type_parameter)){throw_exception(ParameterIsNotSubtypeOfParent=>type_parameter=>$type_parameter,type_name=>$self->name,)}}}if ($contained_tc->isa('Moose::Meta::TypeConstraint')){my$tc_name=$self->name .'[' .$contained_tc->name .']';return Moose::Meta::TypeConstraint::Parameterized->new(name=>$tc_name,parent=>$self,type_parameter=>$contained_tc,parameterized_from=>$self,)}else {confess("The type parameter must be a Moose meta type")}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Parameterized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED';
  package Moose::Meta::TypeConstraint::Parameterized;$Moose::Meta::TypeConstraint::Parameterized::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use Moose::Util::TypeConstraints;use Moose::Meta::TypeConstraint::Parameterizable;use Moose::Util 'throw_exception';use parent 'Moose::Meta::TypeConstraint';__PACKAGE__->meta->add_attribute('type_parameter'=>(accessor=>'type_parameter',predicate=>'has_type_parameter',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('parameterized_from'=>(accessor=>'parameterized_from',predicate=>'has_parameterized_from',Class::MOP::_definition_context(),));sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);return unless$other->isa(__PACKAGE__);return ($self->type_parameter->equals($other->type_parameter)and $self->parent->equals($other->parent))}sub compile_type_constraint {my$self=shift;unless ($self->has_type_parameter){throw_exception(CannotCreateHigherOrderTypeWithoutATypeParameter=>type_name=>$self->name)}my$type_parameter=$self->type_parameter;unless (blessed$type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint')){throw_exception(TypeParameterMustBeMooseMetaType=>type_name=>$self->name)}for my$type (Moose::Util::TypeConstraints::get_all_parameterizable_types()){if (my$constraint=$type->generate_constraint_for($self)){$self->_set_constraint($constraint);return$self->SUPER::compile_type_constraint}}throw_exception(TypeConstraintCannotBeUsedForAParameterizableType=>type_name=>$self->name,parent_type_name=>$self->parent->name,)}sub can_be_inlined {my$self=shift;return $self->has_parameterized_from && $self->parameterized_from->has_inline_generator && $self->type_parameter->can_be_inlined}sub inline_environment {my$self=shift;return {($self->has_parameterized_from ? (%{$self->parameterized_from->inline_environment}): ()),($self->has_type_parameter ? (%{$self->type_parameter->inline_environment}): ()),}}sub _inline_check {my$self=shift;return unless$self->can_be_inlined;return$self->parameterized_from->generate_inline_for($self->type_parameter,@_)}sub create_child_type {my ($self,%opts)=@_;return Moose::Meta::TypeConstraint::Parameterizable->new(%opts,parent=>$self)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY';
  package Moose::Meta::TypeConstraint::Registry;$Moose::Meta::TypeConstraint::Registry::VERSION='2.1213';use strict;use warnings;use metaclass;use Scalar::Util 'blessed';use parent 'Class::MOP::Object';use Moose::Util 'throw_exception';__PACKAGE__->meta->add_attribute('parent_registry'=>(reader=>'get_parent_registry',writer=>'set_parent_registry',predicate=>'has_parent_registry',Class::MOP::_definition_context(),));__PACKAGE__->meta->add_attribute('type_constraints'=>(reader=>'type_constraints',default=>sub {{}},Class::MOP::_definition_context(),));sub new {my$class=shift;my$self=$class->_new(@_);return$self}sub has_type_constraint {my ($self,$type_name)=@_;($type_name and exists$self->type_constraints->{$type_name})? 1 : 0}sub get_type_constraint {my ($self,$type_name)=@_;return unless defined$type_name;$self->type_constraints->{$type_name}}sub add_type_constraint {my ($self,$type)=@_;unless ($type && blessed$type && $type->isa('Moose::Meta::TypeConstraint')){throw_exception(InvalidTypeConstraint=>registry_object=>$self,type=>$type)}$self->type_constraints->{$type->name}=$type}sub find_type_constraint {my ($self,$type_name)=@_;return$self->get_type_constraint($type_name)if$self->has_type_constraint($type_name);return$self->get_parent_registry->find_type_constraint($type_name)if$self->has_parent_registry;return}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE';
  package Moose::Meta::TypeConstraint::Role;$Moose::Meta::TypeConstraint::Role::VERSION='2.1213';use strict;use warnings;use metaclass;use B;use Scalar::Util 'blessed';use Moose::Util::TypeConstraints ();use parent 'Moose::Meta::TypeConstraint';__PACKAGE__->meta->add_attribute('role'=>(reader=>'role',Class::MOP::_definition_context(),));my$inliner=sub {my$self=shift;my$val=shift;return 'Moose::Util::does_role(' .$val .', ' .B::perlstring($self->role).')'};sub new {my ($class,%args)=@_;$args{parent}=Moose::Util::TypeConstraints::find_type_constraint('Object');my$role_name=$args{role};$args{constraint}=sub {Moose::Util::does_role($_[0],$role_name)};$args{inlined}=$inliner;my$self=$class->SUPER::new(\%args);$self->compile_type_constraint();return$self}sub parents {my$self=shift;return ($self->parent,map {Moose::Util::TypeConstraints::find_type_constraint($_)|| __PACKAGE__->new(role=>$_,name=>"__ANON__")}@{Class::MOP::class_of($self->role)->get_roles},)}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);return unless defined$other;return unless$other->isa(__PACKAGE__);return$self->role eq $other->role}sub is_a_type_of {my ($self,$type_or_name)=@_;my$type=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);($self->equals($type)|| $self->is_subtype_of($type_or_name))}sub is_subtype_of {my ($self,$type_or_name_or_role)=@_;if (not ref$type_or_name_or_role){my$class=Class::MOP::class_of($self->role);return 1 if defined($class)&& $class->does_role($type_or_name_or_role)}my$type=Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);return unless defined$type;if ($type->isa(__PACKAGE__)){my$class=Class::MOP::class_of($self->role);return defined($class)&& $class->does_role($type->role)}else {$self->SUPER::is_subtype_of($type)}}sub create_child_type {my ($self,@args)=@_;return Moose::Meta::TypeConstraint->new(@args,parent=>$self)}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION';
  package Moose::Meta::TypeConstraint::Union;$Moose::Meta::TypeConstraint::Union::VERSION='2.1213';use strict;use warnings;use metaclass;use Moose::Meta::TypeCoercion::Union;use List::MoreUtils qw(all);use List::Util qw(first);use parent 'Moose::Meta::TypeConstraint';__PACKAGE__->meta->add_attribute('type_constraints'=>(accessor=>'type_constraints',default=>sub {[]},Class::MOP::_definition_context(),));sub new {my ($class,%options)=@_;my$name=join '|'=>sort {$a cmp $b}map {$_->name}@{$options{type_constraints}};my$self=$class->SUPER::new(name=>$name,%options,);$self->_set_constraint($self->_compiled_type_constraint);return$self}sub coercion {my$self=shift;return$self->{coercion}if exists$self->{coercion};if (grep {$_->has_coercion}@{$self->type_constraints}){return$self->{coercion}=Moose::Meta::TypeCoercion::Union->new(type_constraint=>$self)}else {return$self->{coercion}=undef}}sub has_coercion {return defined $_[0]->coercion}sub _actually_compile_type_constraint {my$self=shift;my@constraints=@{$self->type_constraints};return sub {my$value=shift;for my$type (@constraints){return 1 if$type->check($value)}return undef}}sub can_be_inlined {my$self=shift;for my$tc (@{$self->type_constraints}){return 0 unless$tc->can_be_inlined}return 1}sub _inline_check {my$self=shift;my$val=shift;return '(' .(join ' || ',map {'(' .$_->_inline_check($val).')'}@{$self->type_constraints}).')'}sub inline_environment {my$self=shift;return {map {%{$_->inline_environment}}@{$self->type_constraints}}}sub equals {my ($self,$type_or_name)=@_;my$other=Moose::Util::TypeConstraints::find_type_constraint($type_or_name);return unless$other->isa(__PACKAGE__);my@self_constraints=@{$self->type_constraints};my@other_constraints=@{$other->type_constraints};return unless@self_constraints==@other_constraints;constraint: foreach my$constraint (@self_constraints){for (my$i=0;$i < @other_constraints;$i++ ){if ($constraint->equals($other_constraints[$i])){splice@other_constraints,$i,1;next constraint}}}return@other_constraints==0}sub parent {my$self=shift;my ($first,@rest)=@{$self->type_constraints};for my$parent ($first->_collect_all_parents){return$parent if all {$_->is_a_type_of($parent)}@rest}return}sub validate {my ($self,$value)=@_;my$message;for my$type (@{$self->type_constraints}){my$err=$type->validate($value);return unless defined$err;$message .= ($message ? ' and ' : '').$err if defined$err}return ($message .' in (' .$self->name .')')}sub find_type_for {my ($self,$value)=@_;return first {$_->check($value)}@{$self->type_constraints}}sub is_a_type_of {my ($self,$type_name)=@_;return all {$_->is_a_type_of($type_name)}@{$self->type_constraints}}sub is_subtype_of {my ($self,$type_name)=@_;return all {$_->is_subtype_of($type_name)}@{$self->type_constraints}}sub create_child_type {my ($self,%opts)=@_;my$constraint =Moose::Meta::TypeConstraint->new(%opts,parent=>$self);if (not(defined$opts{constraint})&& $self->has_coercion){$constraint->coercion(Moose::Meta::TypeCoercion::Union->new(type_constraint=>$self,))}return$constraint}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_OBJECT';
  package Moose::Object;$Moose::Object::VERSION='2.1213';use strict;use warnings;use Carp ();use Devel::GlobalDestruction ();use MRO::Compat ();use Scalar::Util ();use Try::Tiny ();use Moose::Util ();use if (not our$__mx_is_compiled),'Moose::Meta::Class';use if (not our$__mx_is_compiled),metaclass=>'Moose::Meta::Class';sub new {my$class=shift;my$real_class=Scalar::Util::blessed($class)|| $class;my$params=$real_class->BUILDARGS(@_);return Class::MOP::Class->initialize($real_class)->new_object($params)}sub BUILDARGS {my$class=shift;if (scalar @_==1){unless (defined $_[0]&& ref $_[0]eq 'HASH'){Moose::Util::throw_exception("SingleParamsToNewMustBeHashRef")}return {%{$_[0]}}}elsif (@_ % 2){Carp::carp("The new() method for $class expects a hash reference or a key/value list." ." You passed an odd number of arguments");return {@_,undef }}else {return {@_}}}sub BUILDALL {return unless $_[0]->can('BUILD');my ($self,$params)=@_;for my$method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')){$method->{code}->execute($self,$params)}}sub DEMOLISHALL {my$self=shift;my ($in_global_destruction)=@_;return unless$self->can('DEMOLISH');my@isa;if (my$meta=Class::MOP::class_of($self)){@isa=$meta->linearized_isa}else {my$class_name=ref$self;@isa=@{mro::get_linear_isa($class_name)}}for my$class (@isa){no strict 'refs';my$demolish=*{"${class}::DEMOLISH"}{CODE};$self->$demolish($in_global_destruction)if defined$demolish}}sub DESTROY {my$self=shift;local $?;Try::Tiny::try {$self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction)}Try::Tiny::catch {die $_};return}BEGIN {my$does=UNIVERSAL->can("DOES")? "SUPER::DOES" : "isa";eval 'sub DOES {
          my ( $self, $class_or_role_name ) = @_;
          return $self->'.$does.'($class_or_role_name)
              || $self->does($class_or_role_name);
      }'}sub does {my ($self,$role_name)=@_;my$class=Scalar::Util::blessed($self)|| $self;my$meta=Class::MOP::Class->initialize($class);(defined$role_name)|| Moose::Util::throw_exception(DoesRequiresRoleName=>class_name=>$meta->name);return 1 if$meta->can('does_role')&& $meta->does_role($role_name);return 0}sub dump {my$self=shift;require Data::Dumper;local$Data::Dumper::Maxdepth=shift if @_;Data::Dumper::Dumper$self}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_OBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_ROLE';
  use strict;use warnings;package Moose::Role;$Moose::Role::VERSION='2.1213';use Scalar::Util 'blessed';use Carp 'croak';use Class::Load 'is_class_loaded';use Module::Runtime 'module_notional_filename';use Sub::Exporter;use Moose ();use Moose::Util 'throw_exception';use Moose::Exporter;use Moose::Meta::Role;use Moose::Util::TypeConstraints;sub extends {throw_exception("RolesDoNotSupportExtends")}sub with {Moose::Util::apply_all_roles(shift,@_)}sub requires {my$meta=shift;throw_exception(MustSpecifyAtleastOneMethod=>role_name=>$meta->name)unless @_;$meta->add_required_methods(@_)}sub excludes {my$meta=shift;throw_exception(MustSpecifyAtleastOneRole=>role_name=>$meta->name)unless @_;$meta->add_excluded_roles(@_)}sub has {my$meta=shift;my$name=shift;throw_exception(InvalidHasProvidedInARole=>role_name=>$meta->name,attribute_name=>$name,)if @_==1;my%context=Moose::Util::_caller_info;$context{context}='has declaration';$context{type}='role';my%options=(definition_context=>\%context,@_);my$attrs=(ref($name)eq 'ARRAY')? $name : [($name)];$meta->add_attribute($_,%options)for @$attrs}sub _add_method_modifier {my$type=shift;my$meta=shift;if (ref($_[0])eq 'Regexp'){throw_exception(RolesDoNotSupportRegexReferencesForMethodModifiers=>modifier_type=>$type,role_name=>$meta->name,)}Moose::Util::add_method_modifier($meta,$type,\@_)}sub before {_add_method_modifier('before',@_)}sub after {_add_method_modifier('after',@_)}sub around {_add_method_modifier('around',@_)}sub super {return unless$Moose::SUPER_BODY;$Moose::SUPER_BODY->(@Moose::SUPER_ARGS)}sub override {my$meta=shift;my ($name,$code)=@_;$meta->add_override_method_modifier($name,$code)}sub inner {throw_exception("RolesDoNotSupportInner")}sub augment {throw_exception("RolesDoNotSupportAugment")}Moose::Exporter->setup_import_methods(with_meta=>[qw(with requires excludes has before after around override) ],as_is=>[qw(extends super inner augment),\&Carp::confess,\&Scalar::Util::blessed,],);sub init_meta {shift;my%args=@_;my$role=$args{for_class};unless ($role){require Moose;throw_exception(InitMetaRequiresClass=>params=>\%args)}my$metaclass=$args{metaclass}|| "Moose::Meta::Role";my$meta_name=exists$args{meta_name}? $args{meta_name}: 'meta';throw_exception(MetaclassNotLoaded=>class_name=>$metaclass)unless is_class_loaded($metaclass);throw_exception(MetaclassMustBeASubclassOfMooseMetaRole=>role_name=>$metaclass)unless$metaclass->isa('Moose::Meta::Role');role_type$role unless find_type_constraint($role);my$meta;if ($meta=Class::MOP::get_metaclass_by_name($role)){unless ($meta->isa("Moose::Meta::Role")){if ($meta->isa('Moose::Meta::Class')){throw_exception(MetaclassIsAClassNotASubclassOfGivenMetaclass=>class_name=>$role,metaclass=>$metaclass,)}else {throw_exception(MetaclassIsNotASubclassOfGivenMetaclass=>class_name=>$role,metaclass=>$metaclass,)}}}else {$meta=$metaclass->initialize($role);my$filename=module_notional_filename($meta->name);$INC{$filename}='(set by Moose)' unless exists$INC{$filename}}if (defined$meta_name){my$existing=$meta->get_method($meta_name);if ($existing &&!$existing->isa('Class::MOP::Method::Meta')){Carp::cluck "Moose::Role is overwriting an existing method named " ."$meta_name in role $role with a method " ."which returns the class's metaclass. If this is " ."actually what you want, you should remove the " ."existing method, otherwise, you should rename or " ."disable this generated method using the " ."'-meta_name' option to 'use Moose::Role'."}$meta->_add_meta_method($meta_name)}return$meta}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL';
  package Moose::Util;$Moose::Util::VERSION='2.1213';use strict;use warnings;use Module::Runtime 0.014 'use_package_optimistically','use_module','module_notional_filename';use Data::OptList;use Params::Util qw(_STRING);use Sub::Exporter;use Scalar::Util 'blessed';use List::Util qw(first);use List::MoreUtils qw(any all);use overload ();use Try::Tiny;my@exports=qw[find_meta is_role does_role search_class_by_role ensure_all_roles apply_all_roles with_traits get_all_init_args get_all_attribute_values resolve_metatrait_alias resolve_metaclass_alias add_method_modifier english_list meta_attribute_alias meta_class_alias throw_exception];Sub::Exporter::setup_exporter({exports=>\@exports,groups=>{all=>\@exports }});require Class::MOP;sub throw_exception {my ($class_name,@args_to_exception)=@_;my$class="Moose::Exception::$class_name";_load_user_class($class);die$class->new(@args_to_exception)}sub find_meta {Class::MOP::class_of(@_)}sub is_role {my$package_or_obj=shift;my$meta=find_meta($package_or_obj);return if not $meta;return$meta->isa('Moose::Meta::Role')}sub does_role {my ($class_or_obj,$role)=@_;if (try {$class_or_obj->isa('Moose::Object')}){return$class_or_obj->does($role)}my$meta=find_meta($class_or_obj);return unless defined$meta;return unless$meta->can('does_role');return 1 if$meta->does_role($role);return}sub search_class_by_role {my ($class_or_obj,$role)=@_;my$meta=find_meta($class_or_obj);return unless defined$meta;my$role_name=blessed$role ? $role->name : $role;for my$class ($meta->class_precedence_list){my$_meta=find_meta($class);next unless defined$_meta;for my$role (@{$_meta->roles || []}){return$class if$role->name eq $role_name}}return}sub ensure_all_roles {my$applicant=shift;_apply_all_roles($applicant,sub {!does_role($applicant,$_)},@_)}sub apply_all_roles {my$applicant=shift;_apply_all_roles($applicant,undef,@_)}sub _apply_all_roles {my$applicant=shift;my$role_filter=shift;unless (@_){require Moose;throw_exception(MustSpecifyAtleastOneRoleToApplicant=>applicant=>$applicant)}my$roles=Data::OptList::mkopt([@_],{moniker=>'role',name_test=>sub {!ref $_[0]or blessed($_[0])&& $_[0]->isa('Moose::Meta::Role')}});my@role_metas;for my$role (@$roles){my$meta;if (blessed$role->[0]){$meta=$role->[0]}else {&use_module($role->[0],$role->[1]&& $role->[1]{-version}? $role->[1]{-version}: ());$meta=find_meta($role->[0])}unless ($meta && $meta->isa('Moose::Meta::Role')){throw_exception(CanOnlyConsumeRole=>role_name=>$role->[0])}push@role_metas,[$meta,$role->[1]]}if (defined$role_filter){@role_metas=grep {local $_=$_->[0];$role_filter->()}@role_metas}return unless@role_metas;_load_user_class($applicant)unless blessed($applicant)|| Class::MOP::class_of($applicant);my$meta=(blessed$applicant ? $applicant : Moose::Meta::Class->initialize($applicant));if (scalar@role_metas==1){my ($role,$params)=@{$role_metas[0]};$role->apply($meta,(defined$params ? %$params : ()))}else {Moose::Meta::Role->combine(@role_metas)->apply($meta)}}sub with_traits {my ($class,@roles)=@_;return$class unless@roles;return Moose::Meta::Class->create_anon_class(superclasses=>[$class],roles=>\@roles,cache=>1,)->name}sub get_all_attribute_values {my ($class,$instance)=@_;return +{map {$_->name=>$_->get_value($instance)}grep {$_->has_value($instance)}$class->get_all_attributes }}sub get_all_init_args {my ($class,$instance)=@_;return +{map {$_->init_arg=>$_->get_value($instance)}grep {$_->has_value($instance)}grep {defined($_->init_arg)}$class->get_all_attributes }}sub resolve_metatrait_alias {return resolve_metaclass_alias(@_,trait=>1)}sub _build_alias_package_name {my ($type,$name,$trait)=@_;return 'Moose::Meta::' .$type .'::Custom::' .($trait ? 'Trait::' : '').$name}{my%cache;sub resolve_metaclass_alias {my ($type,$metaclass_name,%options)=@_;my$cache_key=$type .q{ } .($options{trait}? '-Trait' : '');return$cache{$cache_key}{$metaclass_name}if$cache{$cache_key}{$metaclass_name};my$possible_full_name=_build_alias_package_name($type,$metaclass_name,$options{trait});my@possible=($possible_full_name,$metaclass_name);for my$package (@possible){use_package_optimistically($package);if ($package->can('register_implementation')){return$cache{$cache_key}{$metaclass_name}=$package->register_implementation}elsif (find_meta($package)){return$cache{$cache_key}{$metaclass_name}=$package}}throw_exception(CannotLocatePackageInINC=>possible_packages=>_english_list_or(@possible),INC=>\@INC,type=>$type,metaclass_name=>$metaclass_name,params=>\%options)}}sub add_method_modifier {my ($class_or_obj,$modifier_name,$args)=@_;my$meta =$class_or_obj->can('add_before_method_modifier')? $class_or_obj : find_meta($class_or_obj);my$code=pop @{$args};my$add_modifier_method='add_' .$modifier_name .'_method_modifier';if (my$method_modifier_type=ref(@{$args}[0])){if ($method_modifier_type eq 'Regexp'){my@all_methods=$meta->get_all_methods;my@matched_methods =grep {$_->name =~ @{$args}[0]}@all_methods;$meta->$add_modifier_method($_->name,$code)for@matched_methods}elsif ($method_modifier_type eq 'ARRAY'){$meta->$add_modifier_method($_,$code)for @{$args->[0]}}else {throw_exception(IllegalMethodTypeToAddMethodModifier=>class_or_object=>$class_or_obj,modifier_name=>$modifier_name,params=>$args)}}else {$meta->$add_modifier_method($_,$code)for @{$args}}}sub english_list {_english_list_and(@_)}sub _english_list_and {_english_list('and',\@_)}sub _english_list_or {_english_list('or',\@_)}sub _english_list {my ($conjunction,$items)=@_;my@items=sort @$items;return$items[0]if@items==1;return "$items[0] $conjunction $items[1]" if@items==2;my$tail=pop@items;my$list=join ', ',@items;$list .= ", $conjunction " .$tail;return$list}sub _caller_info {my$level=@_ ? ($_[0]+ 1): 2;my%info;@info{qw(package file line)}=caller($level);return%info}sub _create_alias {my ($type,$name,$trait,$for)=@_;my$package=_build_alias_package_name($type,$name,$trait);Class::MOP::Class->initialize($package)->add_method(register_implementation=>sub {$for})}sub meta_attribute_alias {my ($to,$from)=@_;$from ||=caller;my$meta=Class::MOP::class_of($from);my$trait=$meta->isa('Moose::Meta::Role');_create_alias('Attribute',$to,$trait,$from)}sub meta_class_alias {my ($to,$from)=@_;$from ||=caller;my$meta=Class::MOP::class_of($from);my$trait=$meta->isa('Moose::Meta::Role');_create_alias('Class',$to,$trait,$from)}sub _load_user_class {my ($class,$opts)=@_;&use_package_optimistically($class,$opts && $opts->{-version}? $opts->{-version}: ())}sub _STRINGLIKE0 ($) {return 1 if _STRING($_[0]);if (blessed $_[0]){return overload::Method($_[0],q{""})}return 1 if defined $_[0]&& $_[0]eq q{};return 0}sub _reconcile_roles_for_metaclass {my ($class_meta_name,$super_meta_name)=@_;my@role_differences=_role_differences($class_meta_name,$super_meta_name,);return$super_meta_name unless@role_differences;return Moose::Meta::Class->create_anon_class(superclasses=>[$super_meta_name],roles=>[map {$_->name}@role_differences],cache=>1,)->name}sub _role_differences {my ($class_meta_name,$super_meta_name)=@_;my@super_role_metas=map {$_->isa('Moose::Meta::Role::Composite')? (@{$_->get_roles}): ($_)}$super_meta_name->meta->can('_roles_with_inheritance')? $super_meta_name->meta->_roles_with_inheritance : $super_meta_name->meta->can('roles')? @{$super_meta_name->meta->roles}: ();my@role_metas=map {$_->isa('Moose::Meta::Role::Composite')? (@{$_->get_roles}): ($_)}$class_meta_name->meta->can('_roles_with_inheritance')? $class_meta_name->meta->_roles_with_inheritance : $class_meta_name->meta->can('roles')? @{$class_meta_name->meta->roles}: ();my@differences;for my$role_meta (@role_metas){push@differences,$role_meta unless any {$_->name eq $role_meta->name}@super_role_metas}return@differences}sub _classes_differ_by_roles_only {my ($self_meta_name,$super_meta_name)=@_;my$common_base_name =_find_common_base($self_meta_name,$super_meta_name);return unless defined$common_base_name;my@super_meta_name_ancestor_names =_get_ancestors_until($super_meta_name,$common_base_name);my@class_meta_name_ancestor_names =_get_ancestors_until($self_meta_name,$common_base_name);return unless all {_is_role_only_subclass($_)}@super_meta_name_ancestor_names,@class_meta_name_ancestor_names;return 1}sub _find_common_base {my ($meta1,$meta2)=map {Class::MOP::class_of($_)}@_;return unless defined$meta1 && defined$meta2;my%meta1_parents=map {$_=>1}$meta1->linearized_isa;return first {$meta1_parents{$_}}$meta2->linearized_isa}sub _get_ancestors_until {my ($start_name,$until_name)=@_;my@ancestor_names;for my$ancestor_name (Class::MOP::class_of($start_name)->linearized_isa){last if$ancestor_name eq $until_name;push@ancestor_names,$ancestor_name}return@ancestor_names}sub _is_role_only_subclass {my ($meta_name)=@_;my$meta=Class::MOP::Class->initialize($meta_name);my@parent_names=$meta->superclasses;return unless@parent_names==1;my ($parent_name)=@parent_names;my$parent_meta=Class::MOP::Class->initialize($parent_name);my@roles=$meta->can('calculate_all_roles')? $meta->calculate_all_roles : ();return unless@roles;for my$method ($meta->_get_local_methods){next if$method->isa('Class::MOP::Method::Meta');next if$method->can('associated_attribute');next if$meta->can('does_role')&& $meta->does_role($method->original_package_name);next if$method->isa('Class::MOP::Method::Wrapped')&& ((!scalar($method->around_modifiers)|| any {$_->has_around_method_modifiers($method->name)}@roles)&& (!scalar($method->before_modifiers)|| any {$_->has_before_method_modifiers($method->name)}@roles)&& (!scalar($method->after_modifiers)|| any {$_->has_after_method_modifiers($method->name)}@roles));return 0}for my$attr (map {$meta->get_attribute($_)}$meta->get_attribute_list){next if any {$_->has_attribute($attr->name)}@roles;return 0}return 1}sub _is_package_loaded {my ($package)=@_;defined$INC{module_notional_filename($package)}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/MetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_METAROLE';
  package Moose::Util::MetaRole;$Moose::Util::MetaRole::VERSION='2.1213';use strict;use warnings;use Scalar::Util 'blessed';use List::MoreUtils qw(all);use List::Util qw(first);use Moose::Deprecated;use Scalar::Util qw(blessed);use Moose::Util 'throw_exception';sub apply_metaroles {my%args=@_;my$for=_metathing_for($args{for});if ($for->isa('Moose::Meta::Role')){return _make_new_metaclass($for,$args{role_metaroles},'role')}else {return _make_new_metaclass($for,$args{class_metaroles},'class')}}sub _metathing_for {my$passed=shift;my$found =blessed$passed ? $passed : Class::MOP::class_of($passed);return$found if defined$found && blessed$found && ($found->isa('Moose::Meta::Role')|| $found->isa('Moose::Meta::Class'));local$Carp::CarpLevel=$Carp::CarpLevel + 1;throw_exception(InvalidArgPassedToMooseUtilMetaRole=>argument=>$passed)}sub _make_new_metaclass {my$for=shift;my$roles=shift;my$primary=shift;return$for unless keys %{$roles};my$new_metaclass =exists$roles->{$primary}? _make_new_class(ref$for,$roles->{$primary}): blessed$for;my%classes;for my$key (grep {$_ ne $primary}keys %{$roles}){my$attr=first {$_}map {$for->meta->find_attribute_by_name($_)}($key .'_metaclass',$key .'_class');my$reader=$attr->get_read_method;$classes{$attr->init_arg }=_make_new_class($for->$reader(),$roles->{$key})}my$new_meta=$new_metaclass->reinitialize($for,%classes);return$new_meta}sub apply_base_class_roles {my%args=@_;my$meta=_metathing_for($args{for}|| $args{for_class});throw_exception(CannotApplyBaseClassRolesToRole=>params=>\%args,role_name=>$meta->name,)if$meta->isa('Moose::Meta::Role');my$new_base=_make_new_class($meta->name,$args{roles},[$meta->superclasses()],);$meta->superclasses($new_base)if$new_base ne $meta->name()}sub _make_new_class {my$existing_class=shift;my$roles=shift;my$superclasses=shift || [$existing_class];return$existing_class unless$roles;my$meta=Class::MOP::Class->initialize($existing_class);return$existing_class if$meta->can('does_role')&& all {$meta->does_role($_)}grep {!ref $_}@{$roles};return Moose::Meta::Class->create_anon_class(superclasses=>$superclasses,roles=>$roles,cache=>1,)->name()}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_METAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/TypeConstraints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS';
  package Moose::Util::TypeConstraints;$Moose::Util::TypeConstraints::VERSION='2.1213';use Carp ();use List::MoreUtils qw(all any);use Scalar::Util qw(blessed reftype);use Moose::Exporter;use Moose::Deprecated;sub where (&);sub via (&);sub message (&);sub inline_as (&);use Moose::Meta::TypeConstraint;use Moose::Meta::TypeConstraint::Union;use Moose::Meta::TypeConstraint::Parameterized;use Moose::Meta::TypeConstraint::Parameterizable;use Moose::Meta::TypeConstraint::Class;use Moose::Meta::TypeConstraint::Role;use Moose::Meta::TypeConstraint::Enum;use Moose::Meta::TypeConstraint::DuckType;use Moose::Meta::TypeCoercion;use Moose::Meta::TypeCoercion::Union;use Moose::Meta::TypeConstraint::Registry;use Moose::Util 'throw_exception';Moose::Exporter->setup_import_methods(as_is=>[qw(type subtype class_type role_type maybe_type duck_type as where message inline_as coerce from via enum union find_type_constraint register_type_constraint match_on_type) ],);my$REGISTRY=Moose::Meta::TypeConstraint::Registry->new;sub get_type_constraint_registry {$REGISTRY}sub list_all_type_constraints {keys %{$REGISTRY->type_constraints}}sub export_type_constraints_as_functions {my$pkg=caller();no strict 'refs';for my$constraint (keys %{$REGISTRY->type_constraints}){my$tc=$REGISTRY->get_type_constraint($constraint)->_compiled_type_constraint;*{"${pkg}::${constraint}"}=sub {$tc->($_[0])? 1 : undef}}}sub create_type_constraint_union {_create_type_constraint_union(\@_)}sub create_named_type_constraint_union {my$name=shift;_create_type_constraint_union($name,\@_)}sub _create_type_constraint_union {my$name;$name=shift if @_ > 1;my@tcs=@{shift()};my@type_constraint_names;if (scalar@tcs==1 && _detect_type_constraint_union($tcs[0])){@type_constraint_names=_parse_type_constraint_union($tcs[0])}else {@type_constraint_names=@tcs}(scalar@type_constraint_names >= 2)|| throw_exception("UnionTakesAtleastTwoTypeNames");my@type_constraints=map {find_or_parse_type_constraint($_)|| throw_exception(CouldNotLocateTypeConstraintForUnion=>type_name=>$_)}@type_constraint_names;my%options=(type_constraints=>\@type_constraints);$options{name}=$name if defined$name;return Moose::Meta::TypeConstraint::Union->new(%options)}sub create_parameterized_type_constraint {my$type_constraint_name=shift;my ($base_type,$type_parameter)=_parse_parameterized_type_constraint($type_constraint_name);(defined$base_type && defined$type_parameter)|| throw_exception(InvalidTypeGivenToCreateParameterizedTypeConstraint=>type_name=>$type_constraint_name);if ($REGISTRY->has_type_constraint($base_type)){my$base_type_tc=$REGISTRY->get_type_constraint($base_type);return _create_parameterized_type_constraint($base_type_tc,$type_parameter)}else {throw_exception(InvalidBaseTypeGivenToCreateParameterizedTypeConstraint=>type_name=>$base_type)}}sub _create_parameterized_type_constraint {my ($base_type_tc,$type_parameter)=@_;if ($base_type_tc->can('parameterize')){return$base_type_tc->parameterize($type_parameter)}else {return Moose::Meta::TypeConstraint::Parameterized->new(name=>$base_type_tc->name .'[' .$type_parameter .']',parent=>$base_type_tc,type_parameter=>find_or_create_isa_type_constraint($type_parameter),)}}sub create_class_type_constraint {my ($class,$options)=@_;my$pkg_defined_in=$options->{package_defined_in}|| scalar(caller(1));if (my$type=$REGISTRY->get_type_constraint($class)){if (!($type->isa('Moose::Meta::TypeConstraint::Class')&& $type->class eq $class)){throw_exception(TypeConstraintIsAlreadyCreated=>package_defined_in=>$pkg_defined_in,type_name=>$type->name,)}else {return$type}}my%options=(class=>$class,name=>$class,package_defined_in=>$pkg_defined_in,%{$options || {}},);$options{name}||="__ANON__";my$tc=Moose::Meta::TypeConstraint::Class->new(%options);$REGISTRY->add_type_constraint($tc);return$tc}sub create_role_type_constraint {my ($role,$options)=@_;my$pkg_defined_in=$options->{package_defined_in}|| scalar(caller(1));if (my$type=$REGISTRY->get_type_constraint($role)){if (!($type->isa('Moose::Meta::TypeConstraint::Role')&& $type->role eq $role)){throw_exception(TypeConstraintIsAlreadyCreated=>type_name=>$type->name,package_defined_in=>$pkg_defined_in)}else {return$type}}my%options=(role=>$role,name=>$role,package_defined_in=>$pkg_defined_in,%{$options || {}},);$options{name}||="__ANON__";my$tc=Moose::Meta::TypeConstraint::Role->new(%options);$REGISTRY->add_type_constraint($tc);return$tc}sub find_or_create_type_constraint {my ($type_constraint_name,$options_for_anon_type)=@_;if (my$constraint =find_or_parse_type_constraint($type_constraint_name)){return$constraint}elsif (defined$options_for_anon_type){return Moose::Meta::TypeConstraint->new(name=>'__ANON__',%{$options_for_anon_type})}return}sub find_or_create_isa_type_constraint {my ($type_constraint_name,$options)=@_;find_or_parse_type_constraint($type_constraint_name)|| create_class_type_constraint($type_constraint_name,$options)}sub find_or_create_does_type_constraint {my ($type_constraint_name,$options)=@_;find_or_parse_type_constraint($type_constraint_name)|| create_role_type_constraint($type_constraint_name,$options)}sub find_or_parse_type_constraint {my$type_constraint_name=normalize_type_constraint_name(shift);my$constraint;if ($constraint=find_type_constraint($type_constraint_name)){return$constraint}elsif (_detect_type_constraint_union($type_constraint_name)){$constraint=create_type_constraint_union($type_constraint_name)}elsif (_detect_parameterized_type_constraint($type_constraint_name)){$constraint =create_parameterized_type_constraint($type_constraint_name)}else {return}$REGISTRY->add_type_constraint($constraint);return$constraint}sub normalize_type_constraint_name {my$type_constraint_name=shift;$type_constraint_name =~ s/\s//g;return$type_constraint_name}sub _confess {my$error=shift;local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::confess($error)}sub find_type_constraint {my$type=shift;if (blessed$type and $type->isa("Moose::Meta::TypeConstraint")){return$type}else {return unless$REGISTRY->has_type_constraint($type);return$REGISTRY->get_type_constraint($type)}}sub register_type_constraint {my$constraint=shift;throw_exception(CannotRegisterUnnamedTypeConstraint=>type=>$constraint)unless defined$constraint->name;$REGISTRY->add_type_constraint($constraint);return$constraint}sub type {my$name=shift;my%p=map {%{$_}}@_;return _create_type_constraint($name,undef,$p{where},$p{message},$p{inline_as},)}sub subtype {if (@_==1 &&!ref $_[0]){throw_exception(NoParentGivenToSubtype=>name=>$_[0])}my$name=ref $_[0]&&!blessed $_[0]? undef : shift;my%p=map {%{$_}}@_;if (!exists$p{as}){$p{as}=$name;$name=undef}return _create_type_constraint($name,$p{as},$p{where},$p{message},$p{inline_as},)}sub class_type {create_class_type_constraint(@_)}sub role_type ($;$) {create_role_type_constraint(@_)}sub maybe_type {my ($type_parameter)=@_;register_type_constraint($REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter))}sub duck_type {my ($type_name,@methods)=@_;if (ref$type_name eq 'ARRAY' &&!@methods){@methods=($type_name);$type_name=undef}if (@methods==1 && ref$methods[0]eq 'ARRAY'){@methods=@{$methods[0]}}else {Moose::Deprecated::deprecated(feature=>'non-arrayref form of duck_type',message=>"Passing a list of values to duck_type is deprecated. " ."The method names should be wrapped in an arrayref.",)}register_type_constraint(create_duck_type_constraint($type_name,\@methods,))}sub coerce {my ($type_name,@coercion_map)=@_;_install_type_coercions($type_name,\@coercion_map)}sub as {{as=>shift },@_}sub where (&) {{where=>$_[0]}}sub message (&) {{message=>$_[0]}}sub inline_as (&) {{inline_as=>$_[0]}}sub from {@_}sub via (&) {$_[0]}sub enum {my ($type_name,@values)=@_;if (ref$type_name eq 'ARRAY'){@values==0 || throw_exception(EnumCalledWithAnArrayRefAndAdditionalArgs=>array=>$type_name,args=>\@values);@values=($type_name);$type_name=undef}if (@values==1 && ref$values[0]eq 'ARRAY'){@values=@{$values[0]}}else {Moose::Deprecated::deprecated(feature=>'non-arrayref form of enum',message=>"Passing a list of values to enum is deprecated. " ."Enum values should be wrapped in an arrayref.",)}register_type_constraint(create_enum_type_constraint($type_name,\@values,))}sub union {my ($type_name,@constraints)=@_;if (ref$type_name eq 'ARRAY'){@constraints==0 || throw_exception(UnionCalledWithAnArrayRefAndAdditionalArgs=>array=>$type_name,args=>\@constraints);@constraints=@$type_name;$type_name=undef}if (@constraints==1 && ref$constraints[0]eq 'ARRAY'){@constraints=@{$constraints[0]}}if (defined$type_name){return register_type_constraint(create_named_type_constraint_union($type_name,@constraints))}return create_type_constraint_union(@constraints)}sub create_enum_type_constraint {my ($type_name,$values)=@_;Moose::Meta::TypeConstraint::Enum->new(name=>$type_name || '__ANON__',values=>$values,)}sub create_duck_type_constraint {my ($type_name,$methods)=@_;Moose::Meta::TypeConstraint::DuckType->new(name=>$type_name || '__ANON__',methods=>$methods,)}sub match_on_type {my ($to_match,@cases)=@_;my$default;if (@cases % 2!=0){$default=pop@cases;(ref$default eq 'CODE')|| throw_exception(DefaultToMatchOnTypeMustBeCodeRef=>to_match=>$to_match,default_action=>$default,cases_to_be_matched=>\@cases)}while (@cases){my ($type,$action)=splice@cases,0,2;unless (blessed$type && $type->isa('Moose::Meta::TypeConstraint')){$type=find_or_parse_type_constraint($type)|| throw_exception(CannotFindTypeGivenToMatchOnType=>type=>$type,to_match=>$to_match,action=>$action)}(ref$action eq 'CODE')|| throw_exception(MatchActionMustBeACodeRef=>type_name=>$type->name,action=>$action,to_match=>$to_match);if ($type->check($to_match)){local $_=$to_match;return$action->($to_match)}}(defined$default)|| throw_exception(NoCasesMatched=>to_match=>$to_match,cases_to_be_matched=>\@cases);{local $_=$to_match;return$default->($to_match)}}sub _create_type_constraint ($$$;$) {my$name=shift;my$parent=shift;my$check=shift;my$message=shift;my$inlined=shift;my$pkg_defined_in=scalar(caller(1));if (defined$name){my$type=$REGISTRY->get_type_constraint($name);($type->_package_defined_in eq $pkg_defined_in)|| throw_exception(TypeConstraintIsAlreadyCreated=>package_defined_in=>$pkg_defined_in,type_name=>$type->name,)if defined$type;if($name !~ /^[\w:\.]+$/){throw_exception(InvalidNameForType=>name=>$name)}}my%opts=(name=>$name,package_defined_in=>$pkg_defined_in,($check ? (constraint=>$check): ()),($message ? (message=>$message): ()),($inlined ? (inlined=>$inlined): ()),);my$constraint;if (defined$parent and $parent =blessed$parent ? $parent : find_or_create_isa_type_constraint($parent)){$constraint=$parent->create_child_type(%opts)}else {$constraint=Moose::Meta::TypeConstraint->new(%opts)}$REGISTRY->add_type_constraint($constraint)if defined$name;return$constraint}sub _install_type_coercions ($$) {my ($type_name,$coercion_map)=@_;my$type=find_type_constraint($type_name);(defined$type)|| throw_exception(CannotFindType=>type_name=>$type_name);if ($type->has_coercion){$type->coercion->add_type_coercions(@$coercion_map)}else {my$type_coercion=Moose::Meta::TypeCoercion->new(type_coercion_map=>$coercion_map,type_constraint=>$type);$type->coercion($type_coercion)}}{use re "eval";my$valid_chars=qr{[\w:\.]};my$type_atom=qr{ (?>$valid_chars+) }x;my$ws=qr{ (?>\s*) }x;my$op_union=qr{ $ws \| $ws }x;my ($type,$type_capture_parts,$type_with_parameter,$union,$any);if (Class::MOP::IS_RUNNING_ON_5_10){my$type_pattern =q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };my$type_capture_parts_pattern =q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };my$type_with_parameter_pattern =q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };my$union_pattern =q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };my$any_pattern =q{ (?&type) | (?&union) };my$defines=qr{(?(DEFINE)
              (?<valid_chars>         $valid_chars)
              (?<type_atom>           $type_atom)
              (?<ws>                  $ws)
              (?<op_union>            $op_union)
              (?<type>                $type_pattern)
              (?<type_capture_parts>  $type_capture_parts_pattern)
              (?<type_with_parameter> $type_with_parameter_pattern)
              (?<union>               $union_pattern)
              (?<any>                 $any_pattern)
          )}x;$type=qr{ $type_pattern                $defines }x;$type_capture_parts=qr{ $type_capture_parts_pattern  $defines }x;$type_with_parameter=qr{ $type_with_parameter_pattern $defines }x;$union=qr{ $union_pattern               $defines }x;$any=qr{ $any_pattern                 $defines }x}else {$type =qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;$type_capture_parts =qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;$type_with_parameter =qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;$union =qr{ $type (?> (?: $op_union $type )+ ) }x;$any =qr{ $type | $union }x}sub _parse_parameterized_type_constraint {{no warnings 'void';$any}$_[0]=~ m{ $type_capture_parts }x;return ($1,$2)}sub _detect_parameterized_type_constraint {{no warnings 'void';$any}$_[0]=~ m{ ^ $type_with_parameter $ }x}sub _parse_type_constraint_union {{no warnings 'void';$any}my$given=shift;my@rv;while ($given =~ m{ \G (?: $op_union )? ($type) }gcx){push@rv=>$1}(pos($given)eq length($given))|| throw_exception(CouldNotParseType=>type=>$given,position=>pos($given));@rv}sub _detect_type_constraint_union {{no warnings 'void';$any}$_[0]=~ m{^ $type $op_union $type ( $op_union .* )? $}x}}$_->make_immutable(inline_constructor=>1,constructor_name=>"_new",inline_accessors=>1)for grep {$_->is_mutable}map {Class::MOP::class_of($_)}qw(Moose::Meta::TypeConstraint Moose::Meta::TypeConstraint::Union Moose::Meta::TypeConstraint::Parameterized Moose::Meta::TypeConstraint::Parameterizable Moose::Meta::TypeConstraint::Class Moose::Meta::TypeConstraint::Role Moose::Meta::TypeConstraint::Enum Moose::Meta::TypeConstraint::DuckType Moose::Meta::TypeConstraint::Registry);require Moose::Util::TypeConstraints::Builtins;Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);my@PARAMETERIZABLE_TYPES =map {$REGISTRY->get_type_constraint($_)}qw[ScalarRef ArrayRef HashRef Maybe];sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}sub add_parameterizable_type {my$type=shift;(blessed$type && $type->isa('Moose::Meta::TypeConstraint::Parameterizable'))|| throw_exception(AddParameterizableTypeTakesParameterizableType=>type_name=>$type);push@PARAMETERIZABLE_TYPES=>$type}{my@BUILTINS=list_all_type_constraints();sub list_all_builtin_type_constraints {@BUILTINS}}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/TypeConstraints/Builtins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS';
  package Moose::Util::TypeConstraints::Builtins;$Moose::Util::TypeConstraints::Builtins::VERSION='2.1213';use strict;use warnings;use Class::Load qw(is_class_loaded);use List::MoreUtils ();use Scalar::Util qw(blessed looks_like_number reftype);sub type {goto&Moose::Util::TypeConstraints::type}sub subtype {goto&Moose::Util::TypeConstraints::subtype}sub as {goto&Moose::Util::TypeConstraints::as}sub where (&) {goto&Moose::Util::TypeConstraints::where}sub inline_as (&) {goto&Moose::Util::TypeConstraints::inline_as}sub define_builtins {my$registry=shift;type 'Any' =>where {1}=>inline_as {'1'};subtype 'Item' =>as 'Any' =>inline_as {'1'};subtype 'Undef' =>as 'Item' =>where {!defined($_)}=>inline_as {'!defined(' .$_[1].')'};subtype 'Defined' =>as 'Item' =>where {defined($_)}=>inline_as {'defined(' .$_[1].')'};subtype 'Bool' =>as 'Item' =>where {!defined($_)|| $_ eq "" || "$_" eq '1' || "$_" eq '0'}=>inline_as {'(' .'!defined(' .$_[1].') ' .'|| ' .$_[1].' eq "" ' .'|| (' .$_[1].'."") eq "1" ' .'|| (' .$_[1].'."") eq "0"' .')'};subtype 'Value' =>as 'Defined' =>where {!ref($_)}=>inline_as {$_[0]->parent()->_inline_check($_[1]).' && !ref(' .$_[1].')'};subtype 'Ref' =>as 'Defined' =>where {ref($_)}=>inline_as {'ref(' .$_[1].')'};subtype 'Str' =>as 'Value' =>where {ref(\$_)eq 'SCALAR' || ref(\(my$val=$_))eq 'SCALAR'}=>inline_as {$_[0]->parent()->_inline_check($_[1]).' && (' .'ref(\\' .$_[1].') eq "SCALAR"' .' || ref(\\(my $val = ' .$_[1].')) eq "SCALAR"' .')'};my$value_type=Moose::Util::TypeConstraints::find_type_constraint('Value');subtype 'Num' =>as 'Str' =>where {my$val=$_;($val =~ /\A[+-]?[0-9]+\z/)|| ($val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
          (?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
          [0-9]*                                #matches 0-9 zero or more times
          (?:\.[0-9]+)?                         #matches optional .89 or nothing
              (?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
          \z/x)}=>inline_as {'my $val = '.$_[1].';'.$value_type->_inline_check('$val').' && ( $val =~ /\A[+-]?[0-9]+\z/ || ' .'$val =~ /\A(?:[+-]?)               #matches optional +- in the beginning
                  (?=[0-9]|\.[0-9])                 #matches previous +- only if there is something like 3 or .3
                  [0-9]*                            #matches 0-9 zero or more times
                  (?:\.[0-9]+)?                     #matches optional .89 or nothing
                  (?:[Ee](?:[+-]?[0-9]+))?          #matches E1 or e1 or e-1 or e+1 etc
                  \z/x ); '};subtype 'Int' =>as 'Num' =>where {(my$val=$_)=~ /\A-?[0-9]+\z/}=>inline_as {$value_type->_inline_check($_[1]).' && (my $val = ' .$_[1].') =~ /\A-?[0-9]+\z/'};subtype 'CodeRef' =>as 'Ref' =>where {ref($_)eq 'CODE'}=>inline_as {'ref(' .$_[1].') eq "CODE"'};subtype 'RegexpRef' =>as 'Ref' =>where(\&_RegexpRef)=>inline_as {'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' .$_[1].')'};subtype 'GlobRef' =>as 'Ref' =>where {ref($_)eq 'GLOB'}=>inline_as {'ref(' .$_[1].') eq "GLOB"'};subtype 'FileHandle' =>as 'Ref' =>where {(ref($_)eq "GLOB" && Scalar::Util::openhandle($_))|| (blessed($_)&& $_->isa("IO::Handle"))}=>inline_as {'(ref(' .$_[1].') eq "GLOB" ' .'&& Scalar::Util::openhandle(' .$_[1].')) ' .'|| (Scalar::Util::blessed(' .$_[1].') ' .'&& ' .$_[1].'->isa("IO::Handle"))'};subtype 'Object' =>as 'Ref' =>where {blessed($_)}=>inline_as {'Scalar::Util::blessed(' .$_[1].')'};subtype 'ClassName' =>as 'Str' =>where {is_class_loaded($_)}=>inline_as {'Class::Load::is_class_loaded(' .$_[1].')'};subtype 'RoleName' =>as 'ClassName' =>where {(Class::MOP::class_of($_)|| return)->isa('Moose::Meta::Role')}=>inline_as {$_[0]->parent()->_inline_check($_[1]).' && do {' .'my $meta = Class::MOP::class_of(' .$_[1].');' .'$meta && $meta->isa("Moose::Meta::Role");' .'}'};$registry->add_type_constraint(Moose::Meta::TypeConstraint::Parameterizable->new(name=>'ScalarRef',package_defined_in=>__PACKAGE__,parent=>Moose::Util::TypeConstraints::find_type_constraint('Ref'),constraint=>sub {ref($_)eq 'SCALAR' || ref($_)eq 'REF'},constraint_generator=>sub {my$type_parameter=shift;my$check=$type_parameter->_compiled_type_constraint;return sub {return$check->(${$_})}},inlined=>sub {'ref(' .$_[1].') eq "SCALAR" ' .'|| ref(' .$_[1].') eq "REF"'},inline_generator=>sub {my$self=shift;my$type_parameter=shift;my$val=shift;'(ref(' .$val .') eq "SCALAR" || ref(' .$val .') eq "REF") ' .'&& ' .$type_parameter->_inline_check('${(' .$val .')}')},));$registry->add_type_constraint(Moose::Meta::TypeConstraint::Parameterizable->new(name=>'ArrayRef',package_defined_in=>__PACKAGE__,parent=>Moose::Util::TypeConstraints::find_type_constraint('Ref'),constraint=>sub {ref($_)eq 'ARRAY'},constraint_generator=>sub {my$type_parameter=shift;my$check=$type_parameter->_compiled_type_constraint;return sub {for my$x (@$_){($check->($x))|| return}1}},inlined=>sub {'ref(' .$_[1].') eq "ARRAY"'},inline_generator=>sub {my$self=shift;my$type_parameter=shift;my$val=shift;'do {' .'my $check = ' .$val .';' .'ref($check) eq "ARRAY" ' .'&& &List::MoreUtils::all(' .'sub { ' .$type_parameter->_inline_check('$_').' }, ' .'@{$check}' .')' .'}'},));$registry->add_type_constraint(Moose::Meta::TypeConstraint::Parameterizable->new(name=>'HashRef',package_defined_in=>__PACKAGE__,parent=>Moose::Util::TypeConstraints::find_type_constraint('Ref'),constraint=>sub {ref($_)eq 'HASH'},constraint_generator=>sub {my$type_parameter=shift;my$check=$type_parameter->_compiled_type_constraint;return sub {for my$x (values %$_){($check->($x))|| return}1}},inlined=>sub {'ref(' .$_[1].') eq "HASH"'},inline_generator=>sub {my$self=shift;my$type_parameter=shift;my$val=shift;'do {' .'my $check = ' .$val .';' .'ref($check) eq "HASH" ' .'&& &List::MoreUtils::all(' .'sub { ' .$type_parameter->_inline_check('$_').' }, ' .'values %{$check}' .')' .'}'},));$registry->add_type_constraint(Moose::Meta::TypeConstraint::Parameterizable->new(name=>'Maybe',package_defined_in=>__PACKAGE__,parent=>Moose::Util::TypeConstraints::find_type_constraint('Item'),constraint=>sub {1},constraint_generator=>sub {my$type_parameter=shift;my$check=$type_parameter->_compiled_type_constraint;return sub {return 1 if not(defined($_))|| $check->($_);return}},inlined=>sub {'1'},inline_generator=>sub {my$self=shift;my$type_parameter=shift;my$val=shift;'!defined(' .$val .') ' .'|| (' .$type_parameter->_inline_check($val).')'},))}1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS

$fatpacked{"x86_64-linux-gnu-thread-multi/Package/Stash/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_PACKAGE_STASH_XS';
  package Package::Stash::XS;BEGIN {$Package::Stash::XS::AUTHORITY='cpan:DOY'}{$Package::Stash::XS::VERSION='0.28'}use strict;use warnings;use 5.008001;use XSLoader;XSLoader::load(__PACKAGE__,exists$Package::Stash::XS::{VERSION}? ${$Package::Stash::XS::{VERSION}}: (),);1;
X86_64-LINUX-GNU-THREAD-MULTI_PACKAGE_STASH_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='1.07';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
X86_64-LINUX-GNU-THREAD-MULTI_PARAMS_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/PerlIO/utf8_strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_PERLIO_UTF8_STRICT';
  package PerlIO::utf8_strict;{$PerlIO::utf8_strict::VERSION='0.004'}use strict;use warnings;use XSLoader;XSLoader::load(__PACKAGE__,__PACKAGE__->VERSION);1;
X86_64-LINUX-GNU-THREAD-MULTI_PERLIO_UTF8_STRICT

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Identify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_IDENTIFY';
  package Sub::Identify;use strict;use Exporter;BEGIN {our$VERSION='0.08';our@ISA=('Exporter');our%EXPORT_TAGS=(all=>[our@EXPORT_OK=qw(sub_name stash_name sub_fullname get_code_info get_code_location is_sub_constant) ]);our$IsPurePerl=1;unless ($ENV{PERL_SUB_IDENTIFY_PP}){if (eval {require XSLoader;XSLoader::load(__PACKAGE__,$VERSION);1}){$IsPurePerl=0}else {die $@ if $@ && $@ !~ /object version|loadable object/}}if ($IsPurePerl){require B;*get_code_info=sub ($) {my ($coderef)=@_;ref$coderef or return;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return;$cv->GV->isa('B::SPECIAL')and return;return ($cv->GV->STASH->NAME,$cv->GV->NAME)};*get_code_location=sub ($) {my ($coderef)=@_;ref$coderef or return;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')&& $cv->START->isa('B::COP')or return;return ($cv->START->file,$cv->START->line)}}if ($IsPurePerl || $] < 5.016){require B;*is_sub_constant=sub ($) {my ($coderef)=@_;ref$coderef or return 0;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return 0;my$p=prototype$coderef;defined$p && $p eq "" or return 0;return ($cv->CvFLAGS & B::CVf_CONST())==B::CVf_CONST()}}}sub stash_name ($) {(get_code_info($_[0]))[0]}sub sub_name ($) {(get_code_info($_[0]))[1]}sub sub_fullname ($) {join '::',get_code_info($_[0])}1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_IDENTIFY

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_NAME';
  package Sub::Name;$Sub::Name::VERSION='0.12';use 5.006;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw(subname);our@EXPORT_OK=@EXPORT;use XSLoader;XSLoader::load(__PACKAGE__,exists$Sub::Name::{VERSION}? ${$Sub::Name::{VERSION}}: (),);1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_NAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Test/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_TEST_MOOSE';
  package Test::Moose;$Test::Moose::VERSION='2.1213';use strict;use warnings;use Sub::Exporter;use Test::Builder;use List::MoreUtils 'all';use Moose::Util 'does_role','find_meta';my@exports=qw[meta_ok does_ok has_attribute_ok with_immutable];Sub::Exporter::setup_exporter({exports=>\@exports,groups=>{default=>\@exports }});my$Test=Test::Builder->new;sub meta_ok ($;$) {my ($class_or_obj,$message)=@_;$message ||="The object has a meta";if (find_meta($class_or_obj)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub does_ok ($$;$) {my ($class_or_obj,$does,$message)=@_;$message ||="The object does $does";if (does_role($class_or_obj,$does)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub has_attribute_ok ($$;$) {my ($class_or_obj,$attr_name,$message)=@_;$message ||="The object does has an attribute named $attr_name";my$meta=find_meta($class_or_obj);if ($meta->find_attribute_by_name($attr_name)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub with_immutable (&@) {my$block=shift;my$before=$Test->current_test;$block->(0);Class::MOP::class_of($_)->make_immutable for @_;$block->(1);my$num_tests=$Test->current_test - $before;my$all_passed=all {$_}($Test->summary)[-$num_tests..-1];return$all_passed}1;
X86_64-LINUX-GNU-THREAD-MULTI_TEST_MOOSE

$fatpacked{"x86_64-linux-gnu-thread-multi/Variable/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_VARIABLE_MAGIC';
  package Variable::Magic;use 5.008;use strict;use warnings;our$VERSION;BEGIN {$VERSION='0.55'}BEGIN {require XSLoader;XSLoader::load(__PACKAGE__,$VERSION)}sub wizard {if (@_ % 2){require Carp;Carp::croak('Wrong number of arguments for wizard()')}my%opts=@_;my@keys=qw<op_info data get set len clear free copy dup>;push@keys,'local' if MGf_LOCAL;push@keys,qw<fetch store exists delete copy_key> if VMG_UVAR;my ($wiz,$err);{local $@;$wiz=eval {_wizard(map$opts{$_},@keys)};$err=$@}if ($err){$err =~ s/\sat\s+.*?\n//;require Carp;Carp::croak($err)}return$wiz}use base qw<Exporter>;our@EXPORT=();our%EXPORT_TAGS=('funcs'=>[qw<wizard cast getdata dispell> ],'consts'=>[qw<MGf_COPY MGf_DUP MGf_LOCAL VMG_UVAR VMG_COMPAT_SCALAR_LENGTH_NOLEN VMG_COMPAT_SCALAR_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID VMG_COMPAT_ARRAY_UNDEF_CLEAR VMG_COMPAT_HASH_DELETE_NOUVAR_VOID VMG_COMPAT_CODE_COPY_CLONE VMG_COMPAT_GLOB_GET VMG_PERL_PATCHLEVEL VMG_THREADSAFE VMG_FORKSAFE VMG_OP_INFO_NAME VMG_OP_INFO_OBJECT> ],);our@EXPORT_OK=map {@$_}values%EXPORT_TAGS;$EXPORT_TAGS{'all'}=[@EXPORT_OK ];1;
X86_64-LINUX-GNU-THREAD-MULTI_VARIABLE_MAGIC

$fatpacked{"x86_64-linux-gnu-thread-multi/autobox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_AUTOBOX';
  package autobox;use 5.008;use strict;use warnings;use Carp;use XSLoader;use Scalar::Util;use Scope::Guard;use Storable;our$VERSION='2.82';XSLoader::load 'autobox',$VERSION;use autobox::universal ();my$SEQ=0;my$BINDINGS_CACHE={};my$CLASS_CACHE={};my%TYPES=(UNDEF=>1,INTEGER=>1,FLOAT=>1,NUMBER=>0,STRING=>1,SCALAR=>0,ARRAY=>1,HASH=>1,CODE=>1,UNIVERSAL=>0);my%ISA=(UNIVERSAL=>[0,[qw(SCALAR ARRAY HASH CODE) ]],SCALAR=>[1,[qw(STRING NUMBER) ]],NUMBER=>[2,[qw(INTEGER FLOAT) ]]);my%DEFAULT=(SCALAR=>'SCALAR',ARRAY=>'ARRAY',HASH=>'HASH',CODE=>'CODE');sub _uniq($) {my$list=shift;my (%seen,@uniq);for my$element (@$list){next if ($seen{$element});push@uniq,$element;$seen{$element}=1}return [@uniq ]}sub _generate_class($) {my$isa=_uniq(shift);if (@$isa==1){my$class=$isa->[0];_make_class_accessor($class);return$class}my$key=Storable::freeze($isa);return$CLASS_CACHE->{$key}||=do {my$class=sprintf('autobox::_shim_%d_',++$SEQ);my$synthetic_class_isa=_get_isa($class);@$synthetic_class_isa=@$isa;_make_class_accessor($class);$class}}sub _make_class_accessor ($) {my$class=shift;return unless (defined$class);{no strict 'refs';*{"$class\::autobox_class"}=sub {$class}unless (*{"$class\::autobox_class"}{CODE})}}sub _pretty_print($) {my$hash={%{shift()}};my%synthetic=reverse(%$CLASS_CACHE);for my$type (keys %$hash){my$class=$hash->{$type};$hash->{$type}=$synthetic{$class}? [_get_isa($class)]: [$class ]}return$hash}sub _debug ($) {my$bindings=shift;require Data::Dumper;no warnings qw(once);local ($|,$Data::Dumper::Indent,$Data::Dumper::Terse,$Data::Dumper::Sortkeys)=(1,1,1,1);print STDERR Data::Dumper::Dumper($bindings),$/}sub _isa($$) {my ($ref,$class)=@_;return Scalar::Util::blessed($ref)? $ref->isa($class): ref($ref)eq $class}sub _get_isa($) {my$class=shift;my$isa=do {no strict 'refs';*{"$class\::ISA"}{ARRAY}};return wantarray ? @$isa : $isa}sub _install ($) {my$bindings=shift;$^H{autobox}=$bindings;$BINDINGS_CACHE->{$bindings}=$bindings}sub _expand_namespace($$) {my ($class,$type)=@_;Carp::confess("_expand_namespace not called in list context")unless (wantarray);if ((defined$class)&& ($class ne '')){($class =~ /::$/)? "$class$type" : $class}else {()}}sub import {my$class=shift;my%args=((@_==1)&& _isa($_[0],'HASH'))? %{shift()}: @_;my$debug=delete$args{DEBUG};%args=%DEFAULT unless (%args);for my$type (keys%TYPES){if (exists$args{$type}){if (_isa($args{$type},'ARRAY')){$args{$type}=[@{$args{$type}}]}else {$args{$type}=[$args{$type}]}}else {$args{$type}=[]}}my$default=delete$args{DEFAULT};if ($default){$default=[$default ]unless (_isa($default,'ARRAY'));for my$type (keys%DEFAULT){next if (@{$args{$type}});push @{$args{$type}},map {_expand_namespace($_,$type)}@$default}}for my$vtype (sort {$ISA{$a}->[0]<=> $ISA{$b}->[0]}keys%ISA){next unless ($args{$vtype});my@types=@{$ISA{$vtype}->[1]};for my$type (@types){if (_isa($args{$vtype},'ARRAY')){push @{$args{$type}},map {_expand_namespace($_,$vtype)}@{$args{$vtype}}}else {push @{$args{$type}},_expand_namespace($args{$vtype},$vtype)}}delete$args{$vtype}}my$bindings;$bindings=$^H{autobox}? {%{$^H{autobox}}}: {};my%synthetic=reverse (%$CLASS_CACHE);for my$type (keys%args){Carp::confess("unrecognized option: '",(defined$type ? $type : '<undef>'),"'")unless ($TYPES{$type});my (@isa,$class);if ($class=$bindings->{$type}){@isa=$synthetic{$class}? _get_isa($class): ($class)}push@isa,map {_expand_namespace($_,$type)}@{$args{$type}};$bindings->{$type}=[@isa ]}for my$type (keys %$bindings){my$isa=$bindings->{$type};if (@$isa==0){delete$bindings->{$type}}else {$bindings->{$type}=_generate_class($isa)}}$^H |=0x80020000;_install($bindings);my$scope=_scope();my$old_scope=exists($^H{autobox_scope})? $^H{autobox_scope}: 0;my$new_scope;if ($scope==$old_scope){$new_scope=0}else {$^H{autobox_scope}=$scope;$new_scope=1}if ($debug){$debug=\&_debug unless (_isa($debug,'CODE'));$debug->(_pretty_print($bindings))}return unless ($new_scope);my$guard=Scope::Guard->new(sub {_leave()});$^H{autobox_leave}=$guard;_enter()}sub unimport {my ($class,@args)=@_;return unless ($^H{autobox});my$bindings;if (@args){$bindings={%{$^H{autobox}}};my%args=map {$_=>1}@args;for my$vtype (sort {$ISA{$a}->[0]<=> $ISA{$b}->[0]}keys%ISA){next unless ($args{$vtype});$args{$_}=1 for (@{$ISA{$vtype}->[1]});delete$args{$vtype}}for my$type (keys%args){Carp::confess("unrecognized option: '",(defined$type ? $type : '<undef>'),"'")unless ($TYPES{$type});delete$bindings->{$type}}}else {$bindings={}}if (%$bindings){_install($bindings)}else {$^H &=~0x80020000;delete $^H{autobox};delete $^H{autobox_scope};delete $^H{autobox_leave}}}1;
X86_64-LINUX-GNU-THREAD-MULTI_AUTOBOX

$fatpacked{"x86_64-linux-gnu-thread-multi/autobox/universal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_AUTOBOX_UNIVERSAL';
  package autobox::universal;use strict;use warnings;use autobox ();use Exporter ();our@ISA=qw(Exporter);our@EXPORT_OK=qw(type);1;
X86_64-LINUX-GNU-THREAD-MULTI_AUTOBOX_UNIVERSAL

$fatpacked{"x86_64-linux-gnu-thread-multi/metaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_METACLASS';
  package metaclass;$metaclass::VERSION='2.1213';use strict;use warnings;use Module::Runtime 'use_package_optimistically','use_module';use Class::Load 'load_class';use Scalar::Util 'blessed';use Try::Tiny;use Class::MOP;sub import {my ($class,@args)=@_;unshift@args,"metaclass" if@args % 2==1;my%options=@args;my$meta_name=exists$options{meta_name}? $options{meta_name}: 'meta';my$metaclass=delete$options{metaclass};unless (defined$metaclass){$metaclass="Class::MOP::Class"}else {use_package_optimistically($metaclass)}($metaclass->isa('Class::MOP::Class'))|| die use_module('Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass')->new(class_name=>$metaclass);for my$key (grep {/_(?:meta)?class$/}keys%options){unless (ref(my$class=$options{$key})){use_package_optimistically($class)}}my$package=caller();my$meta=$metaclass->initialize($package=>%options);$meta->_add_meta_method($meta_name)if defined$meta_name}1;
X86_64-LINUX-GNU-THREAD-MULTI_METACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/oose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_OOSE';
  package oose;$oose::VERSION='2.1213';use strict;use warnings;use Moose::Util ();BEGIN {my$package;sub import {$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;Moose::Util::_load_user_class($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/}}1;
X86_64-LINUX-GNU-THREAD-MULTI_OOSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#use Data::Dumper qw( Dumper );
use FindBin qw( $Bin);

require Moose::Role;
require MooseX::App;
require Sub::Identify;
#my $funcname = "ShellUtils";
#my %symbols = ();
#my $package =__PACKAGE__; #bring it in at run-time
#{
#    no strict;
#    %symbols = %{$package . "::"}; #See Symbol Tables on perlmod
#}

use lib ( $FindBin::Bin.'/' , $FindBin::Bin.'/lib' , $FindBin::Bin.'/My' );

use App::CloudMining;

my $new = App::CloudMining->new_with_command->run;




exit;

 
